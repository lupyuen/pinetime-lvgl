#![feature(prelude_import)]
//! LVGL API for Rust. Contains Rust bindings for LVGL API for C, generated by `bindgen`.
//! Also includes safe versions of LVGL APIs created specially for Rust.

#![no_std]
//  Don't link with standard Rust library, which is not compatible with embedded systems
#![feature(trace_macros)]
//  Enable tracing of macros
#![feature(proc_macro_hygiene)]
#[prelude_import]
use core::prelude::v1::*;
#[macro_use]
extern crate core;
#[macro_use]
extern crate compiler_builtins;
//  Allow proc macros to be unhygienic

extern crate macros as lvgl_macros;
//  Import Procedural Macros from `macros` library

//  If building for Mynewt OS...
/// Export Mynewt API
#[cfg(feature = "mynewt_os")]
pub use mynewt;
//  Export Mynewt API

//  Allow unused imports
#[allow(unused_imports)]
pub mod core {
    //  Lvgl Core API. Export folder `core` as Rust module `lvgl::core`

    //  Allow unused imports
    //  Lvgl Draw API. Export folder `draw` as Rust module `lvgl::draw`

    //  Allow unused imports
    //  Lvgl Font API. Export folder `font` as Rust module `lvgl::font`

    //  TODO: pub mod hal;            //  Lvgl HAL API. Export folder `hal` as Rust module `lvgl::hal`
    //  TODO: pub mod misc;           //  Lvgl Misc API. Export folder `misc` as Rust module `lvgl::misc`

    //  Allow unused imports
    //  Lvgl Themes API. Export folder `themes` as Rust module `lvgl::themes`

    //  Allow unused imports
    //  Lvgl Widgets API. Export folder `widgets` as Rust module `lvgl::widgets`

    //  TODO: pub mod themes;         //  Lvgl Themes API. Export folder `themes` as Rust module `lvgl::themes`

    //  Allow macros from Rust module `util`
    //  Lvgl Utility API. Export folder `util` as Rust module `lvgl::util`

    //  If building for RIOT OS...
    //  Lvgl Console API. Export `console.rs` as Rust module `lvgl::console`

    //  If building for RIOT OS...

    //  Allow type names to have non-camel case




    //  TODO

    //  If building for RIOT OS...
    //  Strn may be copied

    //  If building for RIOT OS...
    //  StrnRep may be copied

    //  If building for RIOT OS...
    //  Last byte must be 0.



    //  Last byte must be 0.
    //  Don't count the terminating null.
    //  Look for the null termination.
    //  String too long


    //  Last byte must be 0.

    //  Last byte must be 0.
    //  Not implemented

    //  Last byte must be 0.

    //  Last byte must be 0.

    //  If building for RIOT OS...

    //  If building for RIOT OS...

    //  If building for RIOT OS...

    //  If building for RIOT OS...

    //  If building for RIOT OS...

    //! LVGL Core API for Rust
    #[cfg(feature = "mynewt_os")]
    use mynewt::{result::*, Out, Ptr, Strn};
    /// Contains Rust bindings for LVGL Core Display API `lv_disp`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod disp {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_DISP_DEF_REFR_PERIOD: u32 = 30;
        pub const LV_DISP_SMALL_LIMIT: u32 = 30;
        pub const LV_DISP_MEDIUM_LIMIT: u32 = 50;
        pub const LV_DISP_LARGE_LIMIT: u32 = 70;
        pub type lv_coord_t = i16;
        pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub const LV_ALIGN_CENTER: lv_align_t = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
        pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
        pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
        pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
        #[doc = " Alignments"]
        pub type _bindgen_ty_3 = u32;
        pub type lv_align_t = u8;
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Tasks execute this type type of functions."]
        pub type lv_task_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_task_t {
            #[doc = "< How often the task should run"]
            pub period: u32,
            #[doc = "< Last time the task ran"]
            pub last_run: u32,
            #[doc = "< Task function"]
            pub task_cb: lv_task_cb_t,
            #[doc = "< Custom user data"]
            pub user_data: *mut ::cty::c_void,
            #[doc =
              "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
            pub repeat_count: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for _lv_task_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_task_t {
            #[inline]
            pub fn prio(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_prio(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(prio: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let prio: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(prio)
                                                    };
                                                prio as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_task_t = _lv_task_t;
        #[doc = " Structure for holding display buffer information."]
        #[repr(C)]
        pub struct lv_disp_buf_t {
            #[doc = "< First display buffer."]
            pub buf1: *mut ::cty::c_void,
            #[doc = "< Second display buffer."]
            pub buf2: *mut ::cty::c_void,
            pub buf_act: *mut ::cty::c_void,
            pub size: u32,
            pub area: lv_area_t,
            pub flushing: ::cty::c_int,
            pub flushing_last: ::cty::c_int,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_disp_buf_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_disp_buf_t {
            #[inline]
            pub fn last_area(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_area(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn last_part(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_part(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(last_area: u32, last_part: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let last_area: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_area)
                                                    };
                                                last_area as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let last_part: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_part)
                                                    };
                                                last_part as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Display Driver structure to be registered by HAL"]
        #[repr(C)]
        pub struct _disp_drv_t {
            #[doc = "< Horizontal resolution."]
            pub hor_res: lv_coord_t,
            #[doc = "< Vertical resolution."]
            pub ver_res: lv_coord_t,
            #[doc =
              " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
            #[doc =
              " LVGL will use this buffer(s) to draw the screens contents"]
            pub buffer: *mut lv_disp_buf_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc =
              " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
            #[doc = " called when finished"]
            pub flush_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                          *mut _disp_drv_t,
                                                                      area:
                                                                          *const lv_area_t,
                                                                      color_p:
                                                                          *mut lv_color_t)>,
            #[doc =
              " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
            #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
            pub rounder_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        area:
                                                                            *mut lv_area_t)>,
            #[doc =
              " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
            #[doc =
              " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
            #[doc =
              " __Note:__ Much slower then drawing with supported color formats."]
            pub set_px_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                           *mut _disp_drv_t,
                                                                       buf:
                                                                           *mut u8,
                                                                       buf_w:
                                                                           lv_coord_t,
                                                                       x:
                                                                           lv_coord_t,
                                                                       y:
                                                                           lv_coord_t,
                                                                       color:
                                                                           lv_color_t,
                                                                       opa:
                                                                           lv_opa_t)>,
            #[doc =
              " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
            #[doc = " number of flushed pixels"]
            pub monitor_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        time:
                                                                            u32,
                                                                        px:
                                                                            u32)>,
            #[doc =
              " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
            #[doc = " For example flushing or GPU"]
            #[doc =
              " User can execute very simple tasks here or yield the task"]
            pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                         *mut _disp_drv_t)>,
            #[doc =
              " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
            pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                                 *mut _disp_drv_t)>,
            #[doc = " OPTIONAL: called to wait while the gpu is working"]
            pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                             *mut _disp_drv_t)>,
            #[doc = " On CHROMA_KEYED images this color will be transparent."]
            #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
            pub color_chroma_key: lv_color_t,
            #[doc = "< Custom display driver user data"]
            pub user_data: lv_disp_drv_user_data_t,
        }
        impl Default for _disp_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_drv_t {
            #[inline]
            pub fn antialiasing(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_antialiasing(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rotated(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_rotated(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dpi(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_dpi(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialiasing: u32, rotated: u32, dpi: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialiasing: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialiasing)
                                                    };
                                                antialiasing as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let rotated: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(rotated)
                                                    };
                                                rotated as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 10u8,
                                            {
                                                let dpi: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(dpi)
                                                    };
                                                dpi as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_drv_t = _disp_drv_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _disp_t {
            pub driver: lv_disp_drv_t,
            pub refr_task: *mut lv_task_t,
            #[doc = " Screens of the display"]
            pub scr_ll: lv_ll_t,
            #[doc = "< Currently active screen on this display"]
            pub act_scr: *mut _lv_obj_t,
            #[doc = "< Previous screen. Used during screen animations"]
            pub prev_scr: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_top"]
            pub top_layer: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_sys"]
            pub sys_layer: *mut _lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc = "< Default display color when screens are transparent"]
            pub bg_color: lv_color_t,
            #[doc = "< An image source to display as wallpaper"]
            pub bg_img: *const ::cty::c_void,
            #[doc = "<Opacity of the background color or wallpaper"]
            pub bg_opa: lv_opa_t,
            #[doc = " Invalidated (marked to redraw) areas"]
            pub inv_areas: [lv_area_t; 32usize],
            pub inv_area_joined: [u8; 32usize],
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc = "< Last time there was activity on this display"]
            pub last_activity_time: u32,
        }
        impl Default for _disp_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_t {
            #[inline]
            pub fn del_prev(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_del_prev(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(del_prev: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let del_prev: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(del_prev)
                                                    };
                                                del_prev as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn inv_p(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_inv_p(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(inv_p: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 10u8,
                                            {
                                                let inv_p: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(inv_p)
                                                    };
                                                inv_p as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_t = _disp_t;
        pub const lv_disp_size_t_LV_DISP_SIZE_SMALL: lv_disp_size_t = 0;
        pub const lv_disp_size_t_LV_DISP_SIZE_MEDIUM: lv_disp_size_t = 1;
        pub const lv_disp_size_t_LV_DISP_SIZE_LARGE: lv_disp_size_t = 2;
        pub const lv_disp_size_t_LV_DISP_SIZE_EXTRA_LARGE: lv_disp_size_t = 3;
        pub type lv_disp_size_t = u32;
        #[doc = " Initialize a display driver with default values."]
        #[doc =
          " It is used to have known values in the fields and not junk in memory."]
        #[doc = " After it you can safely set only the fields you need."]
        #[doc = " - __`driver`__: pointer to driver variable to initialize"]
        pub fn disp_drv_init(driver: *mut lv_disp_drv_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a display driver with default values."]
                #[doc =
                  " It is used to have known values in the fields and not junk in memory."]
                #[doc =
                  " After it you can safely set only the fields you need."]
                #[doc =
                  " - __`driver`__: pointer to driver variable to initialize"]
                pub fn lv_disp_drv_init(driver: *mut lv_disp_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_drv_init(driver as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize a display buffer"]
        #[doc =
          " - __`disp_buf`__: pointer `lv_disp_buf_t` variable to initialize"]
        #[doc =
          " - __`buf1`__: A buffer to be used by LVGL to draw the image."]
        #[doc = "             Always has to specified and can't be NULL."]
        #[doc =
          "             Can be an array allocated by the user. E.g. `static lv_color_t disp_buf1[1024 * 10]`"]
        #[doc = "             Or a memory address e.g. in external SRAM"]
        #[doc =
          " - __`buf2`__: Optionally specify a second buffer to make image rendering and image flushing"]
        #[doc = "             (sending to the display) parallel."]
        #[doc =
          "             In the `disp_drv->flush` you should use DMA or similar hardware to send"]
        #[doc = "             the image to the display in the background."]
        #[doc =
          "             It lets LVGL to render next frame into the other buffer while previous is being"]
        #[doc = " sent. Set to `NULL` if unused."]
        #[doc =
          " - __`size_in_px_cnt`__: size of the `buf1` and `buf2` in pixel count."]
        pub fn disp_buf_init(disp_buf: *mut lv_disp_buf_t, buf1: Ptr,
                             buf2: Ptr, size_in_px_cnt: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a display buffer"]
                #[doc =
                  " - __`disp_buf`__: pointer `lv_disp_buf_t` variable to initialize"]
                #[doc =
                  " - __`buf1`__: A buffer to be used by LVGL to draw the image."]
                #[doc =
                  "             Always has to specified and can't be NULL."]
                #[doc =
                  "             Can be an array allocated by the user. E.g. `static lv_color_t disp_buf1[1024 * 10]`"]
                #[doc =
                  "             Or a memory address e.g. in external SRAM"]
                #[doc =
                  " - __`buf2`__: Optionally specify a second buffer to make image rendering and image flushing"]
                #[doc = "             (sending to the display) parallel."]
                #[doc =
                  "             In the `disp_drv->flush` you should use DMA or similar hardware to send"]
                #[doc =
                  "             the image to the display in the background."]
                #[doc =
                  "             It lets LVGL to render next frame into the other buffer while previous is being"]
                #[doc = " sent. Set to `NULL` if unused."]
                #[doc =
                  " - __`size_in_px_cnt`__: size of the `buf1` and `buf2` in pixel count."]
                pub fn lv_disp_buf_init(disp_buf: *mut lv_disp_buf_t,
                                        buf1: *mut ::cty::c_void,
                                        buf2: *mut ::cty::c_void,
                                        size_in_px_cnt: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_buf_init(disp_buf as *mut lv_disp_buf_t,
                                 buf1 as *mut ::cty::c_void,
                                 buf2 as *mut ::cty::c_void,
                                 size_in_px_cnt as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Register an initialized display driver."]
        #[doc = " Automatically set the first display as active."]
        #[doc =
          " - __`driver`__: pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)"]
        #[doc = " Return: pointer to the new display or NULL on error"]
        pub fn disp_drv_register(driver: *mut lv_disp_drv_t)
         -> MynewtResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Register an initialized display driver."]
                #[doc = " Automatically set the first display as active."]
                #[doc =
                  " - __`driver`__: pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)"]
                #[doc =
                  " Return: pointer to the new display or NULL on error"]
                pub fn lv_disp_drv_register(driver: *mut lv_disp_drv_t)
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_drv_register(driver as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Update the driver in run time."]
        #[doc =
          " - __`disp`__: pointer to a display. (return value of `lv_disp_drv_register`)"]
        #[doc = " - __`new_drv`__: pointer to the new driver"]
        pub fn disp_drv_update(disp: *mut lv_disp_t,
                               new_drv: *mut lv_disp_drv_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Update the driver in run time."]
                #[doc =
                  " - __`disp`__: pointer to a display. (return value of `lv_disp_drv_register`)"]
                #[doc = " - __`new_drv`__: pointer to the new driver"]
                pub fn lv_disp_drv_update(disp: *mut lv_disp_t,
                                          new_drv: *mut lv_disp_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_drv_update(disp as *mut lv_disp_t,
                                   new_drv as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Remove a display"]
        #[doc = " - __`disp`__: pointer to display"]
        pub fn disp_remove(disp: *mut lv_disp_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove a display"]
                #[doc = " - __`disp`__: pointer to display"]
                pub fn lv_disp_remove(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_remove(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a default screen. The new screens will be created on it by default."]
        #[doc = " - __`disp`__: pointer to a display"]
        pub fn disp_set_default(disp: *mut lv_disp_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a default screen. The new screens will be created on it by default."]
                #[doc = " - __`disp`__: pointer to a display"]
                pub fn lv_disp_set_default(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_set_default(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the default display"]
        #[doc = " Return: pointer to the default display"]
        pub fn disp_get_default() -> MynewtResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the default display"]
                #[doc = " Return: pointer to the default display"]
                pub fn lv_disp_get_default()
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_default();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the horizontal resolution of a display"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: the horizontal resolution of the display"]
        pub fn disp_get_hor_res(disp: *mut lv_disp_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the horizontal resolution of a display"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc = " Return: the horizontal resolution of the display"]
                pub fn lv_disp_get_hor_res(disp: *mut lv_disp_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_hor_res(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the vertical resolution of a display"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: the vertical resolution of the display"]
        pub fn disp_get_ver_res(disp: *mut lv_disp_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the vertical resolution of a display"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc = " Return: the vertical resolution of the display"]
                pub fn lv_disp_get_ver_res(disp: *mut lv_disp_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_ver_res(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get if anti-aliasing is enabled for a display or not"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: true: anti-aliasing is enabled; false: disabled"]
        pub fn disp_get_antialiasing(disp: *mut lv_disp_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get if anti-aliasing is enabled for a display or not"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc =
                  " Return: true: anti-aliasing is enabled; false: disabled"]
                pub fn lv_disp_get_antialiasing(disp: *mut lv_disp_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_antialiasing(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the DPI of the display"]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: dpi of the display"]
        pub fn disp_get_dpi(disp: *mut lv_disp_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the DPI of the display"]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc = " Return: dpi of the display"]
                pub fn lv_disp_get_dpi(disp: *mut lv_disp_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_dpi(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the size category of the display based on it's hor. res. and dpi."]
        #[doc =
          " - __`disp`__: pointer to a display (NULL to use the default display)"]
        #[doc = " Return: LV_DISP_SIZE_SMALL/MEDIUM/LARGE/EXTRA_LARGE"]
        pub fn disp_get_size_category(disp: *mut lv_disp_t)
         -> MynewtResult<lv_disp_size_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the size category of the display based on it's hor. res. and dpi."]
                #[doc =
                  " - __`disp`__: pointer to a display (NULL to use the default display)"]
                #[doc =
                  " Return: LV_DISP_SIZE_SMALL/MEDIUM/LARGE/EXTRA_LARGE"]
                pub fn lv_disp_get_size_category(disp: *mut lv_disp_t)
                -> lv_disp_size_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_size_category(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Call in the display driver's `flush_cb` function when the flushing is finished"]
        #[doc =
          " - __`disp_drv`__: pointer to display driver in `flush_cb` where this function is called"]
        pub fn disp_flush_ready(disp_drv: *mut lv_disp_drv_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Call in the display driver's `flush_cb` function when the flushing is finished"]
                #[doc =
                  " - __`disp_drv`__: pointer to display driver in `flush_cb` where this function is called"]
                pub fn lv_disp_flush_ready(disp_drv: *mut lv_disp_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_flush_ready(disp_drv as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Tell if it's the last area of the refreshing process."]
        #[doc =
          " Can be called from `flush_cb` to execute some special display refreshing if needed when all areas area flushed."]
        #[doc = " - __`disp_drv`__: pointer to display driver"]
        #[doc =
          " Return: true: it's the last area to flush; false: there are other areas too which will be refreshed soon"]
        pub fn disp_flush_is_last(disp_drv: *mut lv_disp_drv_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Tell if it's the last area of the refreshing process."]
                #[doc =
                  " Can be called from `flush_cb` to execute some special display refreshing if needed when all areas area flushed."]
                #[doc = " - __`disp_drv`__: pointer to display driver"]
                #[doc =
                  " Return: true: it's the last area to flush; false: there are other areas too which will be refreshed soon"]
                pub fn lv_disp_flush_is_last(disp_drv: *mut lv_disp_drv_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_flush_is_last(disp_drv as *mut lv_disp_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the next display."]
        #[doc =
          " - __`disp`__: pointer to the current display. NULL to initialize."]
        #[doc =
          " Return: the next display or NULL if no more. Give the first display when the parameter is NULL"]
        pub fn disp_get_next(disp: *mut lv_disp_t)
         -> MynewtResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the next display."]
                #[doc =
                  " - __`disp`__: pointer to the current display. NULL to initialize."]
                #[doc =
                  " Return: the next display or NULL if no more. Give the first display when the parameter is NULL"]
                pub fn lv_disp_get_next(disp: *mut lv_disp_t)
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_next(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the internal buffer of a display"]
        #[doc = " - __`disp`__: pointer to a display"]
        #[doc = " Return: pointer to the internal buffers"]
        pub fn disp_get_buf(disp: *mut lv_disp_t)
         -> MynewtResult<*mut lv_disp_buf_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the internal buffer of a display"]
                #[doc = " - __`disp`__: pointer to a display"]
                #[doc = " Return: pointer to the internal buffers"]
                pub fn lv_disp_get_buf(disp: *mut lv_disp_t)
                -> *mut lv_disp_buf_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_disp_get_buf(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of areas in the buffer"]
        #[doc = " Return: number of invalid areas"]
        pub fn disp_get_inv_buf_size(disp: *mut lv_disp_t)
         -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of areas in the buffer"]
                #[doc = " Return: number of invalid areas"]
                pub fn lv_disp_get_inv_buf_size(disp: *mut lv_disp_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_inv_buf_size(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)"]
        #[doc = " - __`disp`__: pointer to to display to check"]
        #[doc = " Return: true: double buffered; false: not double buffered"]
        pub fn disp_is_double_buf(disp: *mut lv_disp_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)"]
                #[doc = " - __`disp`__: pointer to to display to check"]
                #[doc =
                  " Return: true: double buffered; false: not double buffered"]
                pub fn lv_disp_is_double_buf(disp: *mut lv_disp_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_is_double_buf(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Check the driver configuration if it's TRUE double buffered (both `buf1` and `buf2` are set and"]
        #[doc = " `size` is screen sized)"]
        #[doc = " - __`disp`__: pointer to to display to check"]
        #[doc = " Return: true: double buffered; false: not double buffered"]
        pub fn disp_is_true_double_buf(disp: *mut lv_disp_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check the driver configuration if it's TRUE double buffered (both `buf1` and `buf2` are set and"]
                #[doc = " `size` is screen sized)"]
                #[doc = " - __`disp`__: pointer to to display to check"]
                #[doc =
                  " Return: true: double buffered; false: not double buffered"]
                pub fn lv_disp_is_true_double_buf(disp: *mut lv_disp_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_is_true_double_buf(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub type lv_drag_dir_t = u8;
        #[repr(C)]
        pub struct lv_style_t {
            pub map: *mut u8,
        }
        impl Default for lv_style_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_obj_t {
            #[doc = "< Pointer to the parent object"]
            pub parent: *mut _lv_obj_t,
            #[doc = "< Linked list to store the children objects"]
            pub child_ll: lv_ll_t,
            #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
            pub coords: lv_area_t,
            #[doc = "< Event callback function"]
            pub event_cb: lv_event_cb_t,
            #[doc = "< Object type specific signal function"]
            pub signal_cb: lv_signal_cb_t,
            #[doc = "< Object type specific design function"]
            pub design_cb: lv_design_cb_t,
            #[doc = "< Object type specific extended data"]
            pub ext_attr: *mut ::cty::c_void,
            pub style_list: lv_style_list_t,
            #[doc = "< Extra click padding in horizontal direction"]
            pub ext_click_pad_hor: u8,
            #[doc = "< Extra click padding in vertical direction"]
            pub ext_click_pad_ver: u8,
            #[doc = "< EXTend the size in every direction for drawing."]
            pub ext_draw_pad: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            #[doc = "< Automatically happening actions can be prevented."]
            #[doc = "'OR'ed values from `lv_protect_t`"]
            pub protect: u8,
            pub state: lv_state_t,
            #[doc = "< Information about the last call to ::lv_obj_align."]
            pub realign: lv_realign_t,
            #[doc = "< Custom user data for object."]
            pub user_data: lv_obj_user_data_t,
        }
        impl Default for _lv_obj_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_obj_t {
            #[inline]
            pub fn click(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_throw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_throw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn parent_event(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_parent_event(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn adv_hittest(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_adv_hittest(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn gesture_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_gesture_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn focus_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_focus_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_dir(&self) -> lv_drag_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn base_dir(&self) -> lv_bidi_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(click: u8, drag: u8, drag_throw: u8,
                                  drag_parent: u8, hidden: u8, top: u8,
                                  parent_event: u8, adv_hittest: u8,
                                  gesture_parent: u8, focus_parent: u8,
                                  drag_dir: lv_drag_dir_t,
                                  base_dir: lv_bidi_dir_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let click: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click)
                                                    };
                                                click as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag)
                                                    };
                                                drag as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let drag_throw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_throw)
                                                    };
                                                drag_throw as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let drag_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_parent)
                                                    };
                                                drag_parent as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top)
                                                    };
                                                top as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let parent_event: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(parent_event)
                                                    };
                                                parent_event as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let adv_hittest: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(adv_hittest)
                                                    };
                                                adv_hittest as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let gesture_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(gesture_parent)
                                                    };
                                                gesture_parent as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let focus_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(focus_parent)
                                                    };
                                                focus_parent as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 3u8,
                                            {
                                                let drag_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_dir)
                                                    };
                                                drag_dir as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 2u8,
                                            {
                                                let base_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(base_dir)
                                                    };
                                                base_dir as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_obj_t = _lv_obj_t;
        #[doc = " Return with a pointer to the active screen"]
        #[doc =
          " - __`disp`__: pointer to display which active screen should be get. (NULL to use the default"]
        #[doc = " screen)"]
        #[doc =
          " Return: pointer to the active screen object (loaded by 'lv_scr_load()')"]
        pub fn disp_get_scr_act(disp: *mut lv_disp_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with a pointer to the active screen"]
                #[doc =
                  " - __`disp`__: pointer to display which active screen should be get. (NULL to use the default"]
                #[doc = " screen)"]
                #[doc =
                  " Return: pointer to the active screen object (loaded by 'lv_scr_load()')"]
                pub fn lv_disp_get_scr_act(disp: *mut lv_disp_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_scr_act(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Return with a pointer to the previous screen. Only used during screen transitions."]
        #[doc =
          " - __`disp`__: pointer to display which previous screen should be get. (NULL to use the default"]
        #[doc = " screen)"]
        #[doc =
          " Return: pointer to the previous screen object or NULL if not used now"]
        pub fn disp_get_scr_prev(disp: *mut lv_disp_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Return with a pointer to the previous screen. Only used during screen transitions."]
                #[doc =
                  " - __`disp`__: pointer to display which previous screen should be get. (NULL to use the default"]
                #[doc = " screen)"]
                #[doc =
                  " Return: pointer to the previous screen object or NULL if not used now"]
                pub fn lv_disp_get_scr_prev(disp: *mut lv_disp_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_scr_prev(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Make a screen active"]
        #[doc = " - __`scr`__: pointer to a screen"]
        pub fn disp_load_scr(scr: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make a screen active"]
                #[doc = " - __`scr`__: pointer to a screen"]
                pub fn lv_disp_load_scr(scr: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_load_scr(scr as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Return with the top layer. (Same on every screen and it is above the normal screen layer)"]
        #[doc =
          " - __`disp`__: pointer to display which top layer should be get. (NULL to use the default screen)"]
        #[doc =
          " Return: pointer to the top layer object  (transparent screen sized lv_obj)"]
        pub fn disp_get_layer_top(disp: *mut lv_disp_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Return with the top layer. (Same on every screen and it is above the normal screen layer)"]
                #[doc =
                  " - __`disp`__: pointer to display which top layer should be get. (NULL to use the default screen)"]
                #[doc =
                  " Return: pointer to the top layer object  (transparent screen sized lv_obj)"]
                pub fn lv_disp_get_layer_top(disp: *mut lv_disp_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_layer_top(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Return with the sys. layer. (Same on every screen and it is above the normal screen and the top"]
        #[doc = " layer)"]
        #[doc =
          " - __`disp`__: pointer to display which sys. layer  should be get. (NULL to use the default screen)"]
        #[doc =
          " Return: pointer to the sys layer object  (transparent screen sized lv_obj)"]
        pub fn disp_get_layer_sys(disp: *mut lv_disp_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Return with the sys. layer. (Same on every screen and it is above the normal screen and the top"]
                #[doc = " layer)"]
                #[doc =
                  " - __`disp`__: pointer to display which sys. layer  should be get. (NULL to use the default screen)"]
                #[doc =
                  " Return: pointer to the sys layer object  (transparent screen sized lv_obj)"]
                pub fn lv_disp_get_layer_sys(disp: *mut lv_disp_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_layer_sys(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Assign a screen to a display."]
        #[doc =
          " - __`disp`__: pointer to a display where to assign the screen"]
        #[doc = " - __`scr`__: pointer to a screen object to assign"]
        pub fn disp_assign_screen(disp: *mut lv_disp_t, scr: *mut lv_obj_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Assign a screen to a display."]
                #[doc =
                  " - __`disp`__: pointer to a display where to assign the screen"]
                #[doc = " - __`scr`__: pointer to a screen object to assign"]
                pub fn lv_disp_assign_screen(disp: *mut lv_disp_t,
                                             scr: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_assign_screen(disp as *mut lv_disp_t,
                                      scr as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the background color of a display"]
        #[doc = " - __`disp`__: pointer to a display"]
        #[doc = " - __`color`__: color of the background"]
        pub fn disp_set_bg_color(disp: *mut lv_disp_t, color: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the background color of a display"]
                #[doc = " - __`disp`__: pointer to a display"]
                #[doc = " - __`color`__: color of the background"]
                pub fn lv_disp_set_bg_color(disp: *mut lv_disp_t,
                                            color: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_set_bg_color(disp as *mut lv_disp_t,
                                     color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the background image of a display"]
        #[doc = " - __`disp`__: pointer to a display"]
        #[doc =
          " - __`img_src`__: path to file or pointer to an `lv_img_dsc_t` variable"]
        pub fn disp_set_bg_image(disp: *mut lv_disp_t,
                                 img_src: *const ::cty::c_void)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the background image of a display"]
                #[doc = " - __`disp`__: pointer to a display"]
                #[doc =
                  " - __`img_src`__: path to file or pointer to an `lv_img_dsc_t` variable"]
                pub fn lv_disp_set_bg_image(disp: *mut lv_disp_t,
                                            img_src: *const ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_set_bg_image(disp as *mut lv_disp_t,
                                     img_src as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Opacity of the background"]
        #[doc = " - __`disp`__: pointer to a display"]
        #[doc = " - __`opa`__: opacity (0..255)"]
        pub fn disp_set_bg_opa(disp: *mut lv_disp_t, opa: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Opacity of the background"]
                #[doc = " - __`disp`__: pointer to a display"]
                #[doc = " - __`opa`__: opacity (0..255)"]
                pub fn lv_disp_set_bg_opa(disp: *mut lv_disp_t,
                                          opa: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_set_bg_opa(disp as *mut lv_disp_t, opa as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get elapsed time since last user activity on a display (e.g. click)"]
        #[doc =
          " - __`disp`__: pointer to an display (NULL to get the overall smallest inactivity)"]
        #[doc =
          " Return: elapsed ticks (milliseconds) since the last activity"]
        pub fn disp_get_inactive_time(disp: *const lv_disp_t)
         -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get elapsed time since last user activity on a display (e.g. click)"]
                #[doc =
                  " - __`disp`__: pointer to an display (NULL to get the overall smallest inactivity)"]
                #[doc =
                  " Return: elapsed ticks (milliseconds) since the last activity"]
                pub fn lv_disp_get_inactive_time(disp: *const lv_disp_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_disp_get_inactive_time(disp as *const lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Manually trigger an activity on a display"]
        #[doc =
          " - __`disp`__: pointer to an display (NULL to use the default display)"]
        pub fn disp_trig_activity(disp: *mut lv_disp_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Manually trigger an activity on a display"]
                #[doc =
                  " - __`disp`__: pointer to an display (NULL to use the default display)"]
                pub fn lv_disp_trig_activity(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_trig_activity(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Clean any CPU cache that is related to the display."]
        #[doc =
          " - __`disp`__: pointer to an display (NULL to use the default display)"]
        pub fn disp_clean_dcache(disp: *mut lv_disp_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Clean any CPU cache that is related to the display."]
                #[doc =
                  " - __`disp`__: pointer to an display (NULL to use the default display)"]
                pub fn lv_disp_clean_dcache(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_disp_clean_dcache(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Core Group API `lv_group`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod group {
        use super::*;
        pub const LV_ALIGN_CENTER: lv_align_t = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
        pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
        pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
        pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
        #[doc = " Alignments"]
        pub type _bindgen_ty_3 = u32;
        pub type lv_align_t = u8;
    }
    /// Contains Rust bindings for LVGL Core Indev API `lv_indev`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod indev {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_INDEV_DEF_READ_PERIOD: u32 = 30;
        pub const LV_INDEV_DEF_DRAG_LIMIT: u32 = 10;
        pub const LV_INDEV_DEF_DRAG_THROW: u32 = 20;
        pub const LV_INDEV_DEF_LONG_PRESS_TIME: u32 = 400;
        pub const LV_INDEV_DEF_LONG_PRESS_REP_TIME: u32 = 100;
        pub const LV_INDEV_DEF_GESTURE_LIMIT: u32 = 50;
        pub const LV_INDEV_DEF_GESTURE_MIN_VELOCITY: u32 = 3;
        pub type lv_coord_t = i16;
        pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_indev_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub const LV_ALIGN_CENTER: lv_align_t = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
        pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
        pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
        pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
        #[doc = " Alignments"]
        pub type _bindgen_ty_3 = u32;
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        #[repr(C)]
        pub struct lv_style_t {
            pub map: *mut u8,
        }
        impl Default for lv_style_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Tasks execute this type type of functions."]
        pub type lv_task_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_task_t {
            #[doc = "< How often the task should run"]
            pub period: u32,
            #[doc = "< Last time the task ran"]
            pub last_run: u32,
            #[doc = "< Task function"]
            pub task_cb: lv_task_cb_t,
            #[doc = "< Custom user data"]
            pub user_data: *mut ::cty::c_void,
            #[doc =
              "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
            pub repeat_count: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for _lv_task_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_task_t {
            #[inline]
            pub fn prio(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_prio(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(prio: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let prio: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(prio)
                                                    };
                                                prio as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_task_t = _lv_task_t;
        #[doc = " Structure for holding display buffer information."]
        #[repr(C)]
        pub struct lv_disp_buf_t {
            #[doc = "< First display buffer."]
            pub buf1: *mut ::cty::c_void,
            #[doc = "< Second display buffer."]
            pub buf2: *mut ::cty::c_void,
            pub buf_act: *mut ::cty::c_void,
            pub size: u32,
            pub area: lv_area_t,
            pub flushing: ::cty::c_int,
            pub flushing_last: ::cty::c_int,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_disp_buf_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_disp_buf_t {
            #[inline]
            pub fn last_area(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_area(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn last_part(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_part(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(last_area: u32, last_part: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let last_area: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_area)
                                                    };
                                                last_area as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let last_part: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_part)
                                                    };
                                                last_part as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Display Driver structure to be registered by HAL"]
        #[repr(C)]
        pub struct _disp_drv_t {
            #[doc = "< Horizontal resolution."]
            pub hor_res: lv_coord_t,
            #[doc = "< Vertical resolution."]
            pub ver_res: lv_coord_t,
            #[doc =
              " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
            #[doc =
              " LVGL will use this buffer(s) to draw the screens contents"]
            pub buffer: *mut lv_disp_buf_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc =
              " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
            #[doc = " called when finished"]
            pub flush_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                          *mut _disp_drv_t,
                                                                      area:
                                                                          *const lv_area_t,
                                                                      color_p:
                                                                          *mut lv_color_t)>,
            #[doc =
              " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
            #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
            pub rounder_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        area:
                                                                            *mut lv_area_t)>,
            #[doc =
              " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
            #[doc =
              " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
            #[doc =
              " __Note:__ Much slower then drawing with supported color formats."]
            pub set_px_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                           *mut _disp_drv_t,
                                                                       buf:
                                                                           *mut u8,
                                                                       buf_w:
                                                                           lv_coord_t,
                                                                       x:
                                                                           lv_coord_t,
                                                                       y:
                                                                           lv_coord_t,
                                                                       color:
                                                                           lv_color_t,
                                                                       opa:
                                                                           lv_opa_t)>,
            #[doc =
              " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
            #[doc = " number of flushed pixels"]
            pub monitor_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        time:
                                                                            u32,
                                                                        px:
                                                                            u32)>,
            #[doc =
              " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
            #[doc = " For example flushing or GPU"]
            #[doc =
              " User can execute very simple tasks here or yield the task"]
            pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                         *mut _disp_drv_t)>,
            #[doc =
              " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
            pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                                 *mut _disp_drv_t)>,
            #[doc = " OPTIONAL: called to wait while the gpu is working"]
            pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                             *mut _disp_drv_t)>,
            #[doc = " On CHROMA_KEYED images this color will be transparent."]
            #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
            pub color_chroma_key: lv_color_t,
            #[doc = "< Custom display driver user data"]
            pub user_data: lv_disp_drv_user_data_t,
        }
        impl Default for _disp_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_drv_t {
            #[inline]
            pub fn antialiasing(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_antialiasing(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rotated(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_rotated(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dpi(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_dpi(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialiasing: u32, rotated: u32, dpi: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialiasing: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialiasing)
                                                    };
                                                antialiasing as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let rotated: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(rotated)
                                                    };
                                                rotated as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 10u8,
                                            {
                                                let dpi: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(dpi)
                                                    };
                                                dpi as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_drv_t = _disp_drv_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _disp_t {
            pub driver: lv_disp_drv_t,
            pub refr_task: *mut lv_task_t,
            #[doc = " Screens of the display"]
            pub scr_ll: lv_ll_t,
            #[doc = "< Currently active screen on this display"]
            pub act_scr: *mut _lv_obj_t,
            #[doc = "< Previous screen. Used during screen animations"]
            pub prev_scr: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_top"]
            pub top_layer: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_sys"]
            pub sys_layer: *mut _lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc = "< Default display color when screens are transparent"]
            pub bg_color: lv_color_t,
            #[doc = "< An image source to display as wallpaper"]
            pub bg_img: *const ::cty::c_void,
            #[doc = "<Opacity of the background color or wallpaper"]
            pub bg_opa: lv_opa_t,
            #[doc = " Invalidated (marked to redraw) areas"]
            pub inv_areas: [lv_area_t; 32usize],
            pub inv_area_joined: [u8; 32usize],
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc = "< Last time there was activity on this display"]
            pub last_activity_time: u32,
        }
        impl Default for _disp_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_t {
            #[inline]
            pub fn del_prev(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_del_prev(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(del_prev: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let del_prev: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(del_prev)
                                                    };
                                                del_prev as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn inv_p(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_inv_p(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(inv_p: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 10u8,
                                            {
                                                let inv_p: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(inv_p)
                                                    };
                                                inv_p as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_t = _disp_t;
        #[doc = "< Uninitialized state"]
        pub const LV_INDEV_TYPE_NONE: _bindgen_ty_16 = 0;
        #[doc = "< Touch pad, mouse, external button"]
        pub const LV_INDEV_TYPE_POINTER: _bindgen_ty_16 = 1;
        #[doc = "< Keypad or keyboard"]
        pub const LV_INDEV_TYPE_KEYPAD: _bindgen_ty_16 = 2;
        #[doc =
          "< External (hardware button) which is assigned to a specific point of the"]
        #[doc = "screen"]
        pub const LV_INDEV_TYPE_BUTTON: _bindgen_ty_16 = 3;
        #[doc = "< Encoder with only Left, Right turn and a Button"]
        pub const LV_INDEV_TYPE_ENCODER: _bindgen_ty_16 = 4;
        #[doc = " Possible input device types"]
        pub type _bindgen_ty_16 = u32;
        pub type lv_indev_type_t = u8;
        pub const LV_INDEV_STATE_REL: _bindgen_ty_17 = 0;
        pub const LV_INDEV_STATE_PR: _bindgen_ty_17 = 1;
        #[doc = " States for input devices"]
        pub type _bindgen_ty_17 = u32;
        pub type lv_indev_state_t = u8;
        pub type lv_drag_dir_t = u8;
        pub type lv_gesture_dir_t = u8;
        #[doc = " Data structure passed to an input driver to fill"]
        #[repr(C)]
        pub struct lv_indev_data_t {
            #[doc = "< For LV_INDEV_TYPE_POINTER the currently pressed point"]
            pub point: lv_point_t,
            #[doc = "< For LV_INDEV_TYPE_KEYPAD the currently pressed key"]
            pub key: u32,
            #[doc = "< For LV_INDEV_TYPE_BUTTON the currently pressed button"]
            pub btn_id: u32,
            #[doc =
              "< For LV_INDEV_TYPE_ENCODER number of steps since the previous read"]
            pub enc_diff: i16,
            #[doc = "< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR"]
            pub state: lv_indev_state_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_indev_data_t {
            #[inline]
            fn default() -> lv_indev_data_t {
                lv_indev_data_t{point: ::core::default::Default::default(),
                                key: ::core::default::Default::default(),
                                btn_id: ::core::default::Default::default(),
                                enc_diff: ::core::default::Default::default(),
                                state: ::core::default::Default::default(),}
            }
        }
        #[doc = " Initialized by the user and registered by 'lv_indev_add()'"]
        #[repr(C)]
        pub struct _lv_indev_drv_t {
            pub type_: lv_indev_type_t,
            pub read_cb: ::core::option::Option<unsafe extern "C" fn(indev_drv:
                                                                         *mut _lv_indev_drv_t,
                                                                     data:
                                                                         *mut lv_indev_data_t)
                                                    -> bool>,
            #[doc = " Called when an action happened on the input device."]
            #[doc = " The second parameter is the event from `lv_event_t`"]
            pub feedback_cb: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut _lv_indev_drv_t,
                                                                         arg2:
                                                                             u8)>,
            pub user_data: lv_indev_drv_user_data_t,
            pub disp: *mut _disp_t,
            pub read_task: *mut lv_task_t,
            pub drag_limit: u8,
            pub drag_throw: u8,
            pub gesture_min_velocity: u8,
            pub gesture_limit: u8,
            pub long_press_time: u16,
            pub long_press_rep_time: u16,
        }
        impl Default for _lv_indev_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_indev_drv_t = _lv_indev_drv_t;
        #[doc = " Run time data of input devices"]
        #[doc =
          " Internally used by the library, you should not need to touch it."]
        #[repr(C)]
        pub struct _lv_indev_proc_t {
            #[doc = "< Current state of the input device."]
            pub state: lv_indev_state_t,
            pub types: _lv_indev_proc_t__bindgen_ty_1,
            #[doc = "< Pressed time stamp"]
            pub pr_timestamp: u32,
            #[doc = "< Long press repeat time stamp"]
            pub longpr_rep_timestamp: u32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct _lv_indev_proc_t__bindgen_ty_1 {
            pub pointer: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1>,
            pub keypad: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2>,
            pub bindgen_union_field: [u64; 7usize],
        }
        #[repr(C)]
        pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
            #[doc = "< Current point of input device."]
            pub act_point: lv_point_t,
            #[doc = "< Last point of input device."]
            pub last_point: lv_point_t,
            #[doc = "< Difference between `act_point` and `last_point`."]
            pub vect: lv_point_t,
            pub drag_sum: lv_point_t,
            pub drag_throw_vect: lv_point_t,
            pub act_obj: *mut _lv_obj_t,
            pub last_obj: *mut _lv_obj_t,
            pub last_pressed: *mut _lv_obj_t,
            pub gesture_dir: lv_gesture_dir_t,
            pub gesture_sum: lv_point_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u8,
        }
        impl Default for _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
            #[inline]
            pub fn drag_limit_out(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_limit_out(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_in_prog(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_in_prog(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_dir(&self) -> lv_drag_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn gesture_sent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_gesture_sent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(drag_limit_out: u8, drag_in_prog: u8,
                                  drag_dir: lv_drag_dir_t, gesture_sent: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let drag_limit_out: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_limit_out)
                                                    };
                                                drag_limit_out as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag_in_prog: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_in_prog)
                                                    };
                                                drag_in_prog as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let drag_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_dir)
                                                    };
                                                drag_dir as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let gesture_sent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(gesture_sent)
                                                    };
                                                gesture_sent as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
            pub last_state: lv_indev_state_t,
            pub last_key: u32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
            #[inline]
            fn default() -> _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
                _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2{last_state:
                                                                 ::core::default::Default::default(),
                                                             last_key:
                                                                 ::core::default::Default::default(),}
            }
        }
        impl Default for _lv_indev_proc_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl Default for _lv_indev_proc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_indev_proc_t {
            #[inline]
            pub fn long_pr_sent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_long_pr_sent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn reset_query(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_reset_query(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn disabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_disabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wait_until_release(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_wait_until_release(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(long_pr_sent: u8, reset_query: u8,
                                  disabled: u8, wait_until_release: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let long_pr_sent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(long_pr_sent)
                                                    };
                                                long_pr_sent as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let reset_query: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(reset_query)
                                                    };
                                                reset_query as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let disabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(disabled)
                                                    };
                                                disabled as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let wait_until_release: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(wait_until_release)
                                                    };
                                                wait_until_release as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_indev_proc_t = _lv_indev_proc_t;
        #[repr(C)]
        pub struct _lv_group_t {
            _unused: [u8; 0],
        }
        #[doc =
          " The main input device descriptor with driver, runtime data ('proc') and some additional"]
        #[doc = " information"]
        #[repr(C)]
        pub struct _lv_indev_t {
            pub driver: lv_indev_drv_t,
            pub proc_: lv_indev_proc_t,
            #[doc = "< Cursor for LV_INPUT_TYPE_POINTER"]
            pub cursor: *mut _lv_obj_t,
            #[doc = "< Keypad destination group"]
            pub group: *mut _lv_group_t,
            #[doc =
              "< Array points assigned to the button ()screen will be pressed"]
            #[doc = "here by the buttons"]
            pub btn_points: *const lv_point_t,
        }
        impl Default for _lv_indev_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_indev_t = _lv_indev_t;
        #[doc = " Initialize an input device driver with default values."]
        #[doc =
          " It is used to surly have known values in the fields ant not memory junk."]
        #[doc = " After it you can set the fields."]
        #[doc = " - __`driver`__: pointer to driver variable to initialize"]
        pub fn indev_drv_init(driver: *mut lv_indev_drv_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Initialize an input device driver with default values."]
                #[doc =
                  " It is used to surly have known values in the fields ant not memory junk."]
                #[doc = " After it you can set the fields."]
                #[doc =
                  " - __`driver`__: pointer to driver variable to initialize"]
                pub fn lv_indev_drv_init(driver: *mut lv_indev_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_drv_init(driver as *mut lv_indev_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Register an initialized input device driver."]
        #[doc =
          " - __`driver`__: pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)"]
        #[doc = " Return: pointer to the new input device or NULL on error"]
        pub fn indev_drv_register(driver: *mut lv_indev_drv_t)
         -> MynewtResult<*mut lv_indev_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Register an initialized input device driver."]
                #[doc =
                  " - __`driver`__: pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)"]
                #[doc =
                  " Return: pointer to the new input device or NULL on error"]
                pub fn lv_indev_drv_register(driver: *mut lv_indev_drv_t)
                -> *mut lv_indev_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_drv_register(driver as *mut lv_indev_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Update the driver in run time."]
        #[doc =
          " - __`indev`__: pointer to a input device. (return value of `lv_indev_drv_register`)"]
        #[doc = " - __`new_drv`__: pointer to the new driver"]
        pub fn indev_drv_update(indev: *mut lv_indev_t,
                                new_drv: *mut lv_indev_drv_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Update the driver in run time."]
                #[doc =
                  " - __`indev`__: pointer to a input device. (return value of `lv_indev_drv_register`)"]
                #[doc = " - __`new_drv`__: pointer to the new driver"]
                pub fn lv_indev_drv_update(indev: *mut lv_indev_t,
                                           new_drv: *mut lv_indev_drv_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_drv_update(indev as *mut lv_indev_t,
                                    new_drv as *mut lv_indev_drv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the next input device."]
        #[doc =
          " - __`indev`__: pointer to the current input device. NULL to initialize."]
        #[doc =
          " Return: the next input devise or NULL if no more. Give the first input device when the parameter"]
        #[doc = " is NULL"]
        pub fn indev_get_next(indev: *mut lv_indev_t)
         -> MynewtResult<*mut lv_indev_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the next input device."]
                #[doc =
                  " - __`indev`__: pointer to the current input device. NULL to initialize."]
                #[doc =
                  " Return: the next input devise or NULL if no more. Give the first input device when the parameter"]
                #[doc = " is NULL"]
                pub fn lv_indev_get_next(indev: *mut lv_indev_t)
                -> *mut lv_indev_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_get_next(indev as *mut lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_obj_t {
            #[doc = "< Pointer to the parent object"]
            pub parent: *mut _lv_obj_t,
            #[doc = "< Linked list to store the children objects"]
            pub child_ll: lv_ll_t,
            #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
            pub coords: lv_area_t,
            #[doc = "< Event callback function"]
            pub event_cb: lv_event_cb_t,
            #[doc = "< Object type specific signal function"]
            pub signal_cb: lv_signal_cb_t,
            #[doc = "< Object type specific design function"]
            pub design_cb: lv_design_cb_t,
            #[doc = "< Object type specific extended data"]
            pub ext_attr: *mut ::cty::c_void,
            pub style_list: lv_style_list_t,
            #[doc = "< Extra click padding in horizontal direction"]
            pub ext_click_pad_hor: u8,
            #[doc = "< Extra click padding in vertical direction"]
            pub ext_click_pad_ver: u8,
            #[doc = "< EXTend the size in every direction for drawing."]
            pub ext_draw_pad: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            #[doc = "< Automatically happening actions can be prevented."]
            #[doc = "'OR'ed values from `lv_protect_t`"]
            pub protect: u8,
            pub state: lv_state_t,
            #[doc = "< Information about the last call to ::lv_obj_align."]
            pub realign: lv_realign_t,
            #[doc = "< Custom user data for object."]
            pub user_data: lv_obj_user_data_t,
        }
        impl Default for _lv_obj_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_obj_t {
            #[inline]
            pub fn click(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_throw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_throw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn parent_event(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_parent_event(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn adv_hittest(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_adv_hittest(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn gesture_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_gesture_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn focus_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_focus_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_dir(&self) -> lv_drag_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn base_dir(&self) -> lv_bidi_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(click: u8, drag: u8, drag_throw: u8,
                                  drag_parent: u8, hidden: u8, top: u8,
                                  parent_event: u8, adv_hittest: u8,
                                  gesture_parent: u8, focus_parent: u8,
                                  drag_dir: lv_drag_dir_t,
                                  base_dir: lv_bidi_dir_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let click: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click)
                                                    };
                                                click as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag)
                                                    };
                                                drag as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let drag_throw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_throw)
                                                    };
                                                drag_throw as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let drag_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_parent)
                                                    };
                                                drag_parent as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top)
                                                    };
                                                top as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let parent_event: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(parent_event)
                                                    };
                                                parent_event as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let adv_hittest: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(adv_hittest)
                                                    };
                                                adv_hittest as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let gesture_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(gesture_parent)
                                                    };
                                                gesture_parent as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let focus_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(focus_parent)
                                                    };
                                                focus_parent as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 3u8,
                                            {
                                                let drag_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_dir)
                                                    };
                                                drag_dir as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 2u8,
                                            {
                                                let base_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(base_dir)
                                                    };
                                                base_dir as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_obj_t = _lv_obj_t;
        #[doc =
          " Get the currently processed input device. Can be used in action functions too."]
        #[doc =
          " Return: pointer to the currently processed input device or NULL if no input device processing"]
        #[doc = " right now"]
        pub fn indev_get_act() -> MynewtResult<*mut lv_indev_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the currently processed input device. Can be used in action functions too."]
                #[doc =
                  " Return: pointer to the currently processed input device or NULL if no input device processing"]
                #[doc = " right now"]
                pub fn lv_indev_get_act()
                -> *mut lv_indev_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_indev_get_act();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the type of an input device"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc =
          " Return: the type of the input device from `lv_hal_indev_type_t` (`LV_INDEV_TYPE_...`)"]
        pub fn indev_get_type(indev: *const lv_indev_t)
         -> MynewtResult<lv_indev_type_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the type of an input device"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc =
                  " Return: the type of the input device from `lv_hal_indev_type_t` (`LV_INDEV_TYPE_...`)"]
                pub fn lv_indev_get_type(indev: *const lv_indev_t)
                -> lv_indev_type_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_get_type(indev as *const lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Reset one or all input devices"]
        #[doc =
          " - __`indev`__: pointer to an input device to reset or NULL to reset all of them"]
        #[doc =
          " - __`obj`__: pointer to an object which triggers the reset."]
        pub fn indev_reset(indev: *mut lv_indev_t, obj: *mut lv_obj_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Reset one or all input devices"]
                #[doc =
                  " - __`indev`__: pointer to an input device to reset or NULL to reset all of them"]
                #[doc =
                  " - __`obj`__: pointer to an object which triggers the reset."]
                pub fn lv_indev_reset(indev: *mut lv_indev_t,
                                      obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_reset(indev as *mut lv_indev_t,
                               obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Reset the long press state of an input device"]
        #[doc = " - __`indev_proc`__: pointer to an input device"]
        pub fn indev_reset_long_press(indev: *mut lv_indev_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Reset the long press state of an input device"]
                #[doc = " - __`indev_proc`__: pointer to an input device"]
                pub fn lv_indev_reset_long_press(indev: *mut lv_indev_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_reset_long_press(indev as *mut lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable or disable an input devices"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " - __`en`__: true: enable; false: disable"]
        pub fn indev_enable(indev: *mut lv_indev_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable or disable an input devices"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc = " - __`en`__: true: enable; false: disable"]
                pub fn lv_indev_enable(indev: *mut lv_indev_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_enable(indev as *mut lv_indev_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON)"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " - __`cur_obj`__: pointer to an object to be used as cursor"]
        pub fn indev_set_cursor(indev: *mut lv_indev_t,
                                cur_obj: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON)"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc =
                  " - __`cur_obj`__: pointer to an object to be used as cursor"]
                pub fn lv_indev_set_cursor(indev: *mut lv_indev_t,
                                           cur_obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_set_cursor(indev as *mut lv_indev_t,
                                    cur_obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the an array of points for LV_INDEV_TYPE_BUTTON."]
        #[doc =
          " These points will be assigned to the buttons to press a specific point on the screen"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " - __`group`__: point to a group"]
        pub fn indev_set_button_points(indev: *mut lv_indev_t,
                                       points: *const lv_point_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the an array of points for LV_INDEV_TYPE_BUTTON."]
                #[doc =
                  " These points will be assigned to the buttons to press a specific point on the screen"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc = " - __`group`__: point to a group"]
                pub fn lv_indev_set_button_points(indev: *mut lv_indev_t,
                                                  points: *const lv_point_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_set_button_points(indev as *mut lv_indev_t,
                                           points as *const lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " - __`point`__: pointer to a point to store the result"]
        pub fn indev_get_point(indev: *const lv_indev_t,
                               point: *mut lv_point_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc =
                  " - __`point`__: pointer to a point to store the result"]
                pub fn lv_indev_get_point(indev: *const lv_indev_t,
                                          point: *mut lv_point_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_get_point(indev as *const lv_indev_t,
                                   point as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the current gesture direct"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " Return: current gesture direct"]
        pub fn indev_get_gesture_dir(indev: *const lv_indev_t)
         -> MynewtResult<lv_gesture_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current gesture direct"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc = " Return: current gesture direct"]
                pub fn lv_indev_get_gesture_dir(indev: *const lv_indev_t)
                -> lv_gesture_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_get_gesture_dir(indev as *const lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD)"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " Return: the last pressed key (0 on error)"]
        pub fn indev_get_key(indev: *const lv_indev_t) -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD)"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc = " Return: the last pressed key (0 on error)"]
                pub fn lv_indev_get_key(indev: *const lv_indev_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_get_key(indev as *const lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Check if there is dragging with an input device or not (for LV_INDEV_TYPE_POINTER and"]
        #[doc = " LV_INDEV_TYPE_BUTTON)"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " Return: true: drag is in progress"]
        pub fn indev_is_dragging(indev: *const lv_indev_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check if there is dragging with an input device or not (for LV_INDEV_TYPE_POINTER and"]
                #[doc = " LV_INDEV_TYPE_BUTTON)"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc = " Return: true: drag is in progress"]
                pub fn lv_indev_is_dragging(indev: *const lv_indev_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_is_dragging(indev as *const lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the vector of dragging of an input device (for LV_INDEV_TYPE_POINTER and"]
        #[doc = " LV_INDEV_TYPE_BUTTON)"]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc = " - __`point`__: pointer to a point to store the vector"]
        pub fn indev_get_vect(indev: *const lv_indev_t,
                              point: *mut lv_point_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the vector of dragging of an input device (for LV_INDEV_TYPE_POINTER and"]
                #[doc = " LV_INDEV_TYPE_BUTTON)"]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc =
                  " - __`point`__: pointer to a point to store the vector"]
                pub fn lv_indev_get_vect(indev: *const lv_indev_t,
                                         point: *mut lv_point_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_get_vect(indev as *const lv_indev_t,
                                  point as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Manually finish dragging."]
        #[doc = " `LV_SIGNAL_DRAG_END` and `LV_EVENT_DRAG_END` will be sent."]
        #[doc = " - __`indev`__: pointer to an input device"]
        #[doc =
          " Return: `LV_RES_INV` if the object being dragged was deleted. Else `LV_RES_OK`."]
        pub fn indev_finish_drag(indev: *mut lv_indev_t)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Manually finish dragging."]
                #[doc =
                  " `LV_SIGNAL_DRAG_END` and `LV_EVENT_DRAG_END` will be sent."]
                #[doc = " - __`indev`__: pointer to an input device"]
                #[doc =
                  " Return: `LV_RES_INV` if the object being dragged was deleted. Else `LV_RES_OK`."]
                pub fn lv_indev_finish_drag(indev: *mut lv_indev_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_finish_drag(indev as *mut lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Do nothing until the next release"]
        #[doc = " - __`indev`__: pointer to an input device"]
        pub fn indev_wait_release(indev: *mut lv_indev_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Do nothing until the next release"]
                #[doc = " - __`indev`__: pointer to an input device"]
                pub fn lv_indev_wait_release(indev: *mut lv_indev_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_indev_wait_release(indev as *mut lv_indev_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Gets a pointer to the currently active object in indev proc functions."]
        #[doc =
          " NULL if no object is currently being handled or if groups aren't used."]
        #[doc = " Return: pointer to currently active object"]
        pub fn indev_get_obj_act() -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Gets a pointer to the currently active object in indev proc functions."]
                #[doc =
                  " NULL if no object is currently being handled or if groups aren't used."]
                #[doc = " Return: pointer to currently active object"]
                pub fn lv_indev_get_obj_act()
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_indev_get_obj_act();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Search the most top, clickable object by a point"]
        #[doc =
          " - __`obj`__: pointer to a start object, typically the screen"]
        #[doc =
          " - __`point`__: pointer to a point for searching the most top child"]
        #[doc =
          " Return: pointer to the found object or NULL if there was no suitable object"]
        pub fn indev_search_obj(obj: *mut lv_obj_t, point: *mut lv_point_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Search the most top, clickable object by a point"]
                #[doc =
                  " - __`obj`__: pointer to a start object, typically the screen"]
                #[doc =
                  " - __`point`__: pointer to a point for searching the most top child"]
                #[doc =
                  " Return: pointer to the found object or NULL if there was no suitable object"]
                pub fn lv_indev_search_obj(obj: *mut lv_obj_t,
                                           point: *mut lv_point_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_search_obj(obj as *mut lv_obj_t,
                                        point as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get a pointer to the indev read task to"]
        #[doc = " modify its parameters with `lv_task_...` functions."]
        #[doc = " - __`indev`__: pointer to an inout device"]
        #[doc =
          " Return: pointer to the indev read refresher task. (NULL on error)"]
        pub fn indev_get_read_task(indev: *mut lv_disp_t)
         -> MynewtResult<*mut lv_task_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get a pointer to the indev read task to"]
                #[doc =
                  " modify its parameters with `lv_task_...` functions."]
                #[doc = " - __`indev`__: pointer to an inout device"]
                #[doc =
                  " Return: pointer to the indev read refresher task. (NULL on error)"]
                pub fn lv_indev_get_read_task(indev: *mut lv_disp_t)
                -> *mut lv_task_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_indev_get_read_task(indev as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Core Obj API `lv_obj`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod obj {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub type lv_coord_t = i16;
        pub type lv_anim_user_data_t = *mut ::cty::c_void;
        pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub const LV_ALIGN_CENTER: lv_align_t = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
        pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
        pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
        pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
        #[doc = " Alignments"]
        pub type _bindgen_ty_3 = u32;
        pub type lv_align_t = u8;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u16,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u16,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i16,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i16,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: lv_coord_t,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Distance between the top of the underline and base line (< 0 means below the base line)"]
            pub underline_position: i8,
            #[doc = "< Thickness of the underline"]
            pub underline_thickness: i8,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[doc = " Get the current value during an animation"]
        pub type lv_anim_path_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1:
                                                         *const _lv_anim_path_t,
                                                     arg2: *const _lv_anim_t)
                                    -> lv_anim_value_t>;
        #[repr(C)]
        pub struct _lv_anim_path_t {
            pub cb: lv_anim_path_cb_t,
            pub user_data: *mut ::cty::c_void,
        }
        impl Default for _lv_anim_path_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_anim_path_t = _lv_anim_path_t;
        #[doc = " Generic prototype of \"animator\" functions."]
        #[doc = " First parameter is the variable to animate."]
        #[doc = " Second parameter is the value to set."]
        #[doc = " Compatible with `lv_xxx_set_yyy(obj, value)` functions"]
        #[doc =
          " The `x` in `_xcb_t` means its not a fully generic prototype because"]
        #[doc = " it doesn't receive `lv_anim_t *` as its first argument"]
        pub type lv_anim_exec_xcb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void,
                                                     arg2: lv_anim_value_t)>;
        #[doc = " Callback to call when the animation is ready"]
        pub type lv_anim_ready_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
        #[doc =
          " Callback to call when the animation really stars (considering `delay`)"]
        pub type lv_anim_start_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
        #[doc = " Describes an animation"]
        #[repr(C)]
        pub struct _lv_anim_t {
            #[doc = "<Variable to animate"]
            pub var: *mut ::cty::c_void,
            #[doc = "< Function to execute to animate"]
            pub exec_cb: lv_anim_exec_xcb_t,
            #[doc =
              "< Call it when the animation is starts (considering `delay`)"]
            pub start_cb: lv_anim_start_cb_t,
            #[doc = "< Call it when the animation is ready"]
            pub ready_cb: lv_anim_ready_cb_t,
            #[doc = "< Describe the path (curve) of animations"]
            pub path: lv_anim_path_t,
            #[doc = "< Start value"]
            pub start: i32,
            #[doc = "< Current value"]
            pub current: i32,
            #[doc = "< End value"]
            pub end: i32,
            #[doc = "< Animation time in ms"]
            pub time: i32,
            #[doc =
              "< Current time in animation. Set to negative to make delay."]
            pub act_time: i32,
            #[doc = "< Wait before play back"]
            pub playback_delay: u32,
            #[doc = "< Duration of playback animation"]
            pub playback_time: u32,
            #[doc = "< Wait before repeat"]
            pub repeat_delay: u32,
            #[doc = "< Repeat count for the animation"]
            pub repeat_cnt: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc = "< Custom user data"]
            pub user_data: lv_anim_user_data_t,
            pub time_orig: u32,
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for _lv_anim_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_anim_t {
            #[inline]
            pub fn early_apply(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_early_apply(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(early_apply: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let early_apply: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(early_apply)
                                                    };
                                                early_apply as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn playback_now(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_playback_now(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_run(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_run(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_2.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(playback_now: u8, has_run: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let playback_now: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(playback_now)
                                                    };
                                                playback_now as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let has_run: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_run)
                                                    };
                                                has_run as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_anim_t = _lv_anim_t;
        pub type lv_blend_mode_t = u8;
        pub type lv_border_side_t = u8;
        pub type lv_grad_dir_t = u8;
        pub type lv_text_decor_t = u8;
        pub type lv_style_property_t = u16;
        #[repr(C)]
        pub struct lv_style_t {
            pub map: *mut u8,
        }
        impl Default for lv_style_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_style_int_t = i16;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Tasks execute this type type of functions."]
        pub type lv_task_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_task_t {
            #[doc = "< How often the task should run"]
            pub period: u32,
            #[doc = "< Last time the task ran"]
            pub last_run: u32,
            #[doc = "< Task function"]
            pub task_cb: lv_task_cb_t,
            #[doc = "< Custom user data"]
            pub user_data: *mut ::cty::c_void,
            #[doc =
              "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
            pub repeat_count: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for _lv_task_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_task_t {
            #[inline]
            pub fn prio(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_prio(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(prio: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let prio: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(prio)
                                                    };
                                                prio as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_task_t = _lv_task_t;
        #[doc = " Structure for holding display buffer information."]
        #[repr(C)]
        pub struct lv_disp_buf_t {
            #[doc = "< First display buffer."]
            pub buf1: *mut ::cty::c_void,
            #[doc = "< Second display buffer."]
            pub buf2: *mut ::cty::c_void,
            pub buf_act: *mut ::cty::c_void,
            pub size: u32,
            pub area: lv_area_t,
            pub flushing: ::cty::c_int,
            pub flushing_last: ::cty::c_int,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_disp_buf_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_disp_buf_t {
            #[inline]
            pub fn last_area(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_area(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn last_part(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_part(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(last_area: u32, last_part: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let last_area: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_area)
                                                    };
                                                last_area as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let last_part: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_part)
                                                    };
                                                last_part as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Display Driver structure to be registered by HAL"]
        #[repr(C)]
        pub struct _disp_drv_t {
            #[doc = "< Horizontal resolution."]
            pub hor_res: lv_coord_t,
            #[doc = "< Vertical resolution."]
            pub ver_res: lv_coord_t,
            #[doc =
              " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
            #[doc =
              " LVGL will use this buffer(s) to draw the screens contents"]
            pub buffer: *mut lv_disp_buf_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc =
              " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
            #[doc = " called when finished"]
            pub flush_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                          *mut _disp_drv_t,
                                                                      area:
                                                                          *const lv_area_t,
                                                                      color_p:
                                                                          *mut lv_color_t)>,
            #[doc =
              " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
            #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
            pub rounder_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        area:
                                                                            *mut lv_area_t)>,
            #[doc =
              " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
            #[doc =
              " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
            #[doc =
              " __Note:__ Much slower then drawing with supported color formats."]
            pub set_px_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                           *mut _disp_drv_t,
                                                                       buf:
                                                                           *mut u8,
                                                                       buf_w:
                                                                           lv_coord_t,
                                                                       x:
                                                                           lv_coord_t,
                                                                       y:
                                                                           lv_coord_t,
                                                                       color:
                                                                           lv_color_t,
                                                                       opa:
                                                                           lv_opa_t)>,
            #[doc =
              " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
            #[doc = " number of flushed pixels"]
            pub monitor_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        time:
                                                                            u32,
                                                                        px:
                                                                            u32)>,
            #[doc =
              " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
            #[doc = " For example flushing or GPU"]
            #[doc =
              " User can execute very simple tasks here or yield the task"]
            pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                         *mut _disp_drv_t)>,
            #[doc =
              " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
            pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                                 *mut _disp_drv_t)>,
            #[doc = " OPTIONAL: called to wait while the gpu is working"]
            pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                             *mut _disp_drv_t)>,
            #[doc = " On CHROMA_KEYED images this color will be transparent."]
            #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
            pub color_chroma_key: lv_color_t,
            #[doc = "< Custom display driver user data"]
            pub user_data: lv_disp_drv_user_data_t,
        }
        impl Default for _disp_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_drv_t {
            #[inline]
            pub fn antialiasing(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_antialiasing(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rotated(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_rotated(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dpi(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_dpi(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialiasing: u32, rotated: u32, dpi: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialiasing: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialiasing)
                                                    };
                                                antialiasing as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let rotated: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(rotated)
                                                    };
                                                rotated as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 10u8,
                                            {
                                                let dpi: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(dpi)
                                                    };
                                                dpi as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_drv_t = _disp_drv_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _disp_t {
            pub driver: lv_disp_drv_t,
            pub refr_task: *mut lv_task_t,
            #[doc = " Screens of the display"]
            pub scr_ll: lv_ll_t,
            #[doc = "< Currently active screen on this display"]
            pub act_scr: *mut _lv_obj_t,
            #[doc = "< Previous screen. Used during screen animations"]
            pub prev_scr: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_top"]
            pub top_layer: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_sys"]
            pub sys_layer: *mut _lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc = "< Default display color when screens are transparent"]
            pub bg_color: lv_color_t,
            #[doc = "< An image source to display as wallpaper"]
            pub bg_img: *const ::cty::c_void,
            #[doc = "<Opacity of the background color or wallpaper"]
            pub bg_opa: lv_opa_t,
            #[doc = " Invalidated (marked to redraw) areas"]
            pub inv_areas: [lv_area_t; 32usize],
            pub inv_area_joined: [u8; 32usize],
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc = "< Last time there was activity on this display"]
            pub last_activity_time: u32,
        }
        impl Default for _disp_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_t {
            #[inline]
            pub fn del_prev(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_del_prev(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(del_prev: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let del_prev: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(del_prev)
                                                    };
                                                del_prev as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn inv_p(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_inv_p(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(inv_p: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 10u8,
                                            {
                                                let inv_p: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(inv_p)
                                                    };
                                                inv_p as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_t = _disp_t;
        pub type lv_drag_dir_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_rect_dsc_t {
            pub radius: lv_style_int_t,
            pub bg_color: lv_color_t,
            pub bg_grad_color: lv_color_t,
            pub bg_grad_dir: lv_grad_dir_t,
            pub bg_main_color_stop: lv_style_int_t,
            pub bg_grad_color_stop: lv_style_int_t,
            pub bg_opa: lv_opa_t,
            pub bg_blend_mode: lv_blend_mode_t,
            pub border_color: lv_color_t,
            pub border_width: lv_style_int_t,
            pub border_side: lv_style_int_t,
            pub border_opa: lv_opa_t,
            pub border_blend_mode: lv_blend_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub outline_color: lv_color_t,
            pub outline_width: lv_style_int_t,
            pub outline_pad: lv_style_int_t,
            pub outline_opa: lv_opa_t,
            pub outline_blend_mode: lv_blend_mode_t,
            pub shadow_color: lv_color_t,
            pub shadow_width: lv_style_int_t,
            pub shadow_ofs_x: lv_style_int_t,
            pub shadow_ofs_y: lv_style_int_t,
            pub shadow_spread: lv_style_int_t,
            pub shadow_opa: lv_opa_t,
            pub shadow_blend_mode: lv_blend_mode_t,
            pub pattern_image: *const ::cty::c_void,
            pub pattern_font: *const lv_font_t,
            pub pattern_recolor: lv_color_t,
            pub pattern_opa: lv_opa_t,
            pub pattern_recolor_opa: lv_opa_t,
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub pattern_blend_mode: lv_blend_mode_t,
            pub value_str: *const ::cty::c_char,
            pub value_font: *const lv_font_t,
            pub value_opa: lv_opa_t,
            pub value_color: lv_color_t,
            pub value_ofs_x: lv_style_int_t,
            pub value_ofs_y: lv_style_int_t,
            pub value_letter_space: lv_style_int_t,
            pub value_line_space: lv_style_int_t,
            pub value_align: lv_align_t,
            pub value_blend_mode: lv_blend_mode_t,
        }
        impl Default for lv_draw_rect_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_rect_dsc_t {
            #[inline]
            pub fn border_post(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_border_post(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(border_post: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let border_post: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post)
                                                    };
                                                border_post as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn pattern_repeat(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_pattern_repeat(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(pattern_repeat: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let pattern_repeat: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_repeat)
                                                    };
                                                pattern_repeat as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_bidi_dir_t = u8;
        pub type lv_txt_flag_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_label_dsc_t {
            pub color: lv_color_t,
            pub sel_color: lv_color_t,
            pub font: *const lv_font_t,
            pub opa: lv_opa_t,
            pub line_space: lv_style_int_t,
            pub letter_space: lv_style_int_t,
            pub sel_start: u32,
            pub sel_end: u32,
            pub ofs_x: lv_coord_t,
            pub ofs_y: lv_coord_t,
            pub bidi_dir: lv_bidi_dir_t,
            pub flag: lv_txt_flag_t,
            pub decor: lv_text_decor_t,
            pub blend_mode: lv_blend_mode_t,
        }
        impl Default for lv_draw_label_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_line_dsc_t {
            pub color: lv_color_t,
            pub width: lv_style_int_t,
            pub dash_width: lv_style_int_t,
            pub dash_gap: lv_style_int_t,
            pub opa: lv_opa_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_draw_line_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_line_dsc_t {
            #[inline]
            pub fn blend_mode(&self) -> lv_blend_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_blend_mode(&mut self, val: lv_blend_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn round_start(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_round_start(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn round_end(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_round_end(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn raw_end(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_raw_end(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(blend_mode: lv_blend_mode_t,
                                  round_start: u8, round_end: u8, raw_end: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let blend_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode)
                                                    };
                                                blend_mode as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let round_start: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(round_start)
                                                    };
                                                round_start as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let round_end: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(round_end)
                                                    };
                                                round_end as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let raw_end: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(raw_end)
                                                    };
                                                raw_end as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_img_dsc_t {
            pub opa: lv_opa_t,
            pub angle: u16,
            pub pivot: lv_point_t,
            pub zoom: u16,
            pub recolor_opa: lv_opa_t,
            pub recolor: lv_color_t,
            pub blend_mode: lv_blend_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_draw_img_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_img_dsc_t {
            #[inline]
            pub fn antialias(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_antialias(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialias: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialias: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialias)
                                                    };
                                                antialias as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_obj_t {
            #[doc = "< Pointer to the parent object"]
            pub parent: *mut _lv_obj_t,
            #[doc = "< Linked list to store the children objects"]
            pub child_ll: lv_ll_t,
            #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
            pub coords: lv_area_t,
            #[doc = "< Event callback function"]
            pub event_cb: lv_event_cb_t,
            #[doc = "< Object type specific signal function"]
            pub signal_cb: lv_signal_cb_t,
            #[doc = "< Object type specific design function"]
            pub design_cb: lv_design_cb_t,
            #[doc = "< Object type specific extended data"]
            pub ext_attr: *mut ::cty::c_void,
            pub style_list: lv_style_list_t,
            #[doc = "< Extra click padding in horizontal direction"]
            pub ext_click_pad_hor: u8,
            #[doc = "< Extra click padding in vertical direction"]
            pub ext_click_pad_ver: u8,
            #[doc = "< EXTend the size in every direction for drawing."]
            pub ext_draw_pad: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            #[doc = "< Automatically happening actions can be prevented."]
            #[doc = "'OR'ed values from `lv_protect_t`"]
            pub protect: u8,
            pub state: lv_state_t,
            #[doc = "< Information about the last call to ::lv_obj_align."]
            pub realign: lv_realign_t,
            #[doc = "< Custom user data for object."]
            pub user_data: lv_obj_user_data_t,
        }
        impl Default for _lv_obj_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_obj_t {
            #[inline]
            pub fn click(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_throw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_throw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn parent_event(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_parent_event(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn adv_hittest(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_adv_hittest(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn gesture_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_gesture_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn focus_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_focus_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_dir(&self) -> lv_drag_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn base_dir(&self) -> lv_bidi_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(click: u8, drag: u8, drag_throw: u8,
                                  drag_parent: u8, hidden: u8, top: u8,
                                  parent_event: u8, adv_hittest: u8,
                                  gesture_parent: u8, focus_parent: u8,
                                  drag_dir: lv_drag_dir_t,
                                  base_dir: lv_bidi_dir_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let click: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click)
                                                    };
                                                click as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag)
                                                    };
                                                drag as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let drag_throw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_throw)
                                                    };
                                                drag_throw as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let drag_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_parent)
                                                    };
                                                drag_parent as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top)
                                                    };
                                                top as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let parent_event: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(parent_event)
                                                    };
                                                parent_event as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let adv_hittest: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(adv_hittest)
                                                    };
                                                adv_hittest as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let gesture_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(gesture_parent)
                                                    };
                                                gesture_parent as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let focus_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(focus_parent)
                                                    };
                                                focus_parent as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 3u8,
                                            {
                                                let drag_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_dir)
                                                    };
                                                drag_dir as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 2u8,
                                            {
                                                let base_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(base_dir)
                                                    };
                                                base_dir as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_OBJ_PART_MAIN: _bindgen_ty_31 = 0;
        pub const _LV_OBJ_PART_VIRTUAL_LAST: _bindgen_ty_31 = 1;
        pub const _LV_OBJ_PART_REAL_LAST: _bindgen_ty_31 = 64;
        pub const LV_OBJ_PART_ALL: _bindgen_ty_31 = 255;
        pub type _bindgen_ty_31 = u32;
        pub type lv_obj_part_t = u8;
        #[doc =
          " Used by `lv_obj_get_type()`. The object's and its ancestor types are stored here"]
        #[repr(C)]
        pub struct lv_obj_type_t {
            #[doc =
              "< [0]: the actual type, [1]: ancestor, [2] #1's ancestor"]
            #[doc = "... [x]: \"lv_obj\""]
            pub type_: [*const ::cty::c_char; 8usize],
        }
        impl Default for lv_obj_type_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Create a basic object"]
        #[doc = " - __`parent`__: pointer to a parent object."]
        #[doc = "                  If NULL then a screen will be created"]
        #[doc =
          " - __`copy`__: pointer to a base object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the new object"]
        pub fn create(parent: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a basic object"]
                #[doc = " - __`parent`__: pointer to a parent object."]
                #[doc =
                  "                  If NULL then a screen will be created"]
                #[doc =
                  " - __`copy`__: pointer to a base object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the new object"]
                pub fn lv_obj_create(parent: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_create(parent as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Delete 'obj' and all of its children"]
        #[doc = " - __`obj`__: pointer to an object to delete"]
        #[doc = " Return: LV_RES_INV because the object is deleted"]
        pub fn del(obj: *mut lv_obj_t) -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete 'obj' and all of its children"]
                #[doc = " - __`obj`__: pointer to an object to delete"]
                #[doc = " Return: LV_RES_INV because the object is deleted"]
                pub fn lv_obj_del(obj: *mut lv_obj_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_del(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " A function to be easily used in animation ready callback to delete an object when the animation is ready"]
        #[doc = " - __`a`__: pointer to the animation"]
        pub fn del_anim_ready_cb(a: *mut lv_anim_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " A function to be easily used in animation ready callback to delete an object when the animation is ready"]
                #[doc = " - __`a`__: pointer to the animation"]
                pub fn lv_obj_del_anim_ready_cb(a: *mut lv_anim_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_del_anim_ready_cb(a as *mut lv_anim_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Helper function for asynchronously deleting objects."]
        #[doc =
          " Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent)."]
        #[doc = " - __`obj`__: object to delete"]
        #[doc = " @see lv_async_call"]
        pub fn del_async(obj: *mut _lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Helper function for asynchronously deleting objects."]
                #[doc =
                  " Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent)."]
                #[doc = " - __`obj`__: object to delete"]
                #[doc = " @see lv_async_call"]
                pub fn lv_obj_del_async(obj: *mut _lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_del_async(obj as *mut _lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Delete all children of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn clean(obj: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete all children of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_clean(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_clean(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Mark an area of an object as invalid."]
        #[doc = " This area will be redrawn by 'lv_refr_task'"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`area`__: the area to redraw"]
        pub fn invalidate_area(obj: *const lv_obj_t, area: *const lv_area_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Mark an area of an object as invalid."]
                #[doc = " This area will be redrawn by 'lv_refr_task'"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`area`__: the area to redraw"]
                pub fn lv_obj_invalidate_area(obj: *const lv_obj_t,
                                              area: *const lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_invalidate_area(obj as *const lv_obj_t,
                                       area as *const lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn invalidate(obj: *const lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_invalidate(obj: *const lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_invalidate(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Tell whether an area of an object is visible (even partially) now or not"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`area`__: the are to check. The visible part of the area will be written back here."]
        #[doc =
          " Return: true: visible; false: not visible (hidden, out of parent, on other screen, etc)"]
        pub fn area_is_visible(obj: *const lv_obj_t, area: *mut lv_area_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Tell whether an area of an object is visible (even partially) now or not"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`area`__: the are to check. The visible part of the area will be written back here."]
                #[doc =
                  " Return: true: visible; false: not visible (hidden, out of parent, on other screen, etc)"]
                pub fn lv_obj_area_is_visible(obj: *const lv_obj_t,
                                              area: *mut lv_area_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_area_is_visible(obj as *const lv_obj_t,
                                           area as *mut lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Tell whether an object is visible (even partially) now or not"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return: true: visible; false: not visible (hidden, out of parent, on other screen, etc)"]
        pub fn is_visible(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Tell whether an object is visible (even partially) now or not"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: true: visible; false: not visible (hidden, out of parent, on other screen, etc)"]
                pub fn lv_obj_is_visible(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_is_visible(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set a new parent for an object. Its relative position will be the same."]
        #[doc = " - __`obj`__: pointer to an object. Can't be a screen."]
        #[doc =
          " - __`parent`__: pointer to the new parent object. (Can't be NULL)"]
        pub fn set_parent(obj: *mut lv_obj_t, parent: *mut lv_obj_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new parent for an object. Its relative position will be the same."]
                #[doc =
                  " - __`obj`__: pointer to an object. Can't be a screen."]
                #[doc =
                  " - __`parent`__: pointer to the new parent object. (Can't be NULL)"]
                pub fn lv_obj_set_parent(obj: *mut lv_obj_t,
                                         parent: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_parent(obj as *mut lv_obj_t,
                                  parent as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move and object to the foreground"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn move_foreground(obj: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move and object to the foreground"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_move_foreground(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_move_foreground(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move and object to the background"]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn move_background(obj: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move and object to the background"]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_move_background(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_move_background(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set relative the position of an object (relative to the parent)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`x`__: new distance from the left side of the parent"]
        #[doc = " - __`y`__: new distance from the top of the parent"]
        pub fn set_pos(obj: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set relative the position of an object (relative to the parent)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`x`__: new distance from the left side of the parent"]
                #[doc = " - __`y`__: new distance from the top of the parent"]
                pub fn lv_obj_set_pos(obj: *mut lv_obj_t, x: lv_coord_t,
                                      y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_pos(obj as *mut lv_obj_t, x as lv_coord_t,
                               y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the x coordinate of a object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`x`__: new distance from the left side from the parent"]
        pub fn set_x(obj: *mut lv_obj_t, x: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the x coordinate of a object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`x`__: new distance from the left side from the parent"]
                pub fn lv_obj_set_x(obj: *mut lv_obj_t, x: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_x(obj as *mut lv_obj_t, x as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the y coordinate of a object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`y`__: new distance from the top of the parent"]
        pub fn set_y(obj: *mut lv_obj_t, y: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the y coordinate of a object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`y`__: new distance from the top of the parent"]
                pub fn lv_obj_set_y(obj: *mut lv_obj_t, y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_y(obj as *mut lv_obj_t, y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the size of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`w`__: new width"]
        #[doc = " - __`h`__: new height"]
        pub fn set_size(obj: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the size of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`w`__: new width"]
                #[doc = " - __`h`__: new height"]
                pub fn lv_obj_set_size(obj: *mut lv_obj_t, w: lv_coord_t,
                                       h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_size(obj as *mut lv_obj_t, w as lv_coord_t,
                                h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the width of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`w`__: new width"]
        pub fn set_width(obj: *mut lv_obj_t, w: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the width of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`w`__: new width"]
                pub fn lv_obj_set_width(obj: *mut lv_obj_t, w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_width(obj as *mut lv_obj_t, w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the height of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`h`__: new height"]
        pub fn set_height(obj: *mut lv_obj_t, h: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the height of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`h`__: new height"]
                pub fn lv_obj_set_height(obj: *mut lv_obj_t, h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_height(obj as *mut lv_obj_t, h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the width reduced by the left and right padding."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`w`__: the width without paddings"]
        pub fn set_width_fit(obj: *mut lv_obj_t, w: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the width reduced by the left and right padding."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`w`__: the width without paddings"]
                pub fn lv_obj_set_width_fit(obj: *mut lv_obj_t,
                                            w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_width_fit(obj as *mut lv_obj_t, w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the height reduced by the top and bottom padding."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`h`__: the height without paddings"]
        pub fn set_height_fit(obj: *mut lv_obj_t, h: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the height reduced by the top and bottom padding."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`h`__: the height without paddings"]
                pub fn lv_obj_set_height_fit(obj: *mut lv_obj_t,
                                             h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_height_fit(obj as *mut lv_obj_t, h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the width of an object by taking the left and right margin into account."]
        #[doc =
          " The object width will be `obj_w = w - margin_left - margin_right`"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`w`__: new height including margins"]
        pub fn set_width_margin(obj: *mut lv_obj_t, w: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the width of an object by taking the left and right margin into account."]
                #[doc =
                  " The object width will be `obj_w = w - margin_left - margin_right`"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`w`__: new height including margins"]
                pub fn lv_obj_set_width_margin(obj: *mut lv_obj_t,
                                               w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_width_margin(obj as *mut lv_obj_t,
                                        w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the height of an object by taking the top and bottom margin into account."]
        #[doc =
          " The object height will be `obj_h = h - margin_top - margin_bottom`"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`h`__: new height including margins"]
        pub fn set_height_margin(obj: *mut lv_obj_t, h: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the height of an object by taking the top and bottom margin into account."]
                #[doc =
                  " The object height will be `obj_h = h - margin_top - margin_bottom`"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`h`__: new height including margins"]
                pub fn lv_obj_set_height_margin(obj: *mut lv_obj_t,
                                                h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_height_margin(obj as *mut lv_obj_t,
                                         h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Align an object to an other object."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
        #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
        pub fn align(obj: *mut lv_obj_t, base: *const lv_obj_t,
                     align: lv_align_t, x_ofs: lv_coord_t, y_ofs: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Align an object to an other object."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
                #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
                pub fn lv_obj_align(obj: *mut lv_obj_t, base: *const lv_obj_t,
                                    align: lv_align_t, x_ofs: lv_coord_t,
                                    y_ofs: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align(obj as *mut lv_obj_t, base as *const lv_obj_t,
                             align as lv_align_t, x_ofs as lv_coord_t,
                             y_ofs as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Align an object to an other object horizontally."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
        pub fn align_x(obj: *mut lv_obj_t, base: *const lv_obj_t,
                       align: lv_align_t, x_ofs: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Align an object to an other object horizontally."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
                pub fn lv_obj_align_x(obj: *mut lv_obj_t,
                                      base: *const lv_obj_t,
                                      align: lv_align_t, x_ofs: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align_x(obj as *mut lv_obj_t, base as *const lv_obj_t,
                               align as lv_align_t, x_ofs as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Align an object to an other object vertically."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
        pub fn align_y(obj: *mut lv_obj_t, base: *const lv_obj_t,
                       align: lv_align_t, y_ofs: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Align an object to an other object vertically."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
                pub fn lv_obj_align_y(obj: *mut lv_obj_t,
                                      base: *const lv_obj_t,
                                      align: lv_align_t, y_ofs: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align_y(obj as *mut lv_obj_t, base as *const lv_obj_t,
                               align as lv_align_t, y_ofs as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Align an object to an other object."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
        #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
        pub fn align_mid(obj: *mut lv_obj_t, base: *const lv_obj_t,
                         align: lv_align_t, x_ofs: lv_coord_t,
                         y_ofs: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Align an object to an other object."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
                #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
                pub fn lv_obj_align_mid(obj: *mut lv_obj_t,
                                        base: *const lv_obj_t,
                                        align: lv_align_t, x_ofs: lv_coord_t,
                                        y_ofs: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align_mid(obj as *mut lv_obj_t,
                                 base as *const lv_obj_t, align as lv_align_t,
                                 x_ofs as lv_coord_t, y_ofs as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Align an object's middle point to an other object horizontally."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
        pub fn align_mid_x(obj: *mut lv_obj_t, base: *const lv_obj_t,
                           align: lv_align_t, x_ofs: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Align an object's middle point to an other object horizontally."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
                pub fn lv_obj_align_mid_x(obj: *mut lv_obj_t,
                                          base: *const lv_obj_t,
                                          align: lv_align_t,
                                          x_ofs: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align_mid_x(obj as *mut lv_obj_t,
                                   base as *const lv_obj_t,
                                   align as lv_align_t, x_ofs as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Align an object's middle point to an other object vertically."]
        #[doc = " - __`obj`__: pointer to an object to align"]
        #[doc =
          " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
        #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
        #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
        pub fn align_mid_y(obj: *mut lv_obj_t, base: *const lv_obj_t,
                           align: lv_align_t, y_ofs: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Align an object's middle point to an other object vertically."]
                #[doc = " - __`obj`__: pointer to an object to align"]
                #[doc =
                  " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
                #[doc =
                  " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
                #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
                pub fn lv_obj_align_mid_y(obj: *mut lv_obj_t,
                                          base: *const lv_obj_t,
                                          align: lv_align_t,
                                          y_ofs: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_align_mid_y(obj as *mut lv_obj_t,
                                   base as *const lv_obj_t,
                                   align as lv_align_t, y_ofs as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Realign the object based on the last `lv_obj_align` parameters."]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn realign(obj: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Realign the object based on the last `lv_obj_align` parameters."]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_realign(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_realign(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the automatic realign of the object when its size has changed based on the last"]
        #[doc = " `lv_obj_align` parameters."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`en`__: true: enable auto realign; false: disable auto realign"]
        pub fn set_auto_realign(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the automatic realign of the object when its size has changed based on the last"]
                #[doc = " `lv_obj_align` parameters."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: enable auto realign; false: disable auto realign"]
                pub fn lv_obj_set_auto_realign(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_auto_realign(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the size of an extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`left`__: extended clickable are on the left [px]"]
        #[doc = " - __`right`__: extended clickable are on the right [px]"]
        #[doc = " - __`top`__: extended clickable are on the top [px]"]
        #[doc = " - __`bottom`__: extended clickable are on the bottom [px]"]
        pub fn set_ext_click_area(obj: *mut lv_obj_t, left: lv_coord_t,
                                  right: lv_coord_t, top: lv_coord_t,
                                  bottom: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the size of an extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`left`__: extended clickable are on the left [px]"]
                #[doc =
                  " - __`right`__: extended clickable are on the right [px]"]
                #[doc =
                  " - __`top`__: extended clickable are on the top [px]"]
                #[doc =
                  " - __`bottom`__: extended clickable are on the bottom [px]"]
                pub fn lv_obj_set_ext_click_area(obj: *mut lv_obj_t,
                                                 left: lv_coord_t,
                                                 right: lv_coord_t,
                                                 top: lv_coord_t,
                                                 bottom: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_ext_click_area(obj as *mut lv_obj_t,
                                          left as lv_coord_t,
                                          right as lv_coord_t,
                                          top as lv_coord_t,
                                          bottom as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Add a new style to the style list of an object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: the part of the object which style property should be set."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        #[doc =
          " - __`style`__: pointer to a style to add (Only its pointer will be saved)"]
        pub fn add_style(obj: *mut lv_obj_t, part: u8, style: *mut lv_style_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add a new style to the style list of an object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: the part of the object which style property should be set."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                #[doc =
                  " - __`style`__: pointer to a style to add (Only its pointer will be saved)"]
                pub fn lv_obj_add_style(obj: *mut lv_obj_t, part: u8,
                                        style: *mut lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_add_style(obj as *mut lv_obj_t, part as u8,
                                 style as *mut lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Remove a style from the style list of an object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: the part of the object which style property should be set."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        #[doc = " - __`style`__: pointer to a style to remove"]
        pub fn remove_style(obj: *mut lv_obj_t, part: u8,
                            style: *mut lv_style_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove a style from the style list of an object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: the part of the object which style property should be set."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                #[doc = " - __`style`__: pointer to a style to remove"]
                pub fn lv_obj_remove_style(obj: *mut lv_obj_t, part: u8,
                                           style: *mut lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_remove_style(obj as *mut lv_obj_t, part as u8,
                                    style as *mut lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Reset a style to the default (empty) state."]
        #[doc =
          " Release all used memories and cancel pending related transitions."]
        #[doc = " Typically used in `LV_SIGN_CLEAN_UP."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: the part of the object which style list should be reseted."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        pub fn clean_style_list(obj: *mut lv_obj_t, part: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Reset a style to the default (empty) state."]
                #[doc =
                  " Release all used memories and cancel pending related transitions."]
                #[doc = " Typically used in `LV_SIGN_CLEAN_UP."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: the part of the object which style list should be reseted."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                pub fn lv_obj_clean_style_list(obj: *mut lv_obj_t, part: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_clean_style_list(obj as *mut lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Reset a style to the default (empty) state."]
        #[doc =
          " Release all used memories and cancel pending related transitions."]
        #[doc = " Also notifies the object about the style change."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: the part of the object which style list should be reseted."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        pub fn reset_style_list(obj: *mut lv_obj_t, part: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Reset a style to the default (empty) state."]
                #[doc =
                  " Release all used memories and cancel pending related transitions."]
                #[doc = " Also notifies the object about the style change."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: the part of the object which style list should be reseted."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                pub fn lv_obj_reset_style_list(obj: *mut lv_obj_t, part: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_reset_style_list(obj as *mut lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Notify an object (and its children) about its style is modified"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`prop`__: `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed."]
        pub fn refresh_style(obj: *mut lv_obj_t, part: u8,
                             prop: lv_style_property_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Notify an object (and its children) about its style is modified"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`prop`__: `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed."]
                pub fn lv_obj_refresh_style(obj: *mut lv_obj_t, part: u8,
                                            prop: lv_style_property_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_refresh_style(obj as *mut lv_obj_t, part as u8,
                                     prop as lv_style_property_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Notify all object if a style is modified"]
        #[doc =
          " - __`style`__: pointer to a style. Only the objects with this style will be notified"]
        #[doc = "               (NULL to notify all objects)"]
        pub fn report_style_mod(style: *mut lv_style_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Notify all object if a style is modified"]
                #[doc =
                  " - __`style`__: pointer to a style. Only the objects with this style will be notified"]
                #[doc = "               (NULL to notify all objects)"]
                pub fn lv_obj_report_style_mod(style: *mut lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_report_style_mod(style as *mut lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Remove a local style property from a part of an object with a given state."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: the part of the object which style property should be removed."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        #[doc = " - __`prop`__: a style property ORed with a state."]
        #[doc =
          " E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`"]
        #[doc =
          " __Note:__ shouldn't be used directly. Use the specific property remove functions instead."]
        #[doc = "       For example: `lv_obj_style_remove_border_opa()`"]
        #[doc =
          " Return: true: the property was found and removed; false: the property was not found"]
        pub fn remove_style_local_prop(obj: *mut lv_obj_t, part: u8,
                                       prop: lv_style_property_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Remove a local style property from a part of an object with a given state."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: the part of the object which style property should be removed."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                #[doc = " - __`prop`__: a style property ORed with a state."]
                #[doc =
                  " E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`"]
                #[doc =
                  " __Note:__ shouldn't be used directly. Use the specific property remove functions instead."]
                #[doc =
                  "       For example: `lv_obj_style_remove_border_opa()`"]
                #[doc =
                  " Return: true: the property was found and removed; false: the property was not found"]
                pub fn lv_obj_remove_style_local_prop(obj: *mut lv_obj_t,
                                                      part: u8,
                                                      prop:
                                                          lv_style_property_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_remove_style_local_prop(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   prop as
                                                       lv_style_property_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Hide an object. It won't be visible and clickable."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: hide the object"]
        pub fn set_hidden(obj: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Hide an object. It won't be visible and clickable."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: hide the object"]
                pub fn lv_obj_set_hidden(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_hidden(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set whether advanced hit-testing is enabled on an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: advanced hit-testing is enabled"]
        pub fn set_adv_hittest(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set whether advanced hit-testing is enabled on an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: advanced hit-testing is enabled"]
                pub fn lv_obj_set_adv_hittest(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_adv_hittest(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable or disable the clicking of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: make the object clickable"]
        pub fn set_click(obj: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable or disable the clicking of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: make the object clickable"]
                pub fn lv_obj_set_click(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_click(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable to bring this object to the foreground if it"]
        #[doc = " or any of its children is clicked"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the auto top feature"]
        pub fn set_top(obj: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable to bring this object to the foreground if it"]
                #[doc = " or any of its children is clicked"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: enable the auto top feature"]
                pub fn lv_obj_set_top(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_top(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the dragging of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: make the object draggable"]
        pub fn set_drag(obj: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable the dragging of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: make the object draggable"]
                pub fn lv_obj_set_drag(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the directions an object can be dragged in"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`drag_dir`__: bitwise OR of allowed drag directions"]
        pub fn set_drag_dir(obj: *mut lv_obj_t, drag_dir: lv_drag_dir_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the directions an object can be dragged in"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`drag_dir`__: bitwise OR of allowed drag directions"]
                pub fn lv_obj_set_drag_dir(obj: *mut lv_obj_t,
                                           drag_dir: lv_drag_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag_dir(obj as *mut lv_obj_t,
                                    drag_dir as lv_drag_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the throwing of an object after is is dragged"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the drag throw"]
        pub fn set_drag_throw(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the throwing of an object after is is dragged"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: enable the drag throw"]
                pub fn lv_obj_set_drag_throw(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag_throw(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable to use parent for drag related operations."]
        #[doc =
          " If trying to drag the object the parent will be moved instead"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the 'drag parent' for the object"]
        pub fn set_drag_parent(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable to use parent for drag related operations."]
                #[doc =
                  " If trying to drag the object the parent will be moved instead"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: enable the 'drag parent' for the object"]
                pub fn lv_obj_set_drag_parent(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_drag_parent(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable to use parent for focus state."]
        #[doc =
          " When object is focused the parent will get the state instead (visual only)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the 'focus parent' for the object"]
        pub fn set_focus_parent(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable to use parent for focus state."]
                #[doc =
                  " When object is focused the parent will get the state instead (visual only)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: enable the 'focus parent' for the object"]
                pub fn lv_obj_set_focus_parent(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_focus_parent(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable to use parent for gesture related operations."]
        #[doc =
          " If trying to gesture the object the parent will be moved instead"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`en`__: true: enable the 'gesture parent' for the object"]
        pub fn set_gesture_parent(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable to use parent for gesture related operations."]
                #[doc =
                  " If trying to gesture the object the parent will be moved instead"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`en`__: true: enable the 'gesture parent' for the object"]
                pub fn lv_obj_set_gesture_parent(obj: *mut lv_obj_t,
                                                 en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_gesture_parent(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Propagate the events to the parent too"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`en`__: true: enable the event propagation"]
        pub fn set_parent_event(obj: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Propagate the events to the parent too"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`en`__: true: enable the event propagation"]
                pub fn lv_obj_set_parent_event(obj: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_parent_event(obj as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the base direction of the object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`dir`__: the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`"]
        pub fn set_base_dir(obj: *mut lv_obj_t, dir: lv_bidi_dir_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the base direction of the object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`dir`__: the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`"]
                pub fn lv_obj_set_base_dir(obj: *mut lv_obj_t,
                                           dir: lv_bidi_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_base_dir(obj as *mut lv_obj_t,
                                    dir as lv_bidi_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a bit or bits in the protect filed"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
        pub fn add_protect(obj: *mut lv_obj_t, prot: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a bit or bits in the protect filed"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
                pub fn lv_obj_add_protect(obj: *mut lv_obj_t, prot: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_add_protect(obj as *mut lv_obj_t, prot as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Clear a bit or bits in the protect filed"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
        pub fn clear_protect(obj: *mut lv_obj_t, prot: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Clear a bit or bits in the protect filed"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
                pub fn lv_obj_clear_protect(obj: *mut lv_obj_t, prot: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_clear_protect(obj as *mut lv_obj_t, prot as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the state (fully overwrite) of an object."]
        #[doc =
          " If specified in the styles a transition animation will be started"]
        #[doc = " from the previous state to the current"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`state`__: the new state"]
        pub fn set_state(obj: *mut lv_obj_t, state: lv_state_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the state (fully overwrite) of an object."]
                #[doc =
                  " If specified in the styles a transition animation will be started"]
                #[doc = " from the previous state to the current"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`state`__: the new state"]
                pub fn lv_obj_set_state(obj: *mut lv_obj_t,
                                        state: lv_state_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_state(obj as *mut lv_obj_t, state as lv_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Add a given state or states to the object. The other state bits will remain unchanged."]
        #[doc =
          " If specified in the styles a transition animation will be started"]
        #[doc = " from the previous state to the current"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`state`__: the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`"]
        pub fn add_state(obj: *mut lv_obj_t, state: lv_state_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Add a given state or states to the object. The other state bits will remain unchanged."]
                #[doc =
                  " If specified in the styles a transition animation will be started"]
                #[doc = " from the previous state to the current"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`state`__: the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`"]
                pub fn lv_obj_add_state(obj: *mut lv_obj_t,
                                        state: lv_state_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_add_state(obj as *mut lv_obj_t, state as lv_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Remove a given state or states to the object. The other state bits will remain unchanged."]
        #[doc =
          " If specified in the styles a transition animation will be started"]
        #[doc = " from the previous state to the current"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`state`__: the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`"]
        pub fn clear_state(obj: *mut lv_obj_t, state: lv_state_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Remove a given state or states to the object. The other state bits will remain unchanged."]
                #[doc =
                  " If specified in the styles a transition animation will be started"]
                #[doc = " from the previous state to the current"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`state`__: the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`"]
                pub fn lv_obj_clear_state(obj: *mut lv_obj_t,
                                          state: lv_state_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_clear_state(obj as *mut lv_obj_t, state as lv_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Finish all pending transitions on a part of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts"]
        pub fn finish_transitions(obj: *mut lv_obj_t, part: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Finish all pending transitions on a part of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts"]
                pub fn lv_obj_finish_transitions(obj: *mut lv_obj_t,
                                                 part: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_finish_transitions(obj as *mut lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a an event handler function for an object."]
        #[doc =
          " Used by the user to react on event which happens with the object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`event_cb`__: the new event function"]
        pub fn set_event_cb(obj: *mut lv_obj_t, event_cb: lv_event_cb_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a an event handler function for an object."]
                #[doc =
                  " Used by the user to react on event which happens with the object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`event_cb`__: the new event function"]
                pub fn lv_obj_set_event_cb(obj: *mut lv_obj_t,
                                           event_cb: lv_event_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_event_cb(obj as *mut lv_obj_t,
                                    event_cb as lv_event_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the a signal function of an object. Used internally by the library."]
        #[doc = " Always call the previous signal function in the new."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`signal_cb`__: the new signal function"]
        pub fn set_signal_cb(obj: *mut lv_obj_t, signal_cb: lv_signal_cb_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the a signal function of an object. Used internally by the library."]
                #[doc =
                  " Always call the previous signal function in the new."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`signal_cb`__: the new signal function"]
                pub fn lv_obj_set_signal_cb(obj: *mut lv_obj_t,
                                            signal_cb: lv_signal_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_signal_cb(obj as *mut lv_obj_t,
                                     signal_cb as lv_signal_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new design function for an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`design_cb`__: the new design function"]
        pub fn set_design_cb(obj: *mut lv_obj_t, design_cb: lv_design_cb_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new design function for an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`design_cb`__: the new design function"]
                pub fn lv_obj_set_design_cb(obj: *mut lv_obj_t,
                                            design_cb: lv_design_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_design_cb(obj as *mut lv_obj_t,
                                     design_cb as lv_design_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Allocate a new ext. data for an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`ext_size`__: the size of the new ext. data"]
        #[doc = " Return: pointer to the allocated ext"]
        pub fn allocate_ext_attr(obj: *mut lv_obj_t, ext_size: u16)
         -> MynewtResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Allocate a new ext. data for an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`ext_size`__: the size of the new ext. data"]
                #[doc = " Return: pointer to the allocated ext"]
                pub fn lv_obj_allocate_ext_attr(obj: *mut lv_obj_t,
                                                ext_size: u16)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_allocate_ext_attr(obj as *mut lv_obj_t,
                                             ext_size as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area."]
        #[doc =
          " he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function."]
        #[doc = " - __`obj`__: pointer to an object"]
        pub fn refresh_ext_draw_pad(obj: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area."]
                #[doc =
                  " he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function."]
                #[doc = " - __`obj`__: pointer to an object"]
                pub fn lv_obj_refresh_ext_draw_pad(obj: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_refresh_ext_draw_pad(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Return with the screen of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to a screen"]
        pub fn get_screen(obj: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with the screen of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to a screen"]
                pub fn lv_obj_get_screen(obj: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_screen(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the display of an object"]
        #[doc = " Return: pointer the object's display"]
        pub fn get_disp(obj: *const lv_obj_t)
         -> MynewtResult<*mut lv_disp_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the display of an object"]
                #[doc = " Return: pointer the object's display"]
                pub fn lv_obj_get_disp(obj: *const lv_obj_t)
                -> *mut lv_disp_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_disp(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Returns with the parent of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to the parent of  'obj'"]
        pub fn get_parent(obj: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Returns with the parent of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to the parent of  'obj'"]
                pub fn lv_obj_get_parent(obj: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_parent(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Iterate through the children of an object (start from the \"youngest, lastly created\")"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`child`__: NULL at first call to get the next children"]
        #[doc = "                  and the previous return value later"]
        #[doc =
          " Return: the child after 'act_child' or NULL if no more child"]
        pub fn get_child(obj: *const lv_obj_t, child: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Iterate through the children of an object (start from the \"youngest, lastly created\")"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`child`__: NULL at first call to get the next children"]
                #[doc =
                  "                  and the previous return value later"]
                #[doc =
                  " Return: the child after 'act_child' or NULL if no more child"]
                pub fn lv_obj_get_child(obj: *const lv_obj_t,
                                        child: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_child(obj as *const lv_obj_t,
                                     child as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Iterate through the children of an object (start from the \"oldest\", firstly created)"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`child`__: NULL at first call to get the next children"]
        #[doc = "                  and the previous return value later"]
        #[doc =
          " Return: the child after 'act_child' or NULL if no more child"]
        pub fn get_child_back(obj: *const lv_obj_t, child: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Iterate through the children of an object (start from the \"oldest\", firstly created)"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`child`__: NULL at first call to get the next children"]
                #[doc =
                  "                  and the previous return value later"]
                #[doc =
                  " Return: the child after 'act_child' or NULL if no more child"]
                pub fn lv_obj_get_child_back(obj: *const lv_obj_t,
                                             child: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_child_back(obj as *const lv_obj_t,
                                          child as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Count the children of an object (only children directly on 'obj')"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: children number of 'obj'"]
        pub fn count_children(obj: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Count the children of an object (only children directly on 'obj')"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: children number of 'obj'"]
                pub fn lv_obj_count_children(obj: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_count_children(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Recursively count the children of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: children number of 'obj'"]
        pub fn count_children_recursive(obj: *const lv_obj_t)
         -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Recursively count the children of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: children number of 'obj'"]
                pub fn lv_obj_count_children_recursive(obj: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_count_children_recursive(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Copy the coordinates of an object to an area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`cords_p`__: pointer to an area to store the coordinates"]
        pub fn get_coords(obj: *const lv_obj_t, cords_p: *mut lv_area_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy the coordinates of an object to an area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`cords_p`__: pointer to an area to store the coordinates"]
                pub fn lv_obj_get_coords(obj: *const lv_obj_t,
                                         cords_p: *mut lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_get_coords(obj as *const lv_obj_t,
                                  cords_p as *mut lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object."]
        #[doc =
          " (Without the size of the border or other extra graphical elements)"]
        #[doc = " - __`coords_p`__: store the result area here"]
        pub fn get_inner_coords(obj: *const lv_obj_t,
                                coords_p: *mut lv_area_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object."]
                #[doc =
                  " (Without the size of the border or other extra graphical elements)"]
                #[doc = " - __`coords_p`__: store the result area here"]
                pub fn lv_obj_get_inner_coords(obj: *const lv_obj_t,
                                               coords_p: *mut lv_area_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_get_inner_coords(obj as *const lv_obj_t,
                                        coords_p as *mut lv_area_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the x coordinate of object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: distance of 'obj' from the left side of its parent"]
        pub fn get_x(obj: *const lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the x coordinate of object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: distance of 'obj' from the left side of its parent"]
                pub fn lv_obj_get_x(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_x(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the y coordinate of object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: distance of 'obj' from the top of its parent"]
        pub fn get_y(obj: *const lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the y coordinate of object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: distance of 'obj' from the top of its parent"]
                pub fn lv_obj_get_y(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_y(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the width of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the width"]
        pub fn get_width(obj: *const lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the width"]
                pub fn lv_obj_get_width(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_width(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the height of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the height"]
        pub fn get_height(obj: *const lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the height of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the height"]
                pub fn lv_obj_get_height(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_height(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get that width reduced by the left and right padding."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the width which still fits into the container"]
        pub fn get_width_fit(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get that width reduced by the left and right padding."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: the width which still fits into the container"]
                pub fn lv_obj_get_width_fit(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_width_fit(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get that height reduced by the top an bottom padding."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the height which still fits into the container"]
        pub fn get_height_fit(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get that height reduced by the top an bottom padding."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: the height which still fits into the container"]
                pub fn lv_obj_get_height_fit(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_height_fit(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the height of an object by taking the top and bottom margin into account."]
        #[doc =
          " The returned height will be `obj_h + margin_top + margin_bottom`"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the height including thee margins"]
        pub fn get_height_margin(obj: *mut lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the height of an object by taking the top and bottom margin into account."]
                #[doc =
                  " The returned height will be `obj_h + margin_top + margin_bottom`"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the height including thee margins"]
                pub fn lv_obj_get_height_margin(obj: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_height_margin(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the width of an object by taking the left and right margin into account."]
        #[doc =
          " The returned width will be `obj_w + margin_left + margin_right`"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the height including thee margins"]
        pub fn get_width_margin(obj: *mut lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the width of an object by taking the left and right margin into account."]
                #[doc =
                  " The returned width will be `obj_w + margin_left + margin_right`"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the height including thee margins"]
                pub fn lv_obj_get_width_margin(obj: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_width_margin(obj as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Divide the width of the object and get the width of a given number of columns."]
        #[doc = " Take paddings into account."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`div`__: indicates how many columns are assumed."]
        #[doc = " If 1 the width will be set the the parent's width"]
        #[doc = " If 2 only half parent width - inner padding of the parent"]
        #[doc =
          " If 3 only third parent width - 2 * inner padding of the parent"]
        #[doc = " - __`span`__: how many columns are combined"]
        #[doc = " Return: the width according to the given parameters"]
        pub fn get_width_grid(obj: *mut lv_obj_t, div: u8, span: u8)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Divide the width of the object and get the width of a given number of columns."]
                #[doc = " Take paddings into account."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`div`__: indicates how many columns are assumed."]
                #[doc = " If 1 the width will be set the the parent's width"]
                #[doc =
                  " If 2 only half parent width - inner padding of the parent"]
                #[doc =
                  " If 3 only third parent width - 2 * inner padding of the parent"]
                #[doc = " - __`span`__: how many columns are combined"]
                #[doc =
                  " Return: the width according to the given parameters"]
                pub fn lv_obj_get_width_grid(obj: *mut lv_obj_t, div: u8,
                                             span: u8)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_width_grid(obj as *mut lv_obj_t, div as u8,
                                          span as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Divide the height of the object and get the width of a given number of columns."]
        #[doc = " Take paddings into account."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`div`__: indicates how many rows are assumed."]
        #[doc = " If 1 the height will be set the the parent's height"]
        #[doc = " If 2 only half parent height - inner padding of the parent"]
        #[doc =
          " If 3 only third parent height - 2 * inner padding of the parent"]
        #[doc = " - __`span`__: how many rows are combined"]
        #[doc = " Return: the height according to the given parameters"]
        pub fn get_height_grid(obj: *mut lv_obj_t, div: u8, span: u8)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Divide the height of the object and get the width of a given number of columns."]
                #[doc = " Take paddings into account."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`div`__: indicates how many rows are assumed."]
                #[doc =
                  " If 1 the height will be set the the parent's height"]
                #[doc =
                  " If 2 only half parent height - inner padding of the parent"]
                #[doc =
                  " If 3 only third parent height - 2 * inner padding of the parent"]
                #[doc = " - __`span`__: how many rows are combined"]
                #[doc =
                  " Return: the height according to the given parameters"]
                pub fn lv_obj_get_height_grid(obj: *mut lv_obj_t, div: u8,
                                              span: u8)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_height_grid(obj as *mut lv_obj_t, div as u8,
                                           span as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the automatic realign property of the object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return:  true: auto realign is enabled; false: auto realign is disabled"]
        pub fn get_auto_realign(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the automatic realign property of the object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return:  true: auto realign is enabled; false: auto realign is disabled"]
                pub fn lv_obj_get_auto_realign(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_auto_realign(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the left padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended left padding"]
        pub fn get_ext_click_pad_left(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the left padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended left padding"]
                pub fn lv_obj_get_ext_click_pad_left(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_left(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the right padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended right padding"]
        pub fn get_ext_click_pad_right(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the right padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended right padding"]
                pub fn lv_obj_get_ext_click_pad_right(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_right(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the top padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended top padding"]
        pub fn get_ext_click_pad_top(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the top padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended top padding"]
                pub fn lv_obj_get_ext_click_pad_top(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_top(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the bottom padding of extended clickable area"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended bottom padding"]
        pub fn get_ext_click_pad_bottom(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the bottom padding of extended clickable area"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended bottom padding"]
                pub fn lv_obj_get_ext_click_pad_bottom(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_click_pad_bottom(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the extended size attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the extended size attribute"]
        pub fn get_ext_draw_pad(obj: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the extended size attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the extended size attribute"]
                pub fn lv_obj_get_ext_draw_pad(obj: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_draw_pad(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the style list of an object's part."]
        #[doc = " - __`obj`__: pointer to an object."]
        #[doc =
          " - __`part`__: part the part of the object which style list should be get."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        #[doc = " Return: pointer to the style list. (Can be `NULL`)"]
        pub fn get_style_list(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<*mut lv_style_list_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the style list of an object's part."]
                #[doc = " - __`obj`__: pointer to an object."]
                #[doc =
                  " - __`part`__: part the part of the object which style list should be get."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                #[doc = " Return: pointer to the style list. (Can be `NULL`)"]
                pub fn lv_obj_get_style_list(obj: *const lv_obj_t, part: u8)
                -> *mut lv_style_list_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_list(obj as *const lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the local style of a part of an object."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`part`__: the part of the object which style property should be set."]
        #[doc =
          " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
        #[doc = " Return: pointer to the local style if exists else `NULL`."]
        pub fn get_local_style(obj: *mut lv_obj_t, part: u8)
         -> MynewtResult<*mut lv_style_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the local style of a part of an object."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`part`__: the part of the object which style property should be set."]
                #[doc =
                  " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
                #[doc =
                  " Return: pointer to the local style if exists else `NULL`."]
                pub fn lv_obj_get_local_style(obj: *mut lv_obj_t, part: u8)
                -> *mut lv_style_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_local_style(obj as *mut lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn get_style_radius(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_radius(obj: *const lv_obj_t, part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_radius(obj as *const lv_obj_t,
                                            part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_radius(obj: *mut lv_obj_t, part: u8,
                                      state: lv_state_t,
                                      value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_radius(obj: *mut lv_obj_t,
                                                     part: u8,
                                                     state: lv_state_t,
                                                     value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_radius(obj as *mut lv_obj_t,
                                              part as u8, state as lv_state_t,
                                              value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_clip_corner(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_clip_corner(obj: *const lv_obj_t,
                                                    part: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_clip_corner(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_clip_corner(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t, value: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_clip_corner(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_clip_corner(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_size(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_size(obj: *const lv_obj_t, part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_size(obj as *const lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_size(obj: *mut lv_obj_t, part: u8,
                                    state: lv_state_t, value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_size(obj: *mut lv_obj_t,
                                                   part: u8,
                                                   state: lv_state_t,
                                                   value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_size(obj as *mut lv_obj_t, part as u8,
                                            state as lv_state_t,
                                            value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transform_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transform_width(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transform_width(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transform_width(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transform_width(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transform_width(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transform_height(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transform_height(obj: *const lv_obj_t,
                                                         part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transform_height(obj as *const lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transform_height(obj: *mut lv_obj_t, part: u8,
                                                state: lv_state_t,
                                                value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transform_height(obj:
                                                                   *mut lv_obj_t,
                                                               part: u8,
                                                               state:
                                                                   lv_state_t,
                                                               value:
                                                                   lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transform_height(obj as *mut lv_obj_t,
                                                        part as u8,
                                                        state as lv_state_t,
                                                        value as
                                                            lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transform_angle(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transform_angle(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transform_angle(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transform_angle(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transform_angle(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transform_angle(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transform_zoom(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transform_zoom(obj: *const lv_obj_t,
                                                       part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transform_zoom(obj as *const lv_obj_t,
                                                    part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transform_zoom(obj: *mut lv_obj_t, part: u8,
                                              state: lv_state_t,
                                              value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transform_zoom(obj:
                                                                 *mut lv_obj_t,
                                                             part: u8,
                                                             state:
                                                                 lv_state_t,
                                                             value:
                                                                 lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transform_zoom(obj as *mut lv_obj_t,
                                                      part as u8,
                                                      state as lv_state_t,
                                                      value as
                                                          lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_opa_scale(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_opa_scale(obj: *const lv_obj_t,
                                                  part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_opa_scale(obj as *const lv_obj_t,
                                               part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_opa_scale(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_opa_scale(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_opa_scale(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pad_top(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pad_top(obj: *const lv_obj_t,
                                                part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pad_top(obj as *const lv_obj_t,
                                             part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pad_top(obj: *mut lv_obj_t, part: u8,
                                       state: lv_state_t,
                                       value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_top(obj: *mut lv_obj_t,
                                                      part: u8,
                                                      state: lv_state_t,
                                                      value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_top(obj as *mut lv_obj_t,
                                               part as u8,
                                               state as lv_state_t,
                                               value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pad_bottom(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pad_bottom(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pad_bottom(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pad_bottom(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_bottom(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_bottom(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pad_left(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pad_left(obj: *const lv_obj_t,
                                                 part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pad_left(obj as *const lv_obj_t,
                                              part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pad_left(obj: *mut lv_obj_t, part: u8,
                                        state: lv_state_t,
                                        value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_left(obj: *mut lv_obj_t,
                                                       part: u8,
                                                       state: lv_state_t,
                                                       value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_left(obj as *mut lv_obj_t,
                                                part as u8,
                                                state as lv_state_t,
                                                value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pad_right(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pad_right(obj: *const lv_obj_t,
                                                  part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pad_right(obj as *const lv_obj_t,
                                               part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pad_right(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t,
                                         value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_right(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value:
                                                            lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_right(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pad_inner(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pad_inner(obj: *const lv_obj_t,
                                                  part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pad_inner(obj as *const lv_obj_t,
                                               part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pad_inner(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t,
                                         value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_inner(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value:
                                                            lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_inner(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_margin_top(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_margin_top(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_margin_top(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_margin_top(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_top(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_top(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_margin_bottom(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_margin_bottom(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_margin_bottom(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_margin_bottom(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_bottom(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_bottom(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_margin_left(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_margin_left(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_margin_left(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_margin_left(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_left(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_left(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_margin_right(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_margin_right(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_margin_right(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_margin_right(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_right(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_right(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_blend_mode(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_blend_mode(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_blend_mode(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_blend_mode(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_blend_mode(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as
                                                         lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_main_stop(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_main_stop(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_main_stop(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_main_stop(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_main_stop(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_main_stop(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_grad_stop(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_grad_stop(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_grad_stop(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_grad_stop(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_grad_stop(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_grad_stop(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_grad_dir(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_grad_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_grad_dir(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_grad_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_grad_dir(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_grad_dir(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_grad_dir_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_grad_dir(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_grad_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_grad_dir(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_grad_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_color(obj: *const lv_obj_t,
                                                 part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_color(obj as *const lv_obj_t,
                                              part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_color(obj: *mut lv_obj_t, part: u8,
                                        state: lv_state_t, value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_color(obj: *mut lv_obj_t,
                                                       part: u8,
                                                       state: lv_state_t,
                                                       value: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_color(obj as *mut lv_obj_t,
                                                part as u8,
                                                state as lv_state_t,
                                                value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_grad_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_grad_color(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_grad_color(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_grad_color(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_grad_color(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_grad_color(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_bg_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_bg_opa(obj: *const lv_obj_t, part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_bg_opa(obj as *const lv_obj_t,
                                            part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_bg_opa(obj: *mut lv_obj_t, part: u8,
                                      state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_bg_opa(obj: *mut lv_obj_t,
                                                     part: u8,
                                                     state: lv_state_t,
                                                     value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_bg_opa(obj as *mut lv_obj_t,
                                              part as u8, state as lv_state_t,
                                              value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_border_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_border_width(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_border_width(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_border_width(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_border_width(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_border_width(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_border_side(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_border_side_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_border_side(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_border_side_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_border_side(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_border_side(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_border_side_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_border_side(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_border_side_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_border_side(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_border_side_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_border_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_border_blend_mode(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_border_blend_mode(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_border_blend_mode(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_border_blend_mode(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_border_blend_mode(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_border_post(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_border_post(obj: *const lv_obj_t,
                                                    part: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_border_post(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_border_post(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t, value: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_border_post(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_border_post(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_border_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_border_color(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_border_color(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_border_color(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_border_color(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_border_color(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_border_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_border_opa(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_border_opa(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_border_opa(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_border_opa(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_border_opa(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_outline_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_outline_width(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_outline_width(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_outline_width(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_outline_width(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_outline_width(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_outline_pad(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_outline_pad(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_outline_pad(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_outline_pad(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_outline_pad(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_outline_pad(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_outline_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_outline_blend_mode(obj:
                                                               *const lv_obj_t,
                                                           part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_outline_blend_mode(obj as
                                                            *const lv_obj_t,
                                                        part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_outline_blend_mode(obj: *mut lv_obj_t,
                                                  part: u8, state: lv_state_t,
                                                  value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_outline_blend_mode(obj:
                                                                     *mut lv_obj_t,
                                                                 part: u8,
                                                                 state:
                                                                     lv_state_t,
                                                                 value:
                                                                     lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_outline_blend_mode(obj as
                                                              *mut lv_obj_t,
                                                          part as u8,
                                                          state as lv_state_t,
                                                          value as
                                                              lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_outline_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_outline_color(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_outline_color(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_outline_color(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_outline_color(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_outline_color(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_outline_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_outline_opa(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_outline_opa(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_outline_opa(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_outline_opa(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_outline_opa(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_width(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_width(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_width(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_width(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_width(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_ofs_x(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_ofs_x(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_ofs_x(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_ofs_x(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_ofs_x(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_ofs_x(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_ofs_y(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_ofs_y(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_ofs_y(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_ofs_y(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_ofs_y(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value:
                                                               lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_ofs_y(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_spread(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_spread(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_spread(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_spread(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_spread(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_spread(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_blend_mode(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_blend_mode(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_blend_mode(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_blend_mode(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_blend_mode(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_color(obj: *const lv_obj_t,
                                                     part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_color(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_color(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t,
                                            value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_color(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_color(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_shadow_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_shadow_opa(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_shadow_opa(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_shadow_opa(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_shadow_opa(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_shadow_opa(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pattern_repeat(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pattern_repeat(obj: *const lv_obj_t,
                                                       part: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pattern_repeat(obj as *const lv_obj_t,
                                                    part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pattern_repeat(obj: *mut lv_obj_t, part: u8,
                                              state: lv_state_t, value: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pattern_repeat(obj:
                                                                 *mut lv_obj_t,
                                                             part: u8,
                                                             state:
                                                                 lv_state_t,
                                                             value: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pattern_repeat(obj as *mut lv_obj_t,
                                                      part as u8,
                                                      state as lv_state_t,
                                                      value as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pattern_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pattern_blend_mode(obj:
                                                               *const lv_obj_t,
                                                           part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pattern_blend_mode(obj as
                                                            *const lv_obj_t,
                                                        part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pattern_blend_mode(obj: *mut lv_obj_t,
                                                  part: u8, state: lv_state_t,
                                                  value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pattern_blend_mode(obj:
                                                                     *mut lv_obj_t,
                                                                 part: u8,
                                                                 state:
                                                                     lv_state_t,
                                                                 value:
                                                                     lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pattern_blend_mode(obj as
                                                              *mut lv_obj_t,
                                                          part as u8,
                                                          state as lv_state_t,
                                                          value as
                                                              lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pattern_recolor(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pattern_recolor(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pattern_recolor(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pattern_recolor(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pattern_recolor(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pattern_recolor(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pattern_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pattern_opa(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pattern_opa(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pattern_opa(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pattern_opa(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pattern_opa(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pattern_recolor_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pattern_recolor_opa(obj:
                                                                *const lv_obj_t,
                                                            part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pattern_recolor_opa(obj as
                                                             *const lv_obj_t,
                                                         part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pattern_recolor_opa(obj: *mut lv_obj_t,
                                                   part: u8,
                                                   state: lv_state_t,
                                                   value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pattern_recolor_opa(obj:
                                                                      *mut lv_obj_t,
                                                                  part: u8,
                                                                  state:
                                                                      lv_state_t,
                                                                  value:
                                                                      lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pattern_recolor_opa(obj as
                                                               *mut lv_obj_t,
                                                           part as u8,
                                                           state as
                                                               lv_state_t,
                                                           value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_pattern_image(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<*const ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_pattern_image(obj: *const lv_obj_t,
                                                      part: u8)
                -> *const ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_pattern_image(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_pattern_image(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: *const ::cty::c_void)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pattern_image(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                *const ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pattern_image(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as
                                                         *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_letter_space(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_letter_space(obj:
                                                               *const lv_obj_t,
                                                           part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_letter_space(obj as
                                                            *const lv_obj_t,
                                                        part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_letter_space(obj: *mut lv_obj_t,
                                                  part: u8, state: lv_state_t,
                                                  value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_letter_space(obj:
                                                                     *mut lv_obj_t,
                                                                 part: u8,
                                                                 state:
                                                                     lv_state_t,
                                                                 value:
                                                                     lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_letter_space(obj as
                                                              *mut lv_obj_t,
                                                          part as u8,
                                                          state as lv_state_t,
                                                          value as
                                                              lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_line_space(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_line_space(obj: *const lv_obj_t,
                                                         part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_line_space(obj as *const lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_line_space(obj: *mut lv_obj_t, part: u8,
                                                state: lv_state_t,
                                                value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_line_space(obj:
                                                                   *mut lv_obj_t,
                                                               part: u8,
                                                               state:
                                                                   lv_state_t,
                                                               value:
                                                                   lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_line_space(obj as *mut lv_obj_t,
                                                        part as u8,
                                                        state as lv_state_t,
                                                        value as
                                                            lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_blend_mode(obj: *const lv_obj_t,
                                                         part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_blend_mode(obj as *const lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_blend_mode(obj: *mut lv_obj_t, part: u8,
                                                state: lv_state_t,
                                                value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_blend_mode(obj:
                                                                   *mut lv_obj_t,
                                                               part: u8,
                                                               state:
                                                                   lv_state_t,
                                                               value:
                                                                   lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_blend_mode(obj as *mut lv_obj_t,
                                                        part as u8,
                                                        state as lv_state_t,
                                                        value as
                                                            lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_ofs_x(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_ofs_x(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_ofs_x(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_ofs_x(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_ofs_x(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_ofs_x(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_ofs_y(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_ofs_y(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_ofs_y(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_ofs_y(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_ofs_y(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_ofs_y(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_align(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_align(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_align(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_align(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_align_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_align(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value: lv_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_align(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_color(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_color(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_color(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_color(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_color(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_opa(obj: *const lv_obj_t,
                                                  part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_opa(obj as *const lv_obj_t,
                                               part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_opa(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_opa(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_opa(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_value_font(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<*const lv_font_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_value_font(obj: *const lv_obj_t,
                                                   part: u8)
                -> *const lv_font_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_value_font(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_value_font(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: *const lv_font_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_font(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             *const lv_font_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_font(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_value_str(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t, value: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_value_str(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value:
                                                            *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            value.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_value_str(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value.as_ptr() as
                                                     *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_letter_space(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_letter_space(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_letter_space(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_letter_space(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_letter_space(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_letter_space(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_line_space(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_line_space(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_line_space(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_line_space(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_line_space(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_line_space(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_decor(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_text_decor_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_decor(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_text_decor_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_decor(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_decor(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_text_decor_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_decor(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_text_decor_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_decor(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_text_decor_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_blend_mode(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_blend_mode(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_blend_mode(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_blend_mode(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_blend_mode(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_color(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_color(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_color(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_color(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_color(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_sel_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_sel_color(obj: *const lv_obj_t,
                                                       part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_sel_color(obj as *const lv_obj_t,
                                                    part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_sel_color(obj: *mut lv_obj_t, part: u8,
                                              state: lv_state_t,
                                              value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_sel_color(obj:
                                                                 *mut lv_obj_t,
                                                             part: u8,
                                                             state:
                                                                 lv_state_t,
                                                             value:
                                                                 lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_sel_color(obj as *mut lv_obj_t,
                                                      part as u8,
                                                      state as lv_state_t,
                                                      value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_opa(obj: *const lv_obj_t,
                                                 part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_opa(obj as *const lv_obj_t,
                                              part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_opa(obj: *mut lv_obj_t, part: u8,
                                        state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_opa(obj: *mut lv_obj_t,
                                                       part: u8,
                                                       state: lv_state_t,
                                                       value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_opa(obj as *mut lv_obj_t,
                                                part as u8,
                                                state as lv_state_t,
                                                value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_text_font(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<*const lv_font_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_text_font(obj: *const lv_obj_t,
                                                  part: u8)
                -> *const lv_font_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_text_font(obj as *const lv_obj_t,
                                               part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_text_font(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t,
                                         value: *const lv_font_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_text_font(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value:
                                                            *const lv_font_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_text_font(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_width(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_width(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_width(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_width(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_width(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_blend_mode(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_blend_mode(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_blend_mode(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_blend_mode(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_blend_mode(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_dash_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_dash_width(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_dash_width(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_dash_width(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_dash_width(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_dash_width(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_dash_gap(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_dash_gap(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_dash_gap(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_dash_gap(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_dash_gap(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_dash_gap(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_rounded(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_rounded(obj: *const lv_obj_t,
                                                     part: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_rounded(obj as *const lv_obj_t,
                                                  part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_rounded(obj: *mut lv_obj_t, part: u8,
                                            state: lv_state_t, value: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_rounded(obj: *mut lv_obj_t,
                                                           part: u8,
                                                           state: lv_state_t,
                                                           value: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_rounded(obj as *mut lv_obj_t,
                                                    part as u8,
                                                    state as lv_state_t,
                                                    value as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_color(obj: *const lv_obj_t,
                                                   part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_color(obj as *const lv_obj_t,
                                                part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_color(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_color(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_color(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_line_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_line_opa(obj: *const lv_obj_t,
                                                 part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_line_opa(obj as *const lv_obj_t,
                                              part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_line_opa(obj: *mut lv_obj_t, part: u8,
                                        state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_line_opa(obj: *mut lv_obj_t,
                                                       part: u8,
                                                       state: lv_state_t,
                                                       value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_line_opa(obj as *mut lv_obj_t,
                                                part as u8,
                                                state as lv_state_t,
                                                value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_image_blend_mode(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_blend_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_image_blend_mode(obj: *const lv_obj_t,
                                                         part: u8)
                -> lv_blend_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_image_blend_mode(obj as *const lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_image_blend_mode(obj: *mut lv_obj_t, part: u8,
                                                state: lv_state_t,
                                                value: lv_blend_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_image_blend_mode(obj:
                                                                   *mut lv_obj_t,
                                                               part: u8,
                                                               state:
                                                                   lv_state_t,
                                                               value:
                                                                   lv_blend_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_image_blend_mode(obj as *mut lv_obj_t,
                                                        part as u8,
                                                        state as lv_state_t,
                                                        value as
                                                            lv_blend_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_image_recolor(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_image_recolor(obj: *const lv_obj_t,
                                                      part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_image_recolor(obj as *const lv_obj_t,
                                                   part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_image_recolor(obj: *mut lv_obj_t, part: u8,
                                             state: lv_state_t,
                                             value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_image_recolor(obj:
                                                                *mut lv_obj_t,
                                                            part: u8,
                                                            state: lv_state_t,
                                                            value:
                                                                lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_image_recolor(obj as *mut lv_obj_t,
                                                     part as u8,
                                                     state as lv_state_t,
                                                     value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_image_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_image_opa(obj: *const lv_obj_t,
                                                  part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_image_opa(obj as *const lv_obj_t,
                                               part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_image_opa(obj: *mut lv_obj_t, part: u8,
                                         state: lv_state_t, value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_image_opa(obj: *mut lv_obj_t,
                                                        part: u8,
                                                        state: lv_state_t,
                                                        value: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_image_opa(obj as *mut lv_obj_t,
                                                 part as u8,
                                                 state as lv_state_t,
                                                 value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_image_recolor_opa(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_image_recolor_opa(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_image_recolor_opa(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_image_recolor_opa(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_image_recolor_opa(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_image_recolor_opa(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_time(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_time(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_time(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_time(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_time(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_time(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_delay(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_delay(obj: *const lv_obj_t,
                                                         part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_delay(obj as *const lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_delay(obj: *mut lv_obj_t, part: u8,
                                                state: lv_state_t,
                                                value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_delay(obj:
                                                                   *mut lv_obj_t,
                                                               part: u8,
                                                               state:
                                                                   lv_state_t,
                                                               value:
                                                                   lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_delay(obj as *mut lv_obj_t,
                                                        part as u8,
                                                        state as lv_state_t,
                                                        value as
                                                            lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_prop_1(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_prop_1(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_prop_1(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_prop_1(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_prop_1(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_prop_1(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_prop_2(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_prop_2(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_prop_2(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_prop_2(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_prop_2(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_prop_2(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_prop_3(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_prop_3(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_prop_3(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_prop_3(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_prop_3(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_prop_3(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_prop_4(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_prop_4(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_prop_4(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_prop_4(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_prop_4(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_prop_4(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_prop_5(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_prop_5(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_prop_5(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_prop_5(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_prop_5(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_prop_5(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_prop_6(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_prop_6(obj:
                                                              *const lv_obj_t,
                                                          part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_prop_6(obj as *const lv_obj_t,
                                                       part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_prop_6(obj: *mut lv_obj_t, part: u8,
                                                 state: lv_state_t,
                                                 value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_prop_6(obj:
                                                                    *mut lv_obj_t,
                                                                part: u8,
                                                                state:
                                                                    lv_state_t,
                                                                value:
                                                                    lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_prop_6(obj as *mut lv_obj_t,
                                                         part as u8,
                                                         state as lv_state_t,
                                                         value as
                                                             lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_transition_path(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<*mut lv_anim_path_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_transition_path(obj: *const lv_obj_t,
                                                        part: u8)
                -> *mut lv_anim_path_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_transition_path(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_transition_path(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: *mut lv_anim_path_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_transition_path(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  *mut lv_anim_path_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_transition_path(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as
                                                           *mut lv_anim_path_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_scale_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_scale_width(obj: *const lv_obj_t,
                                                    part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_scale_width(obj as *const lv_obj_t,
                                                 part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_scale_width(obj: *mut lv_obj_t, part: u8,
                                           state: lv_state_t,
                                           value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_scale_width(obj: *mut lv_obj_t,
                                                          part: u8,
                                                          state: lv_state_t,
                                                          value:
                                                              lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_scale_width(obj as *mut lv_obj_t,
                                                   part as u8,
                                                   state as lv_state_t,
                                                   value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_scale_border_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_scale_border_width(obj:
                                                               *const lv_obj_t,
                                                           part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_scale_border_width(obj as
                                                            *const lv_obj_t,
                                                        part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_scale_border_width(obj: *mut lv_obj_t,
                                                  part: u8, state: lv_state_t,
                                                  value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_scale_border_width(obj:
                                                                     *mut lv_obj_t,
                                                                 part: u8,
                                                                 state:
                                                                     lv_state_t,
                                                                 value:
                                                                     lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_scale_border_width(obj as
                                                              *mut lv_obj_t,
                                                          part as u8,
                                                          state as lv_state_t,
                                                          value as
                                                              lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_scale_end_border_width(obj: *const lv_obj_t,
                                                part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_scale_end_border_width(obj:
                                                                   *const lv_obj_t,
                                                               part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_scale_end_border_width(obj as
                                                                *const lv_obj_t,
                                                            part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_scale_end_border_width(obj: *mut lv_obj_t,
                                                      part: u8,
                                                      state: lv_state_t,
                                                      value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_scale_end_border_width(obj:
                                                                         *mut lv_obj_t,
                                                                     part: u8,
                                                                     state:
                                                                         lv_state_t,
                                                                     value:
                                                                         lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_scale_end_border_width(obj as
                                                                  *mut lv_obj_t,
                                                              part as u8,
                                                              state as
                                                                  lv_state_t,
                                                              value as
                                                                  lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_scale_end_line_width(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_style_int_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_scale_end_line_width(obj:
                                                                 *const lv_obj_t,
                                                             part: u8)
                -> lv_style_int_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_scale_end_line_width(obj as
                                                              *const lv_obj_t,
                                                          part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_scale_end_line_width(obj: *mut lv_obj_t,
                                                    part: u8,
                                                    state: lv_state_t,
                                                    value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_scale_end_line_width(obj:
                                                                       *mut lv_obj_t,
                                                                   part: u8,
                                                                   state:
                                                                       lv_state_t,
                                                                   value:
                                                                       lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_scale_end_line_width(obj as
                                                                *mut lv_obj_t,
                                                            part as u8,
                                                            state as
                                                                lv_state_t,
                                                            value as
                                                                lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_scale_grad_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_scale_grad_color(obj: *const lv_obj_t,
                                                         part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_scale_grad_color(obj as *const lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_scale_grad_color(obj: *mut lv_obj_t, part: u8,
                                                state: lv_state_t,
                                                value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_scale_grad_color(obj:
                                                                   *mut lv_obj_t,
                                                               part: u8,
                                                               state:
                                                                   lv_state_t,
                                                               value:
                                                                   lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_scale_grad_color(obj as *mut lv_obj_t,
                                                        part as u8,
                                                        state as lv_state_t,
                                                        value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn get_style_scale_end_color(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_style_scale_end_color(obj: *const lv_obj_t,
                                                        part: u8)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_style_scale_end_color(obj as *const lv_obj_t,
                                                     part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn set_style_local_scale_end_color(obj: *mut lv_obj_t, part: u8,
                                               state: lv_state_t,
                                               value: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_scale_end_color(obj:
                                                                  *mut lv_obj_t,
                                                              part: u8,
                                                              state:
                                                                  lv_state_t,
                                                              value:
                                                                  lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_scale_end_color(obj as *mut lv_obj_t,
                                                       part as u8,
                                                       state as lv_state_t,
                                                       value as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_pad_all(obj: *mut lv_obj_t, part: u8,
                                       state: lv_state_t,
                                       value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_all(obj: *mut lv_obj_t,
                                                      part: u8,
                                                      state: lv_state_t,
                                                      value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_all(obj as *mut lv_obj_t,
                                               part as u8,
                                               state as lv_state_t,
                                               value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_pad_hor(obj: *mut lv_obj_t, part: u8,
                                       state: lv_state_t,
                                       value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_hor(obj: *mut lv_obj_t,
                                                      part: u8,
                                                      state: lv_state_t,
                                                      value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_hor(obj as *mut lv_obj_t,
                                               part as u8,
                                               state as lv_state_t,
                                               value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_pad_ver(obj: *mut lv_obj_t, part: u8,
                                       state: lv_state_t,
                                       value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_pad_ver(obj: *mut lv_obj_t,
                                                      part: u8,
                                                      state: lv_state_t,
                                                      value: lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_pad_ver(obj as *mut lv_obj_t,
                                               part as u8,
                                               state as lv_state_t,
                                               value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_margin_all(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_all(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_all(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_margin_hor(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_hor(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_hor(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn set_style_local_margin_ver(obj: *mut lv_obj_t, part: u8,
                                          state: lv_state_t,
                                          value: lv_style_int_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_set_style_local_margin_ver(obj: *mut lv_obj_t,
                                                         part: u8,
                                                         state: lv_state_t,
                                                         value:
                                                             lv_style_int_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_style_local_margin_ver(obj as *mut lv_obj_t,
                                                  part as u8,
                                                  state as lv_state_t,
                                                  value as lv_style_int_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the hidden attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the object is hidden"]
        pub fn get_hidden(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the hidden attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the object is hidden"]
                pub fn lv_obj_get_hidden(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_hidden(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether advanced hit-testing is enabled on an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: advanced hit-testing is enabled"]
        pub fn get_adv_hittest(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get whether advanced hit-testing is enabled on an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: advanced hit-testing is enabled"]
                pub fn lv_obj_get_adv_hittest(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_adv_hittest(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the click enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the object is clickable"]
        pub fn get_click(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the click enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the object is clickable"]
                pub fn lv_obj_get_click(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_click(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the top enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the auto top feature is enabled"]
        pub fn get_top(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the top enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the auto top feature is enabled"]
                pub fn lv_obj_get_top(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_top(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: the object is draggable"]
        pub fn get_drag(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: the object is draggable"]
                pub fn lv_obj_get_drag(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_drag(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the directions an object can be dragged"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return: bitwise OR of allowed directions an object can be dragged in"]
        pub fn get_drag_dir(obj: *const lv_obj_t)
         -> MynewtResult<lv_drag_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the directions an object can be dragged"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: bitwise OR of allowed directions an object can be dragged in"]
                pub fn lv_obj_get_drag_dir(obj: *const lv_obj_t)
                -> lv_drag_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_drag_dir(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag throw enable attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: drag throw is enabled"]
        pub fn get_drag_throw(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag throw enable attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: drag throw is enabled"]
                pub fn lv_obj_get_drag_throw(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_drag_throw(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag parent attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: drag parent is enabled"]
        pub fn get_drag_parent(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag parent attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: drag parent is enabled"]
                pub fn lv_obj_get_drag_parent(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_drag_parent(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the focus parent attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: focus parent is enabled"]
        pub fn get_focus_parent(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the focus parent attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: focus parent is enabled"]
                pub fn lv_obj_get_focus_parent(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_focus_parent(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the drag parent attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: drag parent is enabled"]
        pub fn get_parent_event(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the drag parent attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: drag parent is enabled"]
                pub fn lv_obj_get_parent_event(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_parent_event(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the gesture parent attribute of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: true: gesture parent is enabled"]
        pub fn get_gesture_parent(obj: *const lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the gesture parent attribute of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: true: gesture parent is enabled"]
                pub fn lv_obj_get_gesture_parent(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_gesture_parent(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn get_base_dir(obj: *const lv_obj_t)
         -> MynewtResult<lv_bidi_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_base_dir(obj: *const lv_obj_t)
                -> lv_bidi_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_base_dir(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the protect field of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: protect field ('OR'ed values of `lv_protect_t`)"]
        pub fn get_protect(obj: *const lv_obj_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the protect field of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: protect field ('OR'ed values of `lv_protect_t`)"]
                pub fn lv_obj_get_protect(obj: *const lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_protect(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check at least one bit of a given protect bitfield is set"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`prot`__: protect bits to test ('OR'ed values of `lv_protect_t`)"]
        #[doc =
          " Return: false: none of the given bits are set, true: at least one bit is set"]
        pub fn is_protected(obj: *const lv_obj_t, prot: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check at least one bit of a given protect bitfield is set"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`prot`__: protect bits to test ('OR'ed values of `lv_protect_t`)"]
                #[doc =
                  " Return: false: none of the given bits are set, true: at least one bit is set"]
                pub fn lv_obj_is_protected(obj: *const lv_obj_t, prot: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_is_protected(obj as *const lv_obj_t, prot as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn get_state(obj: *const lv_obj_t, part: u8)
         -> MynewtResult<lv_state_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_get_state(obj: *const lv_obj_t, part: u8)
                -> lv_state_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_state(obj as *const lv_obj_t, part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the signal function of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the signal function"]
        pub fn get_signal_cb(obj: *const lv_obj_t)
         -> MynewtResult<lv_signal_cb_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the signal function of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the signal function"]
                pub fn lv_obj_get_signal_cb(obj: *const lv_obj_t)
                -> lv_signal_cb_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_signal_cb(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the design function of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the design function"]
        pub fn get_design_cb(obj: *const lv_obj_t)
         -> MynewtResult<lv_design_cb_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the design function of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the design function"]
                pub fn lv_obj_get_design_cb(obj: *const lv_obj_t)
                -> lv_design_cb_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_design_cb(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the event function of an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the event function"]
        pub fn get_event_cb(obj: *const lv_obj_t)
         -> MynewtResult<lv_event_cb_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the event function of an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the event function"]
                pub fn lv_obj_get_event_cb(obj: *const lv_obj_t)
                -> lv_event_cb_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_event_cb(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Check if a given screen-space point is on an object's coordinates."]
        #[doc = ""]
        #[doc =
          " This method is intended to be used mainly by advanced hit testing algorithms to check"]
        #[doc =
          " whether the point is even within the object (as an optimization)."]
        #[doc = " - __`obj`__: object to check"]
        #[doc = " - __`point`__: screen-space point"]
        pub fn is_point_on_coords(obj: *mut lv_obj_t,
                                  point: *const lv_point_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check if a given screen-space point is on an object's coordinates."]
                #[doc = ""]
                #[doc =
                  " This method is intended to be used mainly by advanced hit testing algorithms to check"]
                #[doc =
                  " whether the point is even within the object (as an optimization)."]
                #[doc = " - __`obj`__: object to check"]
                #[doc = " - __`point`__: screen-space point"]
                pub fn lv_obj_is_point_on_coords(obj: *mut lv_obj_t,
                                                 point: *const lv_point_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_is_point_on_coords(obj as *mut lv_obj_t,
                                              point as *const lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Hit-test an object given a particular point in screen space."]
        #[doc = " - __`obj`__: object to hit-test"]
        #[doc = " - __`point`__: screen-space point"]
        #[doc = " Return: true if the object is considered under the point"]
        pub fn hittest(obj: *mut lv_obj_t, point: *mut lv_point_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Hit-test an object given a particular point in screen space."]
                #[doc = " - __`obj`__: object to hit-test"]
                #[doc = " - __`point`__: screen-space point"]
                #[doc =
                  " Return: true if the object is considered under the point"]
                pub fn lv_obj_hittest(obj: *mut lv_obj_t,
                                      point: *mut lv_point_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_hittest(obj as *mut lv_obj_t,
                                   point as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the ext pointer"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the ext pointer but not the dynamic version"]
        #[doc = "         Use it as ext->data1, and NOT da(ext)->data1"]
        pub fn get_ext_attr(obj: *const lv_obj_t)
         -> MynewtResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the ext pointer"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: the ext pointer but not the dynamic version"]
                #[doc =
                  "         Use it as ext->data1, and NOT da(ext)->data1"]
                pub fn lv_obj_get_ext_attr(obj: *const lv_obj_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_ext_attr(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get object's and its ancestors type. Put their name in `type_buf` starting with the current type."]
        #[doc =
          " E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\""]
        #[doc = " - __`obj`__: pointer to an object which type should be get"]
        #[doc =
          " - __`buf`__: pointer to an `lv_obj_type_t` buffer to store the types"]
        pub fn get_type(obj: *const lv_obj_t, buf: *mut lv_obj_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get object's and its ancestors type. Put their name in `type_buf` starting with the current type."]
                #[doc =
                  " E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\""]
                #[doc =
                  " - __`obj`__: pointer to an object which type should be get"]
                #[doc =
                  " - __`buf`__: pointer to an `lv_obj_type_t` buffer to store the types"]
                pub fn lv_obj_get_type(obj: *const lv_obj_t,
                                       buf: *mut lv_obj_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_get_type(obj as *const lv_obj_t,
                                buf as *mut lv_obj_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the object's user data"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: user data"]
        pub fn get_user_data(obj: *const lv_obj_t)
         -> MynewtResult<lv_obj_user_data_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the object's user data"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: user data"]
                pub fn lv_obj_get_user_data(obj: *const lv_obj_t)
                -> lv_obj_user_data_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_user_data(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get a pointer to the object's user data"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: pointer to the user data"]
        pub fn get_user_data_ptr(obj: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_user_data_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get a pointer to the object's user data"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: pointer to the user data"]
                pub fn lv_obj_get_user_data_ptr(obj: *const lv_obj_t)
                -> *mut lv_obj_user_data_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_user_data_ptr(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the object's user data. The data will be copied."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`data`__: user data"]
        pub fn set_user_data(obj: *mut lv_obj_t, data: lv_obj_user_data_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the object's user data. The data will be copied."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`data`__: user data"]
                pub fn lv_obj_set_user_data(obj: *mut lv_obj_t,
                                            data: lv_obj_user_data_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_set_user_data(obj as *mut lv_obj_t,
                                     data as lv_obj_user_data_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the group of the object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " Return: the pointer to group of the object"]
        pub fn get_group(obj: *const lv_obj_t)
         -> MynewtResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the group of the object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " Return: the pointer to group of the object"]
                pub fn lv_obj_get_group(obj: *const lv_obj_t)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_get_group(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Tell whether the object is the focused object of a group or not."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " Return: true: the object is focused, false: the object is not focused or not in a group"]
        pub fn is_focused(obj: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Tell whether the object is the focused object of a group or not."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " Return: true: the object is focused, false: the object is not focused or not in a group"]
                pub fn lv_obj_is_focused(obj: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_obj_is_focused(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the really focused object by taking `focus_parent` into account."]
        #[doc = " - __`obj`__: the start object"]
        #[doc = " Return: the object to really focus"]
        pub fn get_focused_obj(obj: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the really focused object by taking `focus_parent` into account."]
                #[doc = " - __`obj`__: the start object"]
                #[doc = " Return: the object to really focus"]
                pub fn lv_obj_get_focused_obj(obj: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_focused_obj(obj as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal"]
        #[doc =
          " - __`buf`__: pointer to `lv_obj_type_t`. (`param` in the signal callback)"]
        #[doc =
          " - __`name`__: name of the object. E.g. \"lv_btn\". (Only the pointer is saved)"]
        #[doc = " Return: LV_RES_OK"]
        pub fn handle_get_type_signal(buf: *mut lv_obj_type_t, name: &Strn)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal"]
                #[doc =
                  " - __`buf`__: pointer to `lv_obj_type_t`. (`param` in the signal callback)"]
                #[doc =
                  " - __`name`__: name of the object. E.g. \"lv_btn\". (Only the pointer is saved)"]
                #[doc = " Return: LV_RES_OK"]
                pub fn lv_obj_handle_get_type_signal(buf: *mut lv_obj_type_t,
                                                     name:
                                                         *const ::cty::c_char)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            name.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_handle_get_type_signal(buf as *mut lv_obj_type_t,
                                                  name.as_ptr() as
                                                      *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Initialize a rectangle descriptor from an object's styles"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`type`__: type of style. E.g.  `LV_OBJ_PART_MAIN`, `LV_BTN_SLIDER_KOB`"]
        #[doc = " - __`draw_dsc`__: the descriptor the initialize"]
        #[doc = " __Note:__ Only the relevant fields will be set."]
        #[doc =
          " E.g. if `border width == 0` the other border properties won't be evaluated."]
        pub fn init_draw_rect_dsc(obj: *mut lv_obj_t, type_: u8,
                                  draw_dsc: *mut lv_draw_rect_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Initialize a rectangle descriptor from an object's styles"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`type`__: type of style. E.g.  `LV_OBJ_PART_MAIN`, `LV_BTN_SLIDER_KOB`"]
                #[doc = " - __`draw_dsc`__: the descriptor the initialize"]
                #[doc = " __Note:__ Only the relevant fields will be set."]
                #[doc =
                  " E.g. if `border width == 0` the other border properties won't be evaluated."]
                pub fn lv_obj_init_draw_rect_dsc(obj: *mut lv_obj_t,
                                                 type_: u8,
                                                 draw_dsc:
                                                     *mut lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_init_draw_rect_dsc(obj as *mut lv_obj_t, type_ as u8,
                                          draw_dsc as
                                              *mut lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn init_draw_label_dsc(obj: *mut lv_obj_t, type_: u8,
                                   draw_dsc: *mut lv_draw_label_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_init_draw_label_dsc(obj: *mut lv_obj_t,
                                                  type_: u8,
                                                  draw_dsc:
                                                      *mut lv_draw_label_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_init_draw_label_dsc(obj as *mut lv_obj_t, type_ as u8,
                                           draw_dsc as
                                               *mut lv_draw_label_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn init_draw_img_dsc(obj: *mut lv_obj_t, part: u8,
                                 draw_dsc: *mut lv_draw_img_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_init_draw_img_dsc(obj: *mut lv_obj_t, part: u8,
                                                draw_dsc:
                                                    *mut lv_draw_img_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_init_draw_img_dsc(obj as *mut lv_obj_t, part as u8,
                                         draw_dsc as *mut lv_draw_img_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn init_draw_line_dsc(obj: *mut lv_obj_t, part: u8,
                                  draw_dsc: *mut lv_draw_line_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_obj_init_draw_line_dsc(obj: *mut lv_obj_t, part: u8,
                                                 draw_dsc:
                                                     *mut lv_draw_line_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_init_draw_line_dsc(obj as *mut lv_obj_t, part as u8,
                                          draw_dsc as
                                              *mut lv_draw_line_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get the required extra size (around the object's part) to draw shadow, outline, value etc."]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc = " - __`part`__: part of the object"]
        pub fn get_draw_rect_ext_pad_size(obj: *mut lv_obj_t, part: u8)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the required extra size (around the object's part) to draw shadow, outline, value etc."]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc = " - __`part`__: part of the object"]
                pub fn lv_obj_get_draw_rect_ext_pad_size(obj: *mut lv_obj_t,
                                                         part: u8)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_obj_get_draw_rect_ext_pad_size(obj as *mut lv_obj_t,
                                                      part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Fade in (from transparent to fully cover) an object and all its children using an `opa_scale` animation."]
        #[doc = " - __`obj`__: the object to fade in"]
        #[doc = " - __`time`__: duration of the animation [ms]"]
        #[doc = " - __`delay`__: wait before the animation starts [ms]"]
        pub fn fade_in(obj: *mut lv_obj_t, time: u32, delay: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Fade in (from transparent to fully cover) an object and all its children using an `opa_scale` animation."]
                #[doc = " - __`obj`__: the object to fade in"]
                #[doc = " - __`time`__: duration of the animation [ms]"]
                #[doc =
                  " - __`delay`__: wait before the animation starts [ms]"]
                pub fn lv_obj_fade_in(obj: *mut lv_obj_t, time: u32,
                                      delay: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_fade_in(obj as *mut lv_obj_t, time as u32,
                               delay as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Fade out (from fully cover to transparent) an object and all its children using an `opa_scale` animation."]
        #[doc = " - __`obj`__: the object to fade in"]
        #[doc = " - __`time`__: duration of the animation [ms]"]
        #[doc = " - __`delay`__: wait before the animation starts [ms]"]
        pub fn fade_out(obj: *mut lv_obj_t, time: u32, delay: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Fade out (from fully cover to transparent) an object and all its children using an `opa_scale` animation."]
                #[doc = " - __`obj`__: the object to fade in"]
                #[doc = " - __`time`__: duration of the animation [ms]"]
                #[doc =
                  " - __`delay`__: wait before the animation starts [ms]"]
                pub fn lv_obj_fade_out(obj: *mut lv_obj_t, time: u32,
                                       delay: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_obj_fade_out(obj as *mut lv_obj_t, time as u32,
                                delay as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Core Refr API `lv_refr`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod refr {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub type lv_coord_t = i16;
        pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub const LV_ALIGN_CENTER: lv_align_t = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
        pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
        pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
        pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
        #[doc = " Alignments"]
        pub type _bindgen_ty_3 = u32;
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        #[repr(C)]
        pub struct lv_style_t {
            pub map: *mut u8,
        }
        impl Default for lv_style_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Tasks execute this type type of functions."]
        pub type lv_task_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_task_t {
            #[doc = "< How often the task should run"]
            pub period: u32,
            #[doc = "< Last time the task ran"]
            pub last_run: u32,
            #[doc = "< Task function"]
            pub task_cb: lv_task_cb_t,
            #[doc = "< Custom user data"]
            pub user_data: *mut ::cty::c_void,
            #[doc =
              "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
            pub repeat_count: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for _lv_task_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_task_t {
            #[inline]
            pub fn prio(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_prio(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(prio: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let prio: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(prio)
                                                    };
                                                prio as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_task_t = _lv_task_t;
        #[doc = " Structure for holding display buffer information."]
        #[repr(C)]
        pub struct lv_disp_buf_t {
            #[doc = "< First display buffer."]
            pub buf1: *mut ::cty::c_void,
            #[doc = "< Second display buffer."]
            pub buf2: *mut ::cty::c_void,
            pub buf_act: *mut ::cty::c_void,
            pub size: u32,
            pub area: lv_area_t,
            pub flushing: ::cty::c_int,
            pub flushing_last: ::cty::c_int,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_disp_buf_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_disp_buf_t {
            #[inline]
            pub fn last_area(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_area(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn last_part(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_last_part(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(last_area: u32, last_part: u32)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let last_area: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_area)
                                                    };
                                                last_area as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let last_part: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(last_part)
                                                    };
                                                last_part as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Display Driver structure to be registered by HAL"]
        #[repr(C)]
        pub struct _disp_drv_t {
            #[doc = "< Horizontal resolution."]
            pub hor_res: lv_coord_t,
            #[doc = "< Vertical resolution."]
            pub ver_res: lv_coord_t,
            #[doc =
              " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
            #[doc =
              " LVGL will use this buffer(s) to draw the screens contents"]
            pub buffer: *mut lv_disp_buf_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc =
              " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
            #[doc = " called when finished"]
            pub flush_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                          *mut _disp_drv_t,
                                                                      area:
                                                                          *const lv_area_t,
                                                                      color_p:
                                                                          *mut lv_color_t)>,
            #[doc =
              " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
            #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
            pub rounder_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        area:
                                                                            *mut lv_area_t)>,
            #[doc =
              " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
            #[doc =
              " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
            #[doc =
              " __Note:__ Much slower then drawing with supported color formats."]
            pub set_px_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                           *mut _disp_drv_t,
                                                                       buf:
                                                                           *mut u8,
                                                                       buf_w:
                                                                           lv_coord_t,
                                                                       x:
                                                                           lv_coord_t,
                                                                       y:
                                                                           lv_coord_t,
                                                                       color:
                                                                           lv_color_t,
                                                                       opa:
                                                                           lv_opa_t)>,
            #[doc =
              " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
            #[doc = " number of flushed pixels"]
            pub monitor_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                            *mut _disp_drv_t,
                                                                        time:
                                                                            u32,
                                                                        px:
                                                                            u32)>,
            #[doc =
              " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
            #[doc = " For example flushing or GPU"]
            #[doc =
              " User can execute very simple tasks here or yield the task"]
            pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                         *mut _disp_drv_t)>,
            #[doc =
              " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
            pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                                 *mut _disp_drv_t)>,
            #[doc = " OPTIONAL: called to wait while the gpu is working"]
            pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv:
                                                                             *mut _disp_drv_t)>,
            #[doc = " On CHROMA_KEYED images this color will be transparent."]
            #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
            pub color_chroma_key: lv_color_t,
            #[doc = "< Custom display driver user data"]
            pub user_data: lv_disp_drv_user_data_t,
        }
        impl Default for _disp_drv_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_drv_t {
            #[inline]
            pub fn antialiasing(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_antialiasing(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn rotated(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_rotated(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dpi(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_dpi(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialiasing: u32, rotated: u32, dpi: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialiasing: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialiasing)
                                                    };
                                                antialiasing as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let rotated: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(rotated)
                                                    };
                                                rotated as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 10u8,
                                            {
                                                let dpi: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(dpi)
                                                    };
                                                dpi as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_drv_t = _disp_drv_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _disp_t {
            pub driver: lv_disp_drv_t,
            pub refr_task: *mut lv_task_t,
            #[doc = " Screens of the display"]
            pub scr_ll: lv_ll_t,
            #[doc = "< Currently active screen on this display"]
            pub act_scr: *mut _lv_obj_t,
            #[doc = "< Previous screen. Used during screen animations"]
            pub prev_scr: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_top"]
            pub top_layer: *mut _lv_obj_t,
            #[doc = "< @see lv_disp_get_layer_sys"]
            pub sys_layer: *mut _lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc = "< Default display color when screens are transparent"]
            pub bg_color: lv_color_t,
            #[doc = "< An image source to display as wallpaper"]
            pub bg_img: *const ::cty::c_void,
            #[doc = "<Opacity of the background color or wallpaper"]
            pub bg_opa: lv_opa_t,
            #[doc = " Invalidated (marked to redraw) areas"]
            pub inv_areas: [lv_area_t; 32usize],
            pub inv_area_joined: [u8; 32usize],
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
            #[doc = "< Last time there was activity on this display"]
            pub last_activity_time: u32,
        }
        impl Default for _disp_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _disp_t {
            #[inline]
            pub fn del_prev(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_del_prev(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(del_prev: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let del_prev: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(del_prev)
                                                    };
                                                del_prev as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn inv_p(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_inv_p(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 10u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(inv_p: u32)
             -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 10u8,
                                            {
                                                let inv_p: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(inv_p)
                                                    };
                                                inv_p as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_disp_t = _disp_t;
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct _lv_obj_t {
            #[doc = "< Pointer to the parent object"]
            pub parent: *mut _lv_obj_t,
            #[doc = "< Linked list to store the children objects"]
            pub child_ll: lv_ll_t,
            #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
            pub coords: lv_area_t,
            #[doc = "< Event callback function"]
            pub event_cb: lv_event_cb_t,
            #[doc = "< Object type specific signal function"]
            pub signal_cb: lv_signal_cb_t,
            #[doc = "< Object type specific design function"]
            pub design_cb: lv_design_cb_t,
            #[doc = "< Object type specific extended data"]
            pub ext_attr: *mut ::cty::c_void,
            pub style_list: lv_style_list_t,
            #[doc = "< Extra click padding in horizontal direction"]
            pub ext_click_pad_hor: u8,
            #[doc = "< Extra click padding in vertical direction"]
            pub ext_click_pad_ver: u8,
            #[doc = "< EXTend the size in every direction for drawing."]
            pub ext_draw_pad: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            #[doc = "< Automatically happening actions can be prevented."]
            #[doc = "'OR'ed values from `lv_protect_t`"]
            pub protect: u8,
            pub state: lv_state_t,
            #[doc = "< Information about the last call to ::lv_obj_align."]
            pub realign: lv_realign_t,
            #[doc = "< Custom user data for object."]
            pub user_data: lv_obj_user_data_t,
        }
        impl Default for _lv_obj_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_obj_t {
            #[inline]
            pub fn click(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_throw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_throw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn parent_event(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_parent_event(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn adv_hittest(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_adv_hittest(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn gesture_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_gesture_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn focus_parent(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_focus_parent(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_dir(&self) -> lv_drag_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn base_dir(&self) -> lv_bidi_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(click: u8, drag: u8, drag_throw: u8,
                                  drag_parent: u8, hidden: u8, top: u8,
                                  parent_event: u8, adv_hittest: u8,
                                  gesture_parent: u8, focus_parent: u8,
                                  drag_dir: lv_drag_dir_t,
                                  base_dir: lv_bidi_dir_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let click: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click)
                                                    };
                                                click as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag)
                                                    };
                                                drag as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let drag_throw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_throw)
                                                    };
                                                drag_throw as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let drag_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_parent)
                                                    };
                                                drag_parent as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top)
                                                    };
                                                top as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let parent_event: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(parent_event)
                                                    };
                                                parent_event as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let adv_hittest: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(adv_hittest)
                                                    };
                                                adv_hittest as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let gesture_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(gesture_parent)
                                                    };
                                                gesture_parent as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let focus_parent: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(focus_parent)
                                                    };
                                                focus_parent as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 3u8,
                                            {
                                                let drag_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_dir)
                                                    };
                                                drag_dir as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 2u8,
                                            {
                                                let base_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(base_dir)
                                                    };
                                                base_dir as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Redraw the invalidated areas now."]
        #[doc =
          " Normally the redrawing is periodically executed in `lv_task_handler` but a long blocking process"]
        #[doc =
          " can prevent the call of `lv_task_handler`. In this case if the the GUI is updated in the process"]
        #[doc =
          " (e.g. progress bar) this function can be called when the screen should be updated."]
        #[doc =
          " - __`disp`__: pointer to display to refresh. NULL to refresh all displays."]
        pub fn now(disp: *mut lv_disp_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Redraw the invalidated areas now."]
                #[doc =
                  " Normally the redrawing is periodically executed in `lv_task_handler` but a long blocking process"]
                #[doc =
                  " can prevent the call of `lv_task_handler`. In this case if the the GUI is updated in the process"]
                #[doc =
                  " (e.g. progress bar) this function can be called when the screen should be updated."]
                #[doc =
                  " - __`disp`__: pointer to display to refresh. NULL to refresh all displays."]
                pub fn lv_refr_now(disp: *mut lv_disp_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_refr_now(disp as *mut lv_disp_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Core Style API `lv_style`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod style {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_STYLE_ID_MASK: u32 = 255;
        pub const LV_STYLE_ATTR_NONE: u32 = 0;
        pub const LV_STYLE_ATTR_INHERIT: u32 = 128;
        pub const LV_STYLE_TRANS_NUM_MAX: u32 = 6;
        pub const LV_STYLE_PROP_ALL: u32 = 255;
        pub const LV_STYLE_ID_VALUE: u32 = 0;
        pub const LV_STYLE_ID_COLOR: u32 = 9;
        pub const LV_STYLE_ID_OPA: u32 = 12;
        pub const LV_STYLE_ID_PTR: u32 = 14;
        pub const LV_STYLE_STATE_POS: u32 = 8;
        pub const LV_STYLE_STATE_MASK: u32 = 32512;
        pub const LV_STYLE_INHERIT_MASK: u32 = 32768;
        pub const LV_ALIGN_CENTER: lv_align_t = 0;
        pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
        pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
        pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
        pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
        pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
        pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
        pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
        pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
        pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
        pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
        pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
        pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
        pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
        pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
        pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
        pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
        pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
        pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
        pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
        pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
        #[doc = " Alignments"]
        pub type _bindgen_ty_3 = u32;
        pub type lv_align_t = u8;
        pub type lv_style_attr_t = u8;
        pub const LV_STYLE_RADIUS: _bindgen_ty_14 = 1;
        pub const LV_STYLE_CLIP_CORNER: _bindgen_ty_14 = 2;
        pub const LV_STYLE_SIZE: _bindgen_ty_14 = 3;
        pub const LV_STYLE_TRANSFORM_WIDTH: _bindgen_ty_14 = 4;
        pub const LV_STYLE_TRANSFORM_HEIGHT: _bindgen_ty_14 = 5;
        pub const LV_STYLE_TRANSFORM_ANGLE: _bindgen_ty_14 = 6;
        pub const LV_STYLE_TRANSFORM_ZOOM: _bindgen_ty_14 = 7;
        pub const LV_STYLE_OPA_SCALE: _bindgen_ty_14 = 32780;
        pub const LV_STYLE_PAD_TOP: _bindgen_ty_14 = 16;
        pub const LV_STYLE_PAD_BOTTOM: _bindgen_ty_14 = 17;
        pub const LV_STYLE_PAD_LEFT: _bindgen_ty_14 = 18;
        pub const LV_STYLE_PAD_RIGHT: _bindgen_ty_14 = 19;
        pub const LV_STYLE_PAD_INNER: _bindgen_ty_14 = 20;
        pub const LV_STYLE_MARGIN_TOP: _bindgen_ty_14 = 21;
        pub const LV_STYLE_MARGIN_BOTTOM: _bindgen_ty_14 = 22;
        pub const LV_STYLE_MARGIN_LEFT: _bindgen_ty_14 = 23;
        pub const LV_STYLE_MARGIN_RIGHT: _bindgen_ty_14 = 24;
        pub const LV_STYLE_BG_BLEND_MODE: _bindgen_ty_14 = 32;
        pub const LV_STYLE_BG_MAIN_STOP: _bindgen_ty_14 = 33;
        pub const LV_STYLE_BG_GRAD_STOP: _bindgen_ty_14 = 34;
        pub const LV_STYLE_BG_GRAD_DIR: _bindgen_ty_14 = 35;
        pub const LV_STYLE_BG_COLOR: _bindgen_ty_14 = 41;
        pub const LV_STYLE_BG_GRAD_COLOR: _bindgen_ty_14 = 42;
        pub const LV_STYLE_BG_OPA: _bindgen_ty_14 = 44;
        pub const LV_STYLE_BORDER_WIDTH: _bindgen_ty_14 = 48;
        pub const LV_STYLE_BORDER_SIDE: _bindgen_ty_14 = 49;
        pub const LV_STYLE_BORDER_BLEND_MODE: _bindgen_ty_14 = 50;
        pub const LV_STYLE_BORDER_POST: _bindgen_ty_14 = 51;
        pub const LV_STYLE_BORDER_COLOR: _bindgen_ty_14 = 57;
        pub const LV_STYLE_BORDER_OPA: _bindgen_ty_14 = 60;
        pub const LV_STYLE_OUTLINE_WIDTH: _bindgen_ty_14 = 64;
        pub const LV_STYLE_OUTLINE_PAD: _bindgen_ty_14 = 65;
        pub const LV_STYLE_OUTLINE_BLEND_MODE: _bindgen_ty_14 = 66;
        pub const LV_STYLE_OUTLINE_COLOR: _bindgen_ty_14 = 73;
        pub const LV_STYLE_OUTLINE_OPA: _bindgen_ty_14 = 76;
        pub const LV_STYLE_SHADOW_WIDTH: _bindgen_ty_14 = 80;
        pub const LV_STYLE_SHADOW_OFS_X: _bindgen_ty_14 = 81;
        pub const LV_STYLE_SHADOW_OFS_Y: _bindgen_ty_14 = 82;
        pub const LV_STYLE_SHADOW_SPREAD: _bindgen_ty_14 = 83;
        pub const LV_STYLE_SHADOW_BLEND_MODE: _bindgen_ty_14 = 84;
        pub const LV_STYLE_SHADOW_COLOR: _bindgen_ty_14 = 89;
        pub const LV_STYLE_SHADOW_OPA: _bindgen_ty_14 = 92;
        pub const LV_STYLE_PATTERN_BLEND_MODE: _bindgen_ty_14 = 96;
        pub const LV_STYLE_PATTERN_REPEAT: _bindgen_ty_14 = 97;
        pub const LV_STYLE_PATTERN_RECOLOR: _bindgen_ty_14 = 105;
        pub const LV_STYLE_PATTERN_OPA: _bindgen_ty_14 = 108;
        pub const LV_STYLE_PATTERN_RECOLOR_OPA: _bindgen_ty_14 = 109;
        pub const LV_STYLE_PATTERN_IMAGE: _bindgen_ty_14 = 110;
        pub const LV_STYLE_VALUE_LETTER_SPACE: _bindgen_ty_14 = 112;
        pub const LV_STYLE_VALUE_LINE_SPACE: _bindgen_ty_14 = 113;
        pub const LV_STYLE_VALUE_BLEND_MODE: _bindgen_ty_14 = 114;
        pub const LV_STYLE_VALUE_OFS_X: _bindgen_ty_14 = 115;
        pub const LV_STYLE_VALUE_OFS_Y: _bindgen_ty_14 = 116;
        pub const LV_STYLE_VALUE_ALIGN: _bindgen_ty_14 = 117;
        pub const LV_STYLE_VALUE_COLOR: _bindgen_ty_14 = 121;
        pub const LV_STYLE_VALUE_OPA: _bindgen_ty_14 = 124;
        pub const LV_STYLE_VALUE_FONT: _bindgen_ty_14 = 126;
        pub const LV_STYLE_VALUE_STR: _bindgen_ty_14 = 127;
        pub const LV_STYLE_TEXT_LETTER_SPACE: _bindgen_ty_14 = 32896;
        pub const LV_STYLE_TEXT_LINE_SPACE: _bindgen_ty_14 = 32897;
        pub const LV_STYLE_TEXT_DECOR: _bindgen_ty_14 = 32898;
        pub const LV_STYLE_TEXT_BLEND_MODE: _bindgen_ty_14 = 32899;
        pub const LV_STYLE_TEXT_COLOR: _bindgen_ty_14 = 32905;
        pub const LV_STYLE_TEXT_SEL_COLOR: _bindgen_ty_14 = 32906;
        pub const LV_STYLE_TEXT_OPA: _bindgen_ty_14 = 32908;
        pub const LV_STYLE_TEXT_FONT: _bindgen_ty_14 = 32910;
        pub const LV_STYLE_LINE_WIDTH: _bindgen_ty_14 = 144;
        pub const LV_STYLE_LINE_BLEND_MODE: _bindgen_ty_14 = 145;
        pub const LV_STYLE_LINE_DASH_WIDTH: _bindgen_ty_14 = 146;
        pub const LV_STYLE_LINE_DASH_GAP: _bindgen_ty_14 = 147;
        pub const LV_STYLE_LINE_ROUNDED: _bindgen_ty_14 = 148;
        pub const LV_STYLE_LINE_COLOR: _bindgen_ty_14 = 153;
        pub const LV_STYLE_LINE_OPA: _bindgen_ty_14 = 156;
        pub const LV_STYLE_IMAGE_BLEND_MODE: _bindgen_ty_14 = 32928;
        pub const LV_STYLE_IMAGE_RECOLOR: _bindgen_ty_14 = 32937;
        pub const LV_STYLE_IMAGE_OPA: _bindgen_ty_14 = 32940;
        pub const LV_STYLE_IMAGE_RECOLOR_OPA: _bindgen_ty_14 = 32941;
        pub const LV_STYLE_TRANSITION_TIME: _bindgen_ty_14 = 176;
        pub const LV_STYLE_TRANSITION_DELAY: _bindgen_ty_14 = 177;
        pub const LV_STYLE_TRANSITION_PROP_1: _bindgen_ty_14 = 178;
        pub const LV_STYLE_TRANSITION_PROP_2: _bindgen_ty_14 = 179;
        pub const LV_STYLE_TRANSITION_PROP_3: _bindgen_ty_14 = 180;
        pub const LV_STYLE_TRANSITION_PROP_4: _bindgen_ty_14 = 181;
        pub const LV_STYLE_TRANSITION_PROP_5: _bindgen_ty_14 = 182;
        pub const LV_STYLE_TRANSITION_PROP_6: _bindgen_ty_14 = 183;
        pub const LV_STYLE_TRANSITION_PATH: _bindgen_ty_14 = 190;
        pub const LV_STYLE_SCALE_WIDTH: _bindgen_ty_14 = 192;
        pub const LV_STYLE_SCALE_BORDER_WIDTH: _bindgen_ty_14 = 193;
        pub const LV_STYLE_SCALE_END_BORDER_WIDTH: _bindgen_ty_14 = 194;
        pub const LV_STYLE_SCALE_END_LINE_WIDTH: _bindgen_ty_14 = 195;
        pub const LV_STYLE_SCALE_GRAD_COLOR: _bindgen_ty_14 = 201;
        pub const LV_STYLE_SCALE_END_COLOR: _bindgen_ty_14 = 202;
        pub type _bindgen_ty_14 = u32;
        pub type lv_style_property_t = u16;
        pub type lv_style_state_t = u16;
        #[repr(C)]
        pub struct lv_style_t {
            pub map: *mut u8,
        }
        impl Default for lv_style_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_style_int_t = i16;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Initialize a style"]
        #[doc = " - __`style`__: pointer to a style to initialize"]
        pub fn style_init(style: *mut lv_style_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a style"]
                #[doc = " - __`style`__: pointer to a style to initialize"]
                pub fn lv_style_init(style: *mut lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_init(style as *mut lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Copy a style with all its properties"]
        #[doc =
          " - __`style_dest`__: pointer to the destination style. (Should be initialized with `lv_style_init()`)"]
        #[doc = " - __`style_src`__: pointer to the source (to copy )style"]
        pub fn style_copy(style_dest: *mut lv_style_t,
                          style_src: *const lv_style_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy a style with all its properties"]
                #[doc =
                  " - __`style_dest`__: pointer to the destination style. (Should be initialized with `lv_style_init()`)"]
                #[doc =
                  " - __`style_src`__: pointer to the source (to copy )style"]
                pub fn lv_style_copy(style_dest: *mut lv_style_t,
                                     style_src: *const lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_copy(style_dest as *mut lv_style_t,
                              style_src as *const lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize a style list"]
        #[doc = " - __`list`__: a style list to initialize"]
        pub fn style_list_init(list: *mut lv_style_list_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a style list"]
                #[doc = " - __`list`__: a style list to initialize"]
                pub fn lv_style_list_init(list: *mut lv_style_list_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_list_init(list as *mut lv_style_list_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Copy a style list with all its styles and local style properties"]
        #[doc =
          " - __`list_dest`__: pointer to the destination style list. (should be initialized with `lv_style_list_init()`)"]
        #[doc =
          " - __`list_src`__: pointer to the source (to copy) style list."]
        pub fn style_list_copy(list_dest: *mut lv_style_list_t,
                               list_src: *const lv_style_list_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Copy a style list with all its styles and local style properties"]
                #[doc =
                  " - __`list_dest`__: pointer to the destination style list. (should be initialized with `lv_style_list_init()`)"]
                #[doc =
                  " - __`list_src`__: pointer to the source (to copy) style list."]
                pub fn lv_style_list_copy(list_dest: *mut lv_style_list_t,
                                          list_src: *const lv_style_list_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_list_copy(list_dest as *mut lv_style_list_t,
                                   list_src as *const lv_style_list_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn style_list_get_style(list: *mut lv_style_list_t, id: u8)
         -> MynewtResult<*mut lv_style_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_style_list_get_style(list: *mut lv_style_list_t,
                                               id: u8)
                -> *mut lv_style_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_style_list_get_style(list as *mut lv_style_list_t,
                                            id as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Clear all properties from a style and all allocated memories."]
        #[doc = " - __`style`__: pointer to a style"]
        pub fn style_reset(style: *mut lv_style_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Clear all properties from a style and all allocated memories."]
                #[doc = " - __`style`__: pointer to a style"]
                pub fn lv_style_reset(style: *mut lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_style_reset(style as *mut lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Remove a property from a style"]
        #[doc = " - __`style`__: pointer to a style"]
        #[doc = " - __`prop`__:  a style property ORed with a state."]
        #[doc =
          " E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`"]
        #[doc =
          " Return: true: the property was found and removed; false: the property wasn't found"]
        pub fn style_remove_prop(style: *mut lv_style_t,
                                 prop: lv_style_property_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove a property from a style"]
                #[doc = " - __`style`__: pointer to a style"]
                #[doc = " - __`prop`__:  a style property ORed with a state."]
                #[doc =
                  " E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`"]
                #[doc =
                  " Return: true: the property was found and removed; false: the property wasn't found"]
                pub fn lv_style_remove_prop(style: *mut lv_style_t,
                                            prop: lv_style_property_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_style_remove_prop(style as *mut lv_style_t,
                                         prop as lv_style_property_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the local style of a style list"]
        #[doc =
          " - __`list`__: pointer to a style list where the local property should be set"]
        #[doc = " Return: pointer to the local style if exists else `NULL`."]
        pub fn style_list_get_local_style(list: *mut lv_style_list_t)
         -> MynewtResult<*mut lv_style_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the local style of a style list"]
                #[doc =
                  " - __`list`__: pointer to a style list where the local property should be set"]
                #[doc =
                  " Return: pointer to the local style if exists else `NULL`."]
                pub fn lv_style_list_get_local_style(list:
                                                         *mut lv_style_list_t)
                -> *mut lv_style_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_style_list_get_local_style(list as
                                                      *mut lv_style_list_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
}
#[allow(unused_imports)]
pub mod draw {
    //! LVGL Draw API for Rust
    #[cfg(feature = "mynewt_os")]
    use mynewt::{result::*, Out, Ptr, Strn};
    use crate::{core::{obj::{_lv_obj_t, lv_obj_t, lv_style_t}}};
    /// Contains Rust bindings for LVGL Draw Widget API `lv_draw`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod draw {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_DRAW_LABEL_NO_TXT_SEL: u32 = 65535;
        pub type lv_coord_t = i16;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u16,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u16,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i16,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i16,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: lv_coord_t,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Distance between the top of the underline and base line (< 0 means below the base line)"]
            pub underline_position: i8,
            #[doc = "< Thickness of the underline"]
            pub underline_thickness: i8,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_sqrt_res_t {
            pub i: u16,
            pub f: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_sqrt_res_t {
            #[inline]
            fn default() -> lv_sqrt_res_t {
                lv_sqrt_res_t{i: ::core::default::Default::default(),
                              f: ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        pub const LV_DRAW_MASK_RES_TRANSP: _bindgen_ty_7 = 0;
        pub const LV_DRAW_MASK_RES_FULL_COVER: _bindgen_ty_7 = 1;
        pub const LV_DRAW_MASK_RES_CHANGED: _bindgen_ty_7 = 2;
        pub const LV_DRAW_MASK_RES_UNKNOWN: _bindgen_ty_7 = 3;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_7 = u32;
        pub type lv_draw_mask_res_t = u8;
        pub const LV_DRAW_MASK_TYPE_LINE: _bindgen_ty_8 = 0;
        pub const LV_DRAW_MASK_TYPE_ANGLE: _bindgen_ty_8 = 1;
        pub const LV_DRAW_MASK_TYPE_RADIUS: _bindgen_ty_8 = 2;
        pub const LV_DRAW_MASK_TYPE_FADE: _bindgen_ty_8 = 3;
        pub const LV_DRAW_MASK_TYPE_MAP: _bindgen_ty_8 = 4;
        pub type _bindgen_ty_8 = u32;
        pub type lv_draw_mask_type_t = u8;
        pub const LV_DRAW_MASK_LINE_SIDE_LEFT: _bindgen_ty_9 = 0;
        pub const LV_DRAW_MASK_LINE_SIDE_RIGHT: _bindgen_ty_9 = 1;
        pub const LV_DRAW_MASK_LINE_SIDE_TOP: _bindgen_ty_9 = 2;
        pub const LV_DRAW_MASK_LINE_SIDE_BOTTOM: _bindgen_ty_9 = 3;
        pub type _bindgen_ty_9 = u32;
        #[doc = " A common callback type for every mask type."]
        #[doc = " Used internally by the library."]
        pub type lv_draw_mask_xcb_t =
         ::core::option::Option<unsafe extern "C" fn(mask_buf: *mut lv_opa_t,
                                                     abs_x: lv_coord_t,
                                                     abs_y: lv_coord_t,
                                                     len: lv_coord_t,
                                                     p: *mut ::cty::c_void)
                                    -> lv_draw_mask_res_t>;
        pub type lv_draw_mask_line_side_t = u8;
        #[repr(C)]
        pub struct lv_draw_mask_common_dsc_t {
            pub cb: lv_draw_mask_xcb_t,
            pub type_: lv_draw_mask_type_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_draw_mask_common_dsc_t {
            #[inline]
            fn default() -> lv_draw_mask_common_dsc_t {
                lv_draw_mask_common_dsc_t{cb:
                                              ::core::default::Default::default(),
                                          type_:
                                              ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_line_param_t {
            pub dsc: lv_draw_mask_common_dsc_t,
            pub cfg: lv_draw_mask_line_param_t__bindgen_ty_1,
            pub origo: lv_point_t,
            pub xy_steep: i32,
            pub yx_steep: i32,
            pub steep: i32,
            pub spx: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_draw_mask_line_param_t {
            #[inline]
            fn default() -> lv_draw_mask_line_param_t {
                lv_draw_mask_line_param_t{dsc:
                                              ::core::default::Default::default(),
                                          cfg:
                                              ::core::default::Default::default(),
                                          origo:
                                              ::core::default::Default::default(),
                                          xy_steep:
                                              ::core::default::Default::default(),
                                          yx_steep:
                                              ::core::default::Default::default(),
                                          steep:
                                              ::core::default::Default::default(),
                                          spx:
                                              ::core::default::Default::default(),
                                          _bitfield_1:
                                              ::core::default::Default::default(),
                                          __bindgen_padding_0:
                                              ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_line_param_t__bindgen_ty_1 {
            pub p1: lv_point_t,
            pub p2: lv_point_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         lv_draw_mask_line_param_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_draw_mask_line_param_t__bindgen_ty_1 {
                lv_draw_mask_line_param_t__bindgen_ty_1{p1:
                                                            ::core::default::Default::default(),
                                                        p2:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),
                                                        __bindgen_padding_0:
                                                            ::core::default::Default::default(),}
            }
        }
        impl lv_draw_mask_line_param_t__bindgen_ty_1 {
            #[inline]
            pub fn side(&self) -> lv_draw_mask_line_side_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_side(&mut self, val: lv_draw_mask_line_side_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(side: lv_draw_mask_line_side_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let side: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(side)
                                                    };
                                                side as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl lv_draw_mask_line_param_t {
            #[inline]
            pub fn flat(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_flat(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn inv(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_inv(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(flat: u8, inv: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let flat: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(flat)
                                                    };
                                                flat as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let inv: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(inv)
                                                    };
                                                inv as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_angle_param_t {
            pub dsc: lv_draw_mask_common_dsc_t,
            pub cfg: lv_draw_mask_angle_param_t__bindgen_ty_1,
            pub start_line: lv_draw_mask_line_param_t,
            pub end_line: lv_draw_mask_line_param_t,
            pub delta_deg: u16,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_draw_mask_angle_param_t {
            #[inline]
            fn default() -> lv_draw_mask_angle_param_t {
                lv_draw_mask_angle_param_t{dsc:
                                               ::core::default::Default::default(),
                                           cfg:
                                               ::core::default::Default::default(),
                                           start_line:
                                               ::core::default::Default::default(),
                                           end_line:
                                               ::core::default::Default::default(),
                                           delta_deg:
                                               ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_angle_param_t__bindgen_ty_1 {
            pub vertex_p: lv_point_t,
            pub start_angle: lv_coord_t,
            pub end_angle: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         lv_draw_mask_angle_param_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_draw_mask_angle_param_t__bindgen_ty_1 {
                lv_draw_mask_angle_param_t__bindgen_ty_1{vertex_p:
                                                             ::core::default::Default::default(),
                                                         start_angle:
                                                             ::core::default::Default::default(),
                                                         end_angle:
                                                             ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_radius_param_t {
            pub dsc: lv_draw_mask_common_dsc_t,
            pub cfg: lv_draw_mask_radius_param_t__bindgen_ty_1,
            pub y_prev: i32,
            pub y_prev_x: lv_sqrt_res_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_draw_mask_radius_param_t {
            #[inline]
            fn default() -> lv_draw_mask_radius_param_t {
                lv_draw_mask_radius_param_t{dsc:
                                                ::core::default::Default::default(),
                                            cfg:
                                                ::core::default::Default::default(),
                                            y_prev:
                                                ::core::default::Default::default(),
                                            y_prev_x:
                                                ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_radius_param_t__bindgen_ty_1 {
            pub rect: lv_area_t,
            pub radius: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         lv_draw_mask_radius_param_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_draw_mask_radius_param_t__bindgen_ty_1 {
                lv_draw_mask_radius_param_t__bindgen_ty_1{rect:
                                                              ::core::default::Default::default(),
                                                          radius:
                                                              ::core::default::Default::default(),
                                                          _bitfield_1:
                                                              ::core::default::Default::default(),
                                                          __bindgen_padding_0:
                                                              ::core::default::Default::default(),}
            }
        }
        impl lv_draw_mask_radius_param_t__bindgen_ty_1 {
            #[inline]
            pub fn outer(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_outer(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(outer: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let outer: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(outer)
                                                    };
                                                outer as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_fade_param_t {
            pub dsc: lv_draw_mask_common_dsc_t,
            pub cfg: lv_draw_mask_fade_param_t__bindgen_ty_1,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_draw_mask_fade_param_t {
            #[inline]
            fn default() -> lv_draw_mask_fade_param_t {
                lv_draw_mask_fade_param_t{dsc:
                                              ::core::default::Default::default(),
                                          cfg:
                                              ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_draw_mask_fade_param_t__bindgen_ty_1 {
            pub coords: lv_area_t,
            pub y_top: lv_coord_t,
            pub y_bottom: lv_coord_t,
            pub opa_top: lv_opa_t,
            pub opa_bottom: lv_opa_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for
         lv_draw_mask_fade_param_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_draw_mask_fade_param_t__bindgen_ty_1 {
                lv_draw_mask_fade_param_t__bindgen_ty_1{coords:
                                                            ::core::default::Default::default(),
                                                        y_top:
                                                            ::core::default::Default::default(),
                                                        y_bottom:
                                                            ::core::default::Default::default(),
                                                        opa_top:
                                                            ::core::default::Default::default(),
                                                        opa_bottom:
                                                            ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct _lv_draw_mask_map_param_t {
            pub dsc: lv_draw_mask_common_dsc_t,
            pub cfg: _lv_draw_mask_map_param_t__bindgen_ty_1,
        }
        #[repr(C)]
        pub struct _lv_draw_mask_map_param_t__bindgen_ty_1 {
            pub coords: lv_area_t,
            pub map: *const lv_opa_t,
        }
        impl Default for _lv_draw_mask_map_param_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl Default for _lv_draw_mask_map_param_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_draw_mask_map_param_t = _lv_draw_mask_map_param_t;
        #[doc =
          " Add a draw mask. Everything drawn after it (until removing the mask) will be affected by the mask."]
        #[doc =
          " - __`param`__: an initialized mask parameter. Only the pointer is saved."]
        #[doc =
          " - __`custom_id`__: a custom pointer to identify the mask. Used in `lv_draw_mask_remove_custom`."]
        #[doc =
          " Return: the an integer, the ID of the mask. Can be used in `lv_draw_mask_remove_id`."]
        pub fn mask_add(param: Ptr, custom_id: Ptr) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Add a draw mask. Everything drawn after it (until removing the mask) will be affected by the mask."]
                #[doc =
                  " - __`param`__: an initialized mask parameter. Only the pointer is saved."]
                #[doc =
                  " - __`custom_id`__: a custom pointer to identify the mask. Used in `lv_draw_mask_remove_custom`."]
                #[doc =
                  " Return: the an integer, the ID of the mask. Can be used in `lv_draw_mask_remove_id`."]
                pub fn lv_draw_mask_add(param: *mut ::cty::c_void,
                                        custom_id: *mut ::cty::c_void)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_draw_mask_add(param as *mut ::cty::c_void,
                                     custom_id as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Apply the added buffers on a line. Used internally by the library's drawing routines."]
        #[doc =
          " - __`mask_buf`__: store the result mask here. Has to be `len` byte long. Should be initialized with `0xFF`."]
        #[doc =
          " - __`abs_x`__: absolute X coordinate where the line to calculate start"]
        #[doc =
          " - __`abs_y`__: absolute Y coordinate where the line to calculate start"]
        #[doc =
          " - __`len`__: length of the line to calculate (in pixel count)"]
        #[doc = " Return: One of these values:"]
        #[doc =
          " - `LV_DRAW_MASK_RES_FULL_TRANSP`: the whole line is transparent. `mask_buf` is not set to zero"]
        #[doc =
          " - `LV_DRAW_MASK_RES_FULL_COVER`: the whole line is fully visible. `mask_buf` is unchanged"]
        #[doc =
          " - `LV_DRAW_MASK_RES_CHANGED`: `mask_buf` has changed, it shows the desired opacity of each pixel in the given line"]
        pub fn mask_apply(mask_buf: *mut lv_opa_t, abs_x: lv_coord_t,
                          abs_y: lv_coord_t, len: lv_coord_t)
         -> MynewtResult<lv_draw_mask_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Apply the added buffers on a line. Used internally by the library's drawing routines."]
                #[doc =
                  " - __`mask_buf`__: store the result mask here. Has to be `len` byte long. Should be initialized with `0xFF`."]
                #[doc =
                  " - __`abs_x`__: absolute X coordinate where the line to calculate start"]
                #[doc =
                  " - __`abs_y`__: absolute Y coordinate where the line to calculate start"]
                #[doc =
                  " - __`len`__: length of the line to calculate (in pixel count)"]
                #[doc = " Return: One of these values:"]
                #[doc =
                  " - `LV_DRAW_MASK_RES_FULL_TRANSP`: the whole line is transparent. `mask_buf` is not set to zero"]
                #[doc =
                  " - `LV_DRAW_MASK_RES_FULL_COVER`: the whole line is fully visible. `mask_buf` is unchanged"]
                #[doc =
                  " - `LV_DRAW_MASK_RES_CHANGED`: `mask_buf` has changed, it shows the desired opacity of each pixel in the given line"]
                pub fn lv_draw_mask_apply(mask_buf: *mut lv_opa_t,
                                          abs_x: lv_coord_t,
                                          abs_y: lv_coord_t, len: lv_coord_t)
                -> lv_draw_mask_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_draw_mask_apply(mask_buf as *mut lv_opa_t,
                                       abs_x as lv_coord_t,
                                       abs_y as lv_coord_t,
                                       len as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Remove a mask with a given ID"]
        #[doc =
          " - __`id`__: the ID of the mask.  Returned by `lv_draw_mask_add`"]
        #[doc = " Return: the parameter of the removed mask."]
        #[doc =
          " If more masks have `custom_id` ID then the last mask's parameter will be returned"]
        pub fn mask_remove_id(id: i16) -> MynewtResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove a mask with a given ID"]
                #[doc =
                  " - __`id`__: the ID of the mask.  Returned by `lv_draw_mask_add`"]
                #[doc = " Return: the parameter of the removed mask."]
                #[doc =
                  " If more masks have `custom_id` ID then the last mask's parameter will be returned"]
                pub fn lv_draw_mask_remove_id(id: i16)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_draw_mask_remove_id(id as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Remove all mask with a given custom ID"]
        #[doc = " - __`custom_id`__: a pointer used in `lv_draw_mask_add`"]
        #[doc = " Return: return the parameter of the removed mask."]
        #[doc =
          " If more masks have `custom_id` ID then the last mask's parameter will be returned"]
        pub fn mask_remove_custom(custom_id: Ptr)
         -> MynewtResult<*mut ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove all mask with a given custom ID"]
                #[doc =
                  " - __`custom_id`__: a pointer used in `lv_draw_mask_add`"]
                #[doc = " Return: return the parameter of the removed mask."]
                #[doc =
                  " If more masks have `custom_id` ID then the last mask's parameter will be returned"]
                pub fn lv_draw_mask_remove_custom(custom_id:
                                                      *mut ::cty::c_void)
                -> *mut ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_draw_mask_remove_custom(custom_id as
                                                   *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Count the currently added masks"]
        #[doc = " Return: number of active masks"]
        pub fn mask_get_cnt() -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Count the currently added masks"]
                #[doc = " Return: number of active masks"]
                pub fn lv_draw_mask_get_cnt()
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_draw_mask_get_cnt();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = "Initialize a line mask from two points."]
        #[doc =
          " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
        #[doc = " - __`p1x`__: X coordinate of the first point of the line"]
        #[doc = " - __`p1y`__: Y coordinate of the first point of the line"]
        #[doc = " - __`p2x`__: X coordinate of the second point of the line"]
        #[doc = " - __`p2y`__: y coordinate of the second point of the line"]
        #[doc =
          " - __`side`__: and element of `lv_draw_mask_line_side_t` to describe which side to keep."]
        #[doc =
          " With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept"]
        #[doc =
          " With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept"]
        pub fn mask_line_points_init(param: *mut lv_draw_mask_line_param_t,
                                     p1x: lv_coord_t, p1y: lv_coord_t,
                                     p2x: lv_coord_t, p2y: lv_coord_t,
                                     side: lv_draw_mask_line_side_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = "Initialize a line mask from two points."]
                #[doc =
                  " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
                #[doc =
                  " - __`p1x`__: X coordinate of the first point of the line"]
                #[doc =
                  " - __`p1y`__: Y coordinate of the first point of the line"]
                #[doc =
                  " - __`p2x`__: X coordinate of the second point of the line"]
                #[doc =
                  " - __`p2y`__: y coordinate of the second point of the line"]
                #[doc =
                  " - __`side`__: and element of `lv_draw_mask_line_side_t` to describe which side to keep."]
                #[doc =
                  " With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept"]
                #[doc =
                  " With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept"]
                pub fn lv_draw_mask_line_points_init(param:
                                                         *mut lv_draw_mask_line_param_t,
                                                     p1x: lv_coord_t,
                                                     p1y: lv_coord_t,
                                                     p2x: lv_coord_t,
                                                     p2y: lv_coord_t,
                                                     side:
                                                         lv_draw_mask_line_side_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_mask_line_points_init(param as
                                                  *mut lv_draw_mask_line_param_t,
                                              p1x as lv_coord_t,
                                              p1y as lv_coord_t,
                                              p2x as lv_coord_t,
                                              p2y as lv_coord_t,
                                              side as
                                                  lv_draw_mask_line_side_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = "Initialize a line mask from a point and an angle."]
        #[doc =
          " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
        #[doc = " - __`px`__: X coordinate of a point of the line"]
        #[doc = " - __`py`__: X coordinate of a point of the line"]
        #[doc = " - __`angle`__: right 0 deg, bottom: 90"]
        #[doc =
          " - __`side`__: and element of `lv_draw_mask_line_side_t` to describe which side to keep."]
        #[doc =
          " With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept"]
        #[doc =
          " With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept"]
        pub fn mask_line_angle_init(param: *mut lv_draw_mask_line_param_t,
                                    p1x: lv_coord_t, py: lv_coord_t,
                                    angle: i16,
                                    side: lv_draw_mask_line_side_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = "Initialize a line mask from a point and an angle."]
                #[doc =
                  " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
                #[doc = " - __`px`__: X coordinate of a point of the line"]
                #[doc = " - __`py`__: X coordinate of a point of the line"]
                #[doc = " - __`angle`__: right 0 deg, bottom: 90"]
                #[doc =
                  " - __`side`__: and element of `lv_draw_mask_line_side_t` to describe which side to keep."]
                #[doc =
                  " With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept"]
                #[doc =
                  " With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept"]
                pub fn lv_draw_mask_line_angle_init(param:
                                                        *mut lv_draw_mask_line_param_t,
                                                    p1x: lv_coord_t,
                                                    py: lv_coord_t,
                                                    angle: i16,
                                                    side:
                                                        lv_draw_mask_line_side_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_mask_line_angle_init(param as
                                                 *mut lv_draw_mask_line_param_t,
                                             p1x as lv_coord_t,
                                             py as lv_coord_t, angle as i16,
                                             side as
                                                 lv_draw_mask_line_side_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize an angle mask."]
        #[doc =
          " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
        #[doc =
          " - __`vertex_x`__: X coordinate of the angle vertex (absolute coordinates)"]
        #[doc =
          " - __`vertex_y`__: Y coordinate of the angle vertex (absolute coordinates)"]
        #[doc =
          " - __`start_angle`__: start angle in degrees. 0 deg on the right, 90 deg, on the bottom"]
        #[doc = " - __`end_angle`__: end angle"]
        pub fn mask_angle_init(param: *mut lv_draw_mask_angle_param_t,
                               vertex_x: lv_coord_t, vertex_y: lv_coord_t,
                               start_angle: lv_coord_t, end_angle: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize an angle mask."]
                #[doc =
                  " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
                #[doc =
                  " - __`vertex_x`__: X coordinate of the angle vertex (absolute coordinates)"]
                #[doc =
                  " - __`vertex_y`__: Y coordinate of the angle vertex (absolute coordinates)"]
                #[doc =
                  " - __`start_angle`__: start angle in degrees. 0 deg on the right, 90 deg, on the bottom"]
                #[doc = " - __`end_angle`__: end angle"]
                pub fn lv_draw_mask_angle_init(param:
                                                   *mut lv_draw_mask_angle_param_t,
                                               vertex_x: lv_coord_t,
                                               vertex_y: lv_coord_t,
                                               start_angle: lv_coord_t,
                                               end_angle: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_mask_angle_init(param as
                                            *mut lv_draw_mask_angle_param_t,
                                        vertex_x as lv_coord_t,
                                        vertex_y as lv_coord_t,
                                        start_angle as lv_coord_t,
                                        end_angle as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize a fade mask."]
        #[doc =
          " - __`param`__: param pointer to a `lv_draw_mask_param_t` to initialize"]
        #[doc =
          " - __`rect`__: coordinates of the rectangle to affect (absolute coordinates)"]
        #[doc = " - __`radius`__: radius of the rectangle"]
        #[doc =
          " - __`inv:`__: true: keep the pixels inside the rectangle; keep the pixels outside of the rectangle"]
        pub fn mask_radius_init(param: *mut lv_draw_mask_radius_param_t,
                                rect: *const lv_area_t, radius: lv_coord_t,
                                inv: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a fade mask."]
                #[doc =
                  " - __`param`__: param pointer to a `lv_draw_mask_param_t` to initialize"]
                #[doc =
                  " - __`rect`__: coordinates of the rectangle to affect (absolute coordinates)"]
                #[doc = " - __`radius`__: radius of the rectangle"]
                #[doc =
                  " - __`inv:`__: true: keep the pixels inside the rectangle; keep the pixels outside of the rectangle"]
                pub fn lv_draw_mask_radius_init(param:
                                                    *mut lv_draw_mask_radius_param_t,
                                                rect: *const lv_area_t,
                                                radius: lv_coord_t,
                                                inv: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_mask_radius_init(param as
                                             *mut lv_draw_mask_radius_param_t,
                                         rect as *const lv_area_t,
                                         radius as lv_coord_t, inv as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize a fade mask."]
        #[doc =
          " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
        #[doc =
          " - __`coords`__: coordinates of the area to affect (absolute coordinates)"]
        #[doc = " - __`opa_top`__: opacity on the top"]
        #[doc =
          " - __`y_top`__: at which coordinate start to change to opacity to `opa_bottom`"]
        #[doc = " - __`opa_bottom`__: opacity at the bottom"]
        #[doc = " - __`y_bottom`__: at which coordinate reach `opa_bottom`."]
        pub fn mask_fade_init(param: *mut lv_draw_mask_fade_param_t,
                              coords: *const lv_area_t, opa_top: lv_opa_t,
                              y_top: lv_coord_t, opa_bottom: lv_opa_t,
                              y_bottom: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a fade mask."]
                #[doc =
                  " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
                #[doc =
                  " - __`coords`__: coordinates of the area to affect (absolute coordinates)"]
                #[doc = " - __`opa_top`__: opacity on the top"]
                #[doc =
                  " - __`y_top`__: at which coordinate start to change to opacity to `opa_bottom`"]
                #[doc = " - __`opa_bottom`__: opacity at the bottom"]
                #[doc =
                  " - __`y_bottom`__: at which coordinate reach `opa_bottom`."]
                pub fn lv_draw_mask_fade_init(param:
                                                  *mut lv_draw_mask_fade_param_t,
                                              coords: *const lv_area_t,
                                              opa_top: lv_opa_t,
                                              y_top: lv_coord_t,
                                              opa_bottom: lv_opa_t,
                                              y_bottom: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_mask_fade_init(param as
                                           *mut lv_draw_mask_fade_param_t,
                                       coords as *const lv_area_t,
                                       opa_top as lv_opa_t,
                                       y_top as lv_coord_t,
                                       opa_bottom as lv_opa_t,
                                       y_bottom as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize a map mask."]
        #[doc =
          " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
        #[doc =
          " - __`coords`__: coordinates of the map (absolute coordinates)"]
        #[doc = " - __`map`__: array of bytes with the mask values"]
        pub fn mask_map_init(param: *mut lv_draw_mask_map_param_t,
                             coords: *const lv_area_t, map: *const lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize a map mask."]
                #[doc =
                  " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
                #[doc =
                  " - __`coords`__: coordinates of the map (absolute coordinates)"]
                #[doc = " - __`map`__: array of bytes with the mask values"]
                pub fn lv_draw_mask_map_init(param:
                                                 *mut lv_draw_mask_map_param_t,
                                             coords: *const lv_area_t,
                                             map: *const lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_mask_map_init(param as *mut lv_draw_mask_map_param_t,
                                      coords as *const lv_area_t,
                                      map as *const lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub type lv_blend_mode_t = u8;
        pub type lv_grad_dir_t = u8;
        pub type lv_text_decor_t = u8;
        pub type lv_style_int_t = i16;
        pub type lv_txt_flag_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_rect_dsc_t {
            pub radius: lv_style_int_t,
            pub bg_color: lv_color_t,
            pub bg_grad_color: lv_color_t,
            pub bg_grad_dir: lv_grad_dir_t,
            pub bg_main_color_stop: lv_style_int_t,
            pub bg_grad_color_stop: lv_style_int_t,
            pub bg_opa: lv_opa_t,
            pub bg_blend_mode: lv_blend_mode_t,
            pub border_color: lv_color_t,
            pub border_width: lv_style_int_t,
            pub border_side: lv_style_int_t,
            pub border_opa: lv_opa_t,
            pub border_blend_mode: lv_blend_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub outline_color: lv_color_t,
            pub outline_width: lv_style_int_t,
            pub outline_pad: lv_style_int_t,
            pub outline_opa: lv_opa_t,
            pub outline_blend_mode: lv_blend_mode_t,
            pub shadow_color: lv_color_t,
            pub shadow_width: lv_style_int_t,
            pub shadow_ofs_x: lv_style_int_t,
            pub shadow_ofs_y: lv_style_int_t,
            pub shadow_spread: lv_style_int_t,
            pub shadow_opa: lv_opa_t,
            pub shadow_blend_mode: lv_blend_mode_t,
            pub pattern_image: *const ::cty::c_void,
            pub pattern_font: *const lv_font_t,
            pub pattern_recolor: lv_color_t,
            pub pattern_opa: lv_opa_t,
            pub pattern_recolor_opa: lv_opa_t,
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub pattern_blend_mode: lv_blend_mode_t,
            pub value_str: *const ::cty::c_char,
            pub value_font: *const lv_font_t,
            pub value_opa: lv_opa_t,
            pub value_color: lv_color_t,
            pub value_ofs_x: lv_style_int_t,
            pub value_ofs_y: lv_style_int_t,
            pub value_letter_space: lv_style_int_t,
            pub value_line_space: lv_style_int_t,
            pub value_align: lv_align_t,
            pub value_blend_mode: lv_blend_mode_t,
        }
        impl Default for lv_draw_rect_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_rect_dsc_t {
            #[inline]
            pub fn border_post(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_border_post(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(border_post: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let border_post: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post)
                                                    };
                                                border_post as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn pattern_repeat(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_pattern_repeat(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(pattern_repeat: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let pattern_repeat: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_repeat)
                                                    };
                                                pattern_repeat as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " GLOBAL PROTOTYPES"]
        pub fn rect_dsc_init(dsc: *mut lv_draw_rect_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " GLOBAL PROTOTYPES"]
                pub fn lv_draw_rect_dsc_init(dsc: *mut lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_rect_dsc_init(dsc as *mut lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a rectangle"]
        #[doc = " - __`coords`__: the coordinates of the rectangle"]
        #[doc =
          " - __`mask`__: the rectangle will be drawn only in this mask"]
        #[doc =
          " - __`dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
        pub fn rect(coords: *const lv_area_t, mask: *const lv_area_t,
                    dsc: *const lv_draw_rect_dsc_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a rectangle"]
                #[doc = " - __`coords`__: the coordinates of the rectangle"]
                #[doc =
                  " - __`mask`__: the rectangle will be drawn only in this mask"]
                #[doc =
                  " - __`dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
                pub fn lv_draw_rect(coords: *const lv_area_t,
                                    mask: *const lv_area_t,
                                    dsc: *const lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_rect(coords as *const lv_area_t,
                             mask as *const lv_area_t,
                             dsc as *const lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a pixel"]
        #[doc = " - __`point`__: the coordinates of the point to draw"]
        #[doc = " - __`mask`__: the pixel will be drawn only in this mask"]
        #[doc = " - __`style`__: pointer to a style"]
        pub fn px(point: *const lv_point_t, clip_area: *const lv_area_t,
                  style: *const lv_style_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a pixel"]
                #[doc =
                  " - __`point`__: the coordinates of the point to draw"]
                #[doc =
                  " - __`mask`__: the pixel will be drawn only in this mask"]
                #[doc = " - __`style`__: pointer to a style"]
                pub fn lv_draw_px(point: *const lv_point_t,
                                  clip_area: *const lv_area_t,
                                  style: *const lv_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_px(point as *const lv_point_t,
                           clip_area as *const lv_area_t,
                           style as *const lv_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub type lv_bidi_dir_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_label_dsc_t {
            pub color: lv_color_t,
            pub sel_color: lv_color_t,
            pub font: *const lv_font_t,
            pub opa: lv_opa_t,
            pub line_space: lv_style_int_t,
            pub letter_space: lv_style_int_t,
            pub sel_start: u32,
            pub sel_end: u32,
            pub ofs_x: lv_coord_t,
            pub ofs_y: lv_coord_t,
            pub bidi_dir: lv_bidi_dir_t,
            pub flag: lv_txt_flag_t,
            pub decor: lv_text_decor_t,
            pub blend_mode: lv_blend_mode_t,
        }
        impl Default for lv_draw_label_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Store some info to speed up drawing of very large texts"]
        #[doc =
          " It takes a lot of time to get the first visible character because"]
        #[doc =
          " all the previous characters needs to be checked to calculate the positions."]
        #[doc =
          " This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line."]
        #[doc = " Therefore the calculations can start from here."]
        #[repr(C)]
        pub struct lv_draw_label_hint_t {
            #[doc = " Index of the line at `y` coordinate"]
            pub line_start: i32,
            #[doc =
              " Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates"]
            pub y: i32,
            #[doc =
              " The 'y1' coordinate of the label when the hint was saved."]
            #[doc =
              " Used to invalidate the hint if the label has moved too much."]
            pub coord_y: i32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_draw_label_hint_t {
            #[inline]
            fn default() -> lv_draw_label_hint_t {
                lv_draw_label_hint_t{line_start:
                                         ::core::default::Default::default(),
                                     y: ::core::default::Default::default(),
                                     coord_y:
                                         ::core::default::Default::default(),}
            }
        }
        #[doc = "! @cond Doxygen_Suppress"]
        pub fn label_dsc_init(dsc: *mut lv_draw_label_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = "! @cond Doxygen_Suppress"]
                pub fn lv_draw_label_dsc_init(dsc: *mut lv_draw_label_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_label_dsc_init(dsc as *mut lv_draw_label_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Write a text"]
        #[doc = " - __`coords`__: coordinates of the label"]
        #[doc = " - __`mask`__: the label will be drawn only in this area"]
        #[doc = " - __`dsc`__: pointer to draw descriptor"]
        #[doc = " - __`txt`__: `\\0` terminated text to write"]
        #[doc =
          " - __`hint`__: pointer to a `lv_draw_label_hint_t` variable."]
        #[doc =
          " It is managed by the drawer to speed up the drawing of very long texts (thousands of lines)."]
        pub fn label(coords: *const lv_area_t, mask: *const lv_area_t,
                     dsc: *const lv_draw_label_dsc_t, txt: &Strn,
                     hint: *mut lv_draw_label_hint_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Write a text"]
                #[doc = " - __`coords`__: coordinates of the label"]
                #[doc =
                  " - __`mask`__: the label will be drawn only in this area"]
                #[doc = " - __`dsc`__: pointer to draw descriptor"]
                #[doc = " - __`txt`__: `\\0` terminated text to write"]
                #[doc =
                  " - __`hint`__: pointer to a `lv_draw_label_hint_t` variable."]
                #[doc =
                  " It is managed by the drawer to speed up the drawing of very long texts (thousands of lines)."]
                pub fn lv_draw_label(coords: *const lv_area_t,
                                     mask: *const lv_area_t,
                                     dsc: *const lv_draw_label_dsc_t,
                                     txt: *const ::cty::c_char,
                                     hint: *mut lv_draw_label_hint_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_label(coords as *const lv_area_t,
                              mask as *const lv_area_t,
                              dsc as *const lv_draw_label_dsc_t,
                              txt.as_ptr() as *const ::cty::c_char,
                              hint as *mut lv_draw_label_hint_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_img_dsc_t {
            pub opa: lv_opa_t,
            pub angle: u16,
            pub pivot: lv_point_t,
            pub zoom: u16,
            pub recolor_opa: lv_opa_t,
            pub recolor: lv_color_t,
            pub blend_mode: lv_blend_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_draw_img_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_img_dsc_t {
            #[inline]
            pub fn antialias(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_antialias(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialias: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialias: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialias)
                                                    };
                                                antialias as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " GLOBAL PROTOTYPES"]
        pub fn img_dsc_init(dsc: *mut lv_draw_img_dsc_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " GLOBAL PROTOTYPES"]
                pub fn lv_draw_img_dsc_init(dsc: *mut lv_draw_img_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_img_dsc_init(dsc as *mut lv_draw_img_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw an image"]
        #[doc = " - __`coords`__: the coordinates of the image"]
        #[doc = " - __`mask`__: the image will be drawn only in this area"]
        #[doc =
          " - __`src`__: pointer to a lv_color_t array which contains the pixels of the image"]
        #[doc =
          " - __`dsc`__: pointer to an initialized `lv_draw_img_dsc_t` variable"]
        pub fn img(coords: *const lv_area_t, mask: *const lv_area_t,
                   src: *const ::cty::c_void, dsc: *const lv_draw_img_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw an image"]
                #[doc = " - __`coords`__: the coordinates of the image"]
                #[doc =
                  " - __`mask`__: the image will be drawn only in this area"]
                #[doc =
                  " - __`src`__: pointer to a lv_color_t array which contains the pixels of the image"]
                #[doc =
                  " - __`dsc`__: pointer to an initialized `lv_draw_img_dsc_t` variable"]
                pub fn lv_draw_img(coords: *const lv_area_t,
                                   mask: *const lv_area_t,
                                   src: *const ::cty::c_void,
                                   dsc: *const lv_draw_img_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_img(coords as *const lv_area_t,
                            mask as *const lv_area_t,
                            src as *const ::cty::c_void,
                            dsc as *const lv_draw_img_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_line_dsc_t {
            pub color: lv_color_t,
            pub width: lv_style_int_t,
            pub dash_width: lv_style_int_t,
            pub dash_gap: lv_style_int_t,
            pub opa: lv_opa_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_draw_line_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_line_dsc_t {
            #[inline]
            pub fn blend_mode(&self) -> lv_blend_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_blend_mode(&mut self, val: lv_blend_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn round_start(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_round_start(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn round_end(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_round_end(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn raw_end(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_raw_end(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(blend_mode: lv_blend_mode_t,
                                  round_start: u8, round_end: u8, raw_end: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let blend_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode)
                                                    };
                                                blend_mode as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let round_start: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(round_start)
                                                    };
                                                round_start as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let round_end: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(round_end)
                                                    };
                                                round_end as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let raw_end: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(raw_end)
                                                    };
                                                raw_end as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "! @cond Doxygen_Suppress"]
        #[doc = "**"]
        #[doc = "* Draw a line"]
        #[doc = "* - __`point1`__: first point of the line"]
        #[doc = "* - __`point2`__: second point of the line"]
        #[doc = "* - __`clip`__: the line will be drawn only in this area"]
        #[doc =
          "* - __`dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
        #[doc = "*/"]
        pub fn line(point1: *const lv_point_t, point2: *const lv_point_t,
                    clip: *const lv_area_t, dsc: *const lv_draw_line_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = "! @cond Doxygen_Suppress"]
                #[doc = "**"]
                #[doc = "* Draw a line"]
                #[doc = "* - __`point1`__: first point of the line"]
                #[doc = "* - __`point2`__: second point of the line"]
                #[doc =
                  "* - __`clip`__: the line will be drawn only in this area"]
                #[doc =
                  "* - __`dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
                #[doc = "*/"]
                pub fn lv_draw_line(point1: *const lv_point_t,
                                    point2: *const lv_point_t,
                                    clip: *const lv_area_t,
                                    dsc: *const lv_draw_line_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_line(point1 as *const lv_point_t,
                             point2 as *const lv_point_t,
                             clip as *const lv_area_t,
                             dsc as *const lv_draw_line_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        pub fn line_dsc_init(dsc: *mut lv_draw_line_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_draw_line_dsc_init(dsc: *mut lv_draw_line_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_line_dsc_init(dsc as *mut lv_draw_line_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a triangle"]
        #[doc = " - __`points`__: pointer to an array with 3 points"]
        #[doc =
          " - __`clip_area`__: the triangle will be drawn only in this area"]
        #[doc =
          " - __`draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
        pub fn triangle(points: *const lv_point_t, clip: *const lv_area_t,
                        draw_dsc: *const lv_draw_rect_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a triangle"]
                #[doc = " - __`points`__: pointer to an array with 3 points"]
                #[doc =
                  " - __`clip_area`__: the triangle will be drawn only in this area"]
                #[doc =
                  " - __`draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
                pub fn lv_draw_triangle(points: *const lv_point_t,
                                        clip: *const lv_area_t,
                                        draw_dsc: *const lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_triangle(points as *const lv_point_t,
                                 clip as *const lv_area_t,
                                 draw_dsc as *const lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a polygon. Only convex polygons are supported."]
        #[doc = " - __`points`__: an array of points"]
        #[doc = " - __`point_cnt`__: number of points"]
        #[doc = " - __`clip_area`__: polygon will be drawn only in this area"]
        #[doc =
          " - __`draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
        pub fn polygon(points: *const lv_point_t, point_cnt: u16,
                       mask: *const lv_area_t,
                       draw_dsc: *const lv_draw_rect_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Draw a polygon. Only convex polygons are supported."]
                #[doc = " - __`points`__: an array of points"]
                #[doc = " - __`point_cnt`__: number of points"]
                #[doc =
                  " - __`clip_area`__: polygon will be drawn only in this area"]
                #[doc =
                  " - __`draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
                pub fn lv_draw_polygon(points: *const lv_point_t,
                                       point_cnt: u16, mask: *const lv_area_t,
                                       draw_dsc: *const lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_polygon(points as *const lv_point_t, point_cnt as u16,
                                mask as *const lv_area_t,
                                draw_dsc as *const lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw an arc. (Can draw pie too with great thickness.)"]
        #[doc =
          " - __`center_x`__: the x coordinate of the center of the arc"]
        #[doc =
          " - __`center_y`__: the y coordinate of the center of the arc"]
        #[doc = " - __`radius`__: the radius of the arc"]
        #[doc = " - __`mask`__: the arc will be drawn only in this mask"]
        #[doc =
          " - __`start_angle`__: the start angle of the arc (0 deg on the bottom, 90 deg on the right)"]
        #[doc = " - __`end_angle`__: the end angle of the arc"]
        #[doc = " - __`clip_area`__: the arc will be drawn only in this area"]
        #[doc =
          " - __`dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
        pub fn arc(center_x: lv_coord_t, center_y: lv_coord_t, radius: u16,
                   start_angle: u16, end_angle: u16,
                   clip_area: *const lv_area_t,
                   dsc: *const lv_draw_line_dsc_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Draw an arc. (Can draw pie too with great thickness.)"]
                #[doc =
                  " - __`center_x`__: the x coordinate of the center of the arc"]
                #[doc =
                  " - __`center_y`__: the y coordinate of the center of the arc"]
                #[doc = " - __`radius`__: the radius of the arc"]
                #[doc =
                  " - __`mask`__: the arc will be drawn only in this mask"]
                #[doc =
                  " - __`start_angle`__: the start angle of the arc (0 deg on the bottom, 90 deg on the right)"]
                #[doc = " - __`end_angle`__: the end angle of the arc"]
                #[doc =
                  " - __`clip_area`__: the arc will be drawn only in this area"]
                #[doc =
                  " - __`dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
                pub fn lv_draw_arc(center_x: lv_coord_t, center_y: lv_coord_t,
                                   radius: u16, start_angle: u16,
                                   end_angle: u16,
                                   clip_area: *const lv_area_t,
                                   dsc: *const lv_draw_line_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_draw_arc(center_x as lv_coord_t, center_y as lv_coord_t,
                            radius as u16, start_angle as u16,
                            end_angle as u16, clip_area as *const lv_area_t,
                            dsc as *const lv_draw_line_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
}
#[allow(unused_imports)]
pub mod font {
    //! LVGL Font API for Rust
    #[cfg(feature = "mynewt_os")]
    use mynewt::{result::*, Out, Ptr, Strn};
    use crate::{core::{obj::{_lv_obj_t, lv_obj_t, lv_style_t}}};
    /// Contains Rust bindings for LVGL Font Widget API `lv_font`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod font {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_FONT_MONTSERRAT_12: u32 = 0;
        pub const LV_FONT_MONTSERRAT_14: u32 = 0;
        pub const LV_FONT_MONTSERRAT_16: u32 = 0;
        pub const LV_FONT_MONTSERRAT_18: u32 = 0;
        pub const LV_FONT_MONTSERRAT_20: u32 = 0;
        pub const LV_FONT_MONTSERRAT_22: u32 = 0;
        pub const LV_FONT_MONTSERRAT_24: u32 = 1;
        pub const LV_FONT_MONTSERRAT_26: u32 = 0;
        pub const LV_FONT_MONTSERRAT_28: u32 = 0;
        pub const LV_FONT_MONTSERRAT_30: u32 = 0;
        pub const LV_FONT_MONTSERRAT_32: u32 = 1;
        pub const LV_FONT_MONTSERRAT_34: u32 = 0;
        pub const LV_FONT_MONTSERRAT_36: u32 = 0;
        pub const LV_FONT_MONTSERRAT_38: u32 = 0;
        pub const LV_FONT_MONTSERRAT_40: u32 = 0;
        pub const LV_FONT_MONTSERRAT_42: u32 = 0;
        pub const LV_FONT_MONTSERRAT_44: u32 = 0;
        pub const LV_FONT_MONTSERRAT_46: u32 = 0;
        pub const LV_FONT_MONTSERRAT_48: u32 = 0;
        pub const LV_FONT_MONTSERRAT_12_SUBPX: u32 = 0;
        pub const LV_FONT_MONTSERRAT_28_COMPRESSED: u32 = 0;
        pub const LV_FONT_DEJAVU_16_PERSIAN_HEBREW: u32 = 0;
        pub const LV_FONT_SIMSUN_16_CJK: u32 = 0;
        pub const LV_FONT_UNSCII_8: u32 = 0;
        pub const LV_FONT_FMT_TXT_LARGE: u32 = 0;
        pub const LV_FONT_SUBPX_BGR: u32 = 0;
        pub const LV_FONT_MONTSERRAT_8: u32 = 0;
        pub const LV_FONT_MONTSERRAT_10: u32 = 0;
        pub const LV_FONT_WIDTH_FRACT_DIGIT: u32 = 4;
        pub const LV_FONT_KERN_POSITIVE: u32 = 0;
        pub const LV_FONT_KERN_NEGATIVE: u32 = 1;
        pub type lv_coord_t = i16;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u16,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u16,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i16,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i16,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        pub const LV_FONT_SUBPX_NONE: _bindgen_ty_4 = 0;
        pub const LV_FONT_SUBPX_HOR: _bindgen_ty_4 = 1;
        pub const LV_FONT_SUBPX_VER: _bindgen_ty_4 = 2;
        pub const LV_FONT_SUBPX_BOTH: _bindgen_ty_4 = 3;
        #[doc =
          " The bitmaps might be upscaled by 3 to achieve subpixel rendering."]
        pub type _bindgen_ty_4 = u32;
        pub type lv_font_subpx_t = u8;
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: lv_coord_t,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Distance between the top of the underline and base line (< 0 means below the base line)"]
            pub underline_position: i8,
            #[doc = "< Thickness of the underline"]
            pub underline_thickness: i8,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[doc = " Return with the bitmap of a font."]
        #[doc = " - __`font_p`__: pointer to a font"]
        #[doc = " - __`letter`__: an UNICODE character code"]
        #[doc = " Return:  pointer to the bitmap of the letter"]
        pub fn font_get_glyph_bitmap(font_p: *const lv_font_t, letter: u32)
         -> MynewtResult<*const u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Return with the bitmap of a font."]
                #[doc = " - __`font_p`__: pointer to a font"]
                #[doc = " - __`letter`__: an UNICODE character code"]
                #[doc = " Return:  pointer to the bitmap of the letter"]
                pub fn lv_font_get_glyph_bitmap(font_p: *const lv_font_t,
                                                letter: u32)
                -> *const u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_glyph_bitmap(font_p as *const lv_font_t,
                                             letter as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the descriptor of a glyph"]
        #[doc = " - __`font_p`__: pointer to font"]
        #[doc = " - __`dsc_out`__: store the result descriptor here"]
        #[doc = " - __`letter`__: an UNICODE letter code"]
        #[doc =
          " Return: true: descriptor is successfully loaded into `dsc_out`."]
        #[doc =
          "         false: the letter was not found, no data is loaded to `dsc_out`"]
        pub fn font_get_glyph_dsc(font_p: *const lv_font_t,
                                  dsc_out: *mut lv_font_glyph_dsc_t,
                                  letter: u32, letter_next: u32)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the descriptor of a glyph"]
                #[doc = " - __`font_p`__: pointer to font"]
                #[doc = " - __`dsc_out`__: store the result descriptor here"]
                #[doc = " - __`letter`__: an UNICODE letter code"]
                #[doc =
                  " Return: true: descriptor is successfully loaded into `dsc_out`."]
                #[doc =
                  "         false: the letter was not found, no data is loaded to `dsc_out`"]
                pub fn lv_font_get_glyph_dsc(font_p: *const lv_font_t,
                                             dsc_out:
                                                 *mut lv_font_glyph_dsc_t,
                                             letter: u32, letter_next: u32)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_glyph_dsc(font_p as *const lv_font_t,
                                          dsc_out as *mut lv_font_glyph_dsc_t,
                                          letter as u32, letter_next as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the width of a glyph with kerning"]
        #[doc = " - __`font`__: pointer to a font"]
        #[doc = " - __`letter`__: an UNICODE letter"]
        #[doc =
          " - __`letter_next`__: the next letter after `letter`. Used for kerning"]
        #[doc = " Return: the width of the glyph"]
        pub fn font_get_glyph_width(font: *const lv_font_t, letter: u32,
                                    letter_next: u32) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of a glyph with kerning"]
                #[doc = " - __`font`__: pointer to a font"]
                #[doc = " - __`letter`__: an UNICODE letter"]
                #[doc =
                  " - __`letter_next`__: the next letter after `letter`. Used for kerning"]
                #[doc = " Return: the width of the glyph"]
                pub fn lv_font_get_glyph_width(font: *const lv_font_t,
                                               letter: u32, letter_next: u32)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_glyph_width(font as *const lv_font_t,
                                            letter as u32,
                                            letter_next as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the line height of a font. All characters fit into this height"]
        #[doc = " - __`font_p`__: pointer to a font"]
        #[doc = " Return: the height of a font"]
        pub fn font_get_line_height(font_p: *const lv_font_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the line height of a font. All characters fit into this height"]
                #[doc = " - __`font_p`__: pointer to a font"]
                #[doc = " Return: the height of a font"]
                pub fn lv_font_get_line_height(font_p: *const lv_font_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_font_get_line_height(font_p as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        extern "C" {
            pub static mut lv_font_montserrat_24: lv_font_t ;
        }
        extern "C" {
            pub static mut lv_font_montserrat_32: lv_font_t ;
        }
    }
}
#[allow(unused_imports)]
pub mod themes {
    //! LVGL Themes API for Rust
    #[cfg(feature = "mynewt_os")]
    use mynewt::{result::*, Out, Ptr, Strn};
    use crate::{core::{obj::{_lv_obj_t, lv_obj_t, lv_style_t}}};
    /// Contains Rust bindings for LVGL Themes Widget API `lv_theme`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod theme {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub type lv_coord_t = i16;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u16,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u16,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i16,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i16,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: lv_coord_t,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Distance between the top of the underline and base line (< 0 means below the base line)"]
            pub underline_position: i8,
            #[doc = "< Thickness of the underline"]
            pub underline_thickness: i8,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub const lv_theme_style_t_LV_THEME_NONE: lv_theme_style_t = 0;
        pub const lv_theme_style_t_LV_THEME_SCR: lv_theme_style_t = 1;
        pub const lv_theme_style_t_LV_THEME_OBJ: lv_theme_style_t = 2;
        pub const lv_theme_style_t_LV_THEME_ARC: lv_theme_style_t = 3;
        pub const lv_theme_style_t_LV_THEME_BAR: lv_theme_style_t = 4;
        pub const lv_theme_style_t_LV_THEME_BTN: lv_theme_style_t = 5;
        pub const lv_theme_style_t_LV_THEME_BTNMATRIX: lv_theme_style_t = 6;
        pub const lv_theme_style_t_LV_THEME_CALENDAR: lv_theme_style_t = 7;
        pub const lv_theme_style_t_LV_THEME_CANVAS: lv_theme_style_t = 8;
        pub const lv_theme_style_t_LV_THEME_CHECKBOX: lv_theme_style_t = 9;
        pub const lv_theme_style_t_LV_THEME_CHART: lv_theme_style_t = 10;
        pub const lv_theme_style_t_LV_THEME_CONT: lv_theme_style_t = 11;
        pub const lv_theme_style_t_LV_THEME_CPICKER: lv_theme_style_t = 12;
        pub const lv_theme_style_t_LV_THEME_DROPDOWN: lv_theme_style_t = 13;
        pub const lv_theme_style_t_LV_THEME_GAUGE: lv_theme_style_t = 14;
        pub const lv_theme_style_t_LV_THEME_IMAGE: lv_theme_style_t = 15;
        pub const lv_theme_style_t_LV_THEME_IMGBTN: lv_theme_style_t = 16;
        pub const lv_theme_style_t_LV_THEME_KEYBOARD: lv_theme_style_t = 17;
        pub const lv_theme_style_t_LV_THEME_LABEL: lv_theme_style_t = 18;
        pub const lv_theme_style_t_LV_THEME_LED: lv_theme_style_t = 19;
        pub const lv_theme_style_t_LV_THEME_LINE: lv_theme_style_t = 20;
        pub const lv_theme_style_t_LV_THEME_LIST: lv_theme_style_t = 21;
        pub const lv_theme_style_t_LV_THEME_LIST_BTN: lv_theme_style_t = 22;
        pub const lv_theme_style_t_LV_THEME_LINEMETER: lv_theme_style_t = 23;
        pub const lv_theme_style_t_LV_THEME_MSGBOX: lv_theme_style_t = 24;
        pub const lv_theme_style_t_LV_THEME_MSGBOX_BTNS: lv_theme_style_t =
            25;
        pub const lv_theme_style_t_LV_THEME_OBJMASK: lv_theme_style_t = 26;
        pub const lv_theme_style_t_LV_THEME_PAGE: lv_theme_style_t = 27;
        pub const lv_theme_style_t_LV_THEME_ROLLER: lv_theme_style_t = 28;
        pub const lv_theme_style_t_LV_THEME_SLIDER: lv_theme_style_t = 29;
        pub const lv_theme_style_t_LV_THEME_SPINBOX: lv_theme_style_t = 30;
        pub const lv_theme_style_t_LV_THEME_SPINBOX_BTN: lv_theme_style_t =
            31;
        pub const lv_theme_style_t_LV_THEME_SPINNER: lv_theme_style_t = 32;
        pub const lv_theme_style_t_LV_THEME_SWITCH: lv_theme_style_t = 33;
        pub const lv_theme_style_t_LV_THEME_TABLE: lv_theme_style_t = 34;
        pub const lv_theme_style_t_LV_THEME_TABVIEW: lv_theme_style_t = 35;
        pub const lv_theme_style_t_LV_THEME_TABVIEW_PAGE: lv_theme_style_t =
            36;
        pub const lv_theme_style_t_LV_THEME_TEXTAREA: lv_theme_style_t = 37;
        pub const lv_theme_style_t_LV_THEME_TILEVIEW: lv_theme_style_t = 38;
        pub const lv_theme_style_t_LV_THEME_WIN: lv_theme_style_t = 39;
        pub const lv_theme_style_t_LV_THEME_WIN_BTN: lv_theme_style_t = 40;
        pub const lv_theme_style_t__LV_THEME_BUILTIN_LAST: lv_theme_style_t =
            41;
        pub const lv_theme_style_t_LV_THEME_CUSTOM_START: lv_theme_style_t =
            41;
        pub const lv_theme_style_t__LV_THEME_CUSTOM_LAST: lv_theme_style_t =
            65535;
        #[doc = " A theme in LVGL consists of many styles bound together."]
        #[doc = ""]
        #[doc =
          " There is a style for each object type, as well as a generic style for"]
        #[doc = " backgrounds and panels."]
        pub type lv_theme_style_t = u32;
        pub type lv_theme_apply_cb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_theme_t,
                                                     arg2: *mut lv_obj_t,
                                                     arg3: lv_theme_style_t)>;
        pub type lv_theme_apply_xcb_t =
         ::core::option::Option<unsafe extern "C" fn(arg1: *mut lv_obj_t,
                                                     arg2: lv_theme_style_t)>;
        #[repr(C)]
        pub struct _lv_theme_t {
            pub apply_cb: lv_theme_apply_cb_t,
            pub apply_xcb: lv_theme_apply_xcb_t,
            #[doc = "< Apply the current theme's style on top of this theme."]
            pub base: *mut _lv_theme_t,
            pub color_primary: lv_color_t,
            pub color_secondary: lv_color_t,
            pub font_small: *const lv_font_t,
            pub font_normal: *const lv_font_t,
            pub font_subtitle: *const lv_font_t,
            pub font_title: *const lv_font_t,
            pub flags: u32,
            pub user_data: *mut ::cty::c_void,
        }
        impl Default for _lv_theme_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_theme_t = _lv_theme_t;
        #[doc = " Set a theme for the system."]
        #[doc =
          " From now, all the created objects will use styles from this theme by default"]
        #[doc =
          " - __`th`__: pointer to theme (return value of: 'lv_theme_init_xxx()')"]
        pub fn set_act(th: *mut lv_theme_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a theme for the system."]
                #[doc =
                  " From now, all the created objects will use styles from this theme by default"]
                #[doc =
                  " - __`th`__: pointer to theme (return value of: 'lv_theme_init_xxx()')"]
                pub fn lv_theme_set_act(th: *mut lv_theme_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_theme_set_act(th as *mut lv_theme_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the current system theme."]
        #[doc =
          " Return: pointer to the current system theme. NULL if not set."]
        pub fn get_act() -> MynewtResult<*mut lv_theme_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current system theme."]
                #[doc =
                  " Return: pointer to the current system theme. NULL if not set."]
                pub fn lv_theme_get_act()
                -> *mut lv_theme_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_act();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Apply the active theme on an object"]
        #[doc = " - __`obj`__: pointer to an object"]
        #[doc =
          " - __`name`__: the name of the theme element to apply. E.g. `LV_THEME_BTN`"]
        pub fn apply(obj: *mut lv_obj_t, name: lv_theme_style_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Apply the active theme on an object"]
                #[doc = " - __`obj`__: pointer to an object"]
                #[doc =
                  " - __`name`__: the name of the theme element to apply. E.g. `LV_THEME_BTN`"]
                pub fn lv_theme_apply(obj: *mut lv_obj_t,
                                      name: lv_theme_style_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_theme_apply(obj as *mut lv_obj_t,
                               name as lv_theme_style_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Copy a theme to an other or initialize a theme"]
        #[doc = " - __`theme`__: pointer to a theme to initialize"]
        #[doc = " - __`copy`__: pointer to a theme to copy"]
        #[doc = "             or `NULL` to initialize `theme` to empty"]
        pub fn copy(theme: *mut lv_theme_t, copy: *const lv_theme_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy a theme to an other or initialize a theme"]
                #[doc = " - __`theme`__: pointer to a theme to initialize"]
                #[doc = " - __`copy`__: pointer to a theme to copy"]
                #[doc =
                  "             or `NULL` to initialize `theme` to empty"]
                pub fn lv_theme_copy(theme: *mut lv_theme_t,
                                     copy: *const lv_theme_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_theme_copy(theme as *mut lv_theme_t,
                              copy as *const lv_theme_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a base theme for a theme."]
        #[doc =
          " The styles from the base them will be added before the styles of the current theme."]
        #[doc =
          " Arbitrary long chain of themes can be created by setting base themes."]
        #[doc =
          " - __`new_theme`__: pointer to theme which base should be set"]
        #[doc = " - __`base`__: pointer to the base theme"]
        pub fn set_base(new_theme: *mut lv_theme_t, base: *mut lv_theme_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a base theme for a theme."]
                #[doc =
                  " The styles from the base them will be added before the styles of the current theme."]
                #[doc =
                  " Arbitrary long chain of themes can be created by setting base themes."]
                #[doc =
                  " - __`new_theme`__: pointer to theme which base should be set"]
                #[doc = " - __`base`__: pointer to the base theme"]
                pub fn lv_theme_set_base(new_theme: *mut lv_theme_t,
                                         base: *mut lv_theme_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_theme_set_base(new_theme as *mut lv_theme_t,
                                  base as *mut lv_theme_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set an apply callback for a theme."]
        #[doc =
          " The apply callback is used to add styles to different objects"]
        #[doc =
          " - __`theme`__: pointer to theme which callback should be set"]
        #[doc = " - __`apply_cb`__: pointer to the callback"]
        pub fn set_apply_cb(theme: *mut lv_theme_t,
                            apply_cb: lv_theme_apply_cb_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set an apply callback for a theme."]
                #[doc =
                  " The apply callback is used to add styles to different objects"]
                #[doc =
                  " - __`theme`__: pointer to theme which callback should be set"]
                #[doc = " - __`apply_cb`__: pointer to the callback"]
                pub fn lv_theme_set_apply_cb(theme: *mut lv_theme_t,
                                             apply_cb: lv_theme_apply_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_theme_set_apply_cb(theme as *mut lv_theme_t,
                                      apply_cb as lv_theme_apply_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the small font of the theme"]
        #[doc = " Return: pointer to the font"]
        pub fn get_font_small() -> MynewtResult<*const lv_font_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the small font of the theme"]
                #[doc = " Return: pointer to the font"]
                pub fn lv_theme_get_font_small()
                -> *const lv_font_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_font_small();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the normal font of the theme"]
        #[doc = " Return: pointer to the font"]
        pub fn get_font_normal() -> MynewtResult<*const lv_font_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the normal font of the theme"]
                #[doc = " Return: pointer to the font"]
                pub fn lv_theme_get_font_normal()
                -> *const lv_font_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_font_normal();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the subtitle font of the theme"]
        #[doc = " Return: pointer to the font"]
        pub fn get_font_subtitle() -> MynewtResult<*const lv_font_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the subtitle font of the theme"]
                #[doc = " Return: pointer to the font"]
                pub fn lv_theme_get_font_subtitle()
                -> *const lv_font_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_font_subtitle();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the title font of the theme"]
        #[doc = " Return: pointer to the font"]
        pub fn get_font_title() -> MynewtResult<*const lv_font_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the title font of the theme"]
                #[doc = " Return: pointer to the font"]
                pub fn lv_theme_get_font_title()
                -> *const lv_font_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_font_title();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the primary color of the theme"]
        #[doc = " Return: the color"]
        pub fn get_color_primary() -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the primary color of the theme"]
                #[doc = " Return: the color"]
                pub fn lv_theme_get_color_primary()
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_color_primary();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the secondary color of the theme"]
        #[doc = " Return: the color"]
        pub fn get_color_secondary() -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the secondary color of the theme"]
                #[doc = " Return: the color"]
                pub fn lv_theme_get_color_secondary()
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_color_secondary();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the flags of the theme"]
        #[doc = " Return: the flags"]
        pub fn get_flags() -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the flags of the theme"]
                #[doc = " Return: the flags"]
                pub fn lv_theme_get_flags()
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_theme_get_flags();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Initialize the default"]
        #[doc = " - __`color_primary`__: the primary color of the theme"]
        #[doc = " - __`color_secondary`__: the secondary color for the theme"]
        #[doc =
          " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
        #[doc = " - __`font_small`__: pointer to a small font"]
        #[doc = " - __`font_normal`__: pointer to a normal font"]
        #[doc = " - __`font_subtitle`__: pointer to a large font"]
        #[doc = " - __`font_title`__: pointer to a extra large font"]
        #[doc = " Return: a pointer to reference this theme later"]
        pub fn empty_init(color_primary: lv_color_t,
                          color_secondary: lv_color_t, flags: u32,
                          font_small: *const lv_font_t,
                          font_normal: *const lv_font_t,
                          font_subtitle: *const lv_font_t,
                          font_title: *const lv_font_t)
         -> MynewtResult<*mut lv_theme_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize the default"]
                #[doc =
                  " - __`color_primary`__: the primary color of the theme"]
                #[doc =
                  " - __`color_secondary`__: the secondary color for the theme"]
                #[doc =
                  " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
                #[doc = " - __`font_small`__: pointer to a small font"]
                #[doc = " - __`font_normal`__: pointer to a normal font"]
                #[doc = " - __`font_subtitle`__: pointer to a large font"]
                #[doc = " - __`font_title`__: pointer to a extra large font"]
                #[doc = " Return: a pointer to reference this theme later"]
                pub fn lv_theme_empty_init(color_primary: lv_color_t,
                                           color_secondary: lv_color_t,
                                           flags: u32,
                                           font_small: *const lv_font_t,
                                           font_normal: *const lv_font_t,
                                           font_subtitle: *const lv_font_t,
                                           font_title: *const lv_font_t)
                -> *mut lv_theme_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_theme_empty_init(color_primary as lv_color_t,
                                        color_secondary as lv_color_t,
                                        flags as u32,
                                        font_small as *const lv_font_t,
                                        font_normal as *const lv_font_t,
                                        font_subtitle as *const lv_font_t,
                                        font_title as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Initialize the default"]
        #[doc = " - __`color_primary`__: the primary color of the theme"]
        #[doc = " - __`color_secondary`__: the secondary color for the theme"]
        #[doc =
          " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
        #[doc = " - __`font_small`__: pointer to a small font"]
        #[doc = " - __`font_normal`__: pointer to a normal font"]
        #[doc = " - __`font_subtitle`__: pointer to a large font"]
        #[doc = " - __`font_title`__: pointer to a extra large font"]
        #[doc = " Return: a pointer to reference this theme later"]
        pub fn template_init(color_primary: lv_color_t,
                             color_secondary: lv_color_t, flags: u32,
                             font_small: *const lv_font_t,
                             font_normal: *const lv_font_t,
                             font_subtitle: *const lv_font_t,
                             font_title: *const lv_font_t)
         -> MynewtResult<*mut lv_theme_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize the default"]
                #[doc =
                  " - __`color_primary`__: the primary color of the theme"]
                #[doc =
                  " - __`color_secondary`__: the secondary color for the theme"]
                #[doc =
                  " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
                #[doc = " - __`font_small`__: pointer to a small font"]
                #[doc = " - __`font_normal`__: pointer to a normal font"]
                #[doc = " - __`font_subtitle`__: pointer to a large font"]
                #[doc = " - __`font_title`__: pointer to a extra large font"]
                #[doc = " Return: a pointer to reference this theme later"]
                pub fn lv_theme_template_init(color_primary: lv_color_t,
                                              color_secondary: lv_color_t,
                                              flags: u32,
                                              font_small: *const lv_font_t,
                                              font_normal: *const lv_font_t,
                                              font_subtitle: *const lv_font_t,
                                              font_title: *const lv_font_t)
                -> *mut lv_theme_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_theme_template_init(color_primary as lv_color_t,
                                           color_secondary as lv_color_t,
                                           flags as u32,
                                           font_small as *const lv_font_t,
                                           font_normal as *const lv_font_t,
                                           font_subtitle as *const lv_font_t,
                                           font_title as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_DARK:
         lv_theme_material_flag_t =
            1;
        pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_LIGHT:
         lv_theme_material_flag_t =
            2;
        pub const
         lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_NO_TRANSITION:
         lv_theme_material_flag_t =
            16;
        pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_NO_FOCUS:
         lv_theme_material_flag_t =
            32;
        #[doc = "      DEFINES"]
        pub type lv_theme_material_flag_t = u32;
        #[doc = " Initialize the default"]
        #[doc = " - __`color_primary`__: the primary color of the theme"]
        #[doc = " - __`color_secondary`__: the secondary color for the theme"]
        #[doc =
          " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
        #[doc = " - __`font_small`__: pointer to a small font"]
        #[doc = " - __`font_normal`__: pointer to a normal font"]
        #[doc = " - __`font_subtitle`__: pointer to a large font"]
        #[doc = " - __`font_title`__: pointer to a extra large font"]
        #[doc = " Return: a pointer to reference this theme later"]
        pub fn material_init(color_primary: lv_color_t,
                             color_secondary: lv_color_t, flags: u32,
                             font_small: *const lv_font_t,
                             font_normal: *const lv_font_t,
                             font_subtitle: *const lv_font_t,
                             font_title: *const lv_font_t)
         -> MynewtResult<*mut lv_theme_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize the default"]
                #[doc =
                  " - __`color_primary`__: the primary color of the theme"]
                #[doc =
                  " - __`color_secondary`__: the secondary color for the theme"]
                #[doc =
                  " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
                #[doc = " - __`font_small`__: pointer to a small font"]
                #[doc = " - __`font_normal`__: pointer to a normal font"]
                #[doc = " - __`font_subtitle`__: pointer to a large font"]
                #[doc = " - __`font_title`__: pointer to a extra large font"]
                #[doc = " Return: a pointer to reference this theme later"]
                pub fn lv_theme_material_init(color_primary: lv_color_t,
                                              color_secondary: lv_color_t,
                                              flags: u32,
                                              font_small: *const lv_font_t,
                                              font_normal: *const lv_font_t,
                                              font_subtitle: *const lv_font_t,
                                              font_title: *const lv_font_t)
                -> *mut lv_theme_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_theme_material_init(color_primary as lv_color_t,
                                           color_secondary as lv_color_t,
                                           flags as u32,
                                           font_small as *const lv_font_t,
                                           font_normal as *const lv_font_t,
                                           font_subtitle as *const lv_font_t,
                                           font_title as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Initialize the mono theme."]
        #[doc = " - __`color_primary`__: the primary color of the theme"]
        #[doc = " - __`color_secondary`__: the secondary color for the theme"]
        #[doc =
          " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
        #[doc = " - __`font_small`__: pointer to a small font"]
        #[doc = " - __`font_normal`__: pointer to a normal font"]
        #[doc = " - __`font_subtitle`__: pointer to a large font"]
        #[doc = " - __`font_title`__: pointer to a extra large font"]
        #[doc = " Return: a pointer to reference this theme later"]
        pub fn mono_init(color_primary: lv_color_t,
                         color_secondary: lv_color_t, flags: u32,
                         font_small: *const lv_font_t,
                         font_normal: *const lv_font_t,
                         font_subtitle: *const lv_font_t,
                         font_title: *const lv_font_t)
         -> MynewtResult<*mut lv_theme_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize the mono theme."]
                #[doc =
                  " - __`color_primary`__: the primary color of the theme"]
                #[doc =
                  " - __`color_secondary`__: the secondary color for the theme"]
                #[doc =
                  " - __`flags`__: ORed flags starting with `LV_THEME_DEF_FLAG_...`"]
                #[doc = " - __`font_small`__: pointer to a small font"]
                #[doc = " - __`font_normal`__: pointer to a normal font"]
                #[doc = " - __`font_subtitle`__: pointer to a large font"]
                #[doc = " - __`font_title`__: pointer to a extra large font"]
                #[doc = " Return: a pointer to reference this theme later"]
                pub fn lv_theme_mono_init(color_primary: lv_color_t,
                                          color_secondary: lv_color_t,
                                          flags: u32,
                                          font_small: *const lv_font_t,
                                          font_normal: *const lv_font_t,
                                          font_subtitle: *const lv_font_t,
                                          font_title: *const lv_font_t)
                -> *mut lv_theme_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_theme_mono_init(color_primary as lv_color_t,
                                       color_secondary as lv_color_t,
                                       flags as u32,
                                       font_small as *const lv_font_t,
                                       font_normal as *const lv_font_t,
                                       font_subtitle as *const lv_font_t,
                                       font_title as *const lv_font_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
}
#[allow(unused_imports)]
pub mod widgets {
    //! LVGL Widgets API for Rust
    #[cfg(feature = "mynewt_os")]
    use mynewt::{result::*, Out, Ptr, Strn};
    use crate::{core::{obj::{_lv_obj_t, lv_obj_t, lv_style_t}}};
    /// Contains Rust bindings for LVGL Arc Widget API `lv_arc`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod arc {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_ARC_TYPE_NORMAL: _bindgen_ty_32 = 0;
        pub const LV_ARC_TYPE_SYMMETRIC: _bindgen_ty_32 = 1;
        pub const LV_ARC_TYPE_REVERSE: _bindgen_ty_32 = 2;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_32 = u32;
        pub type lv_arc_type_t = u8;
        #[repr(C)]
        pub struct lv_arc_ext_t {
            pub rotation_angle: u16,
            pub arc_angle_start: u16,
            pub arc_angle_end: u16,
            pub bg_angle_start: u16,
            pub bg_angle_end: u16,
            pub style_arc: lv_style_list_t,
            pub style_knob: lv_style_list_t,
            pub cur_value: i16,
            pub min_value: i16,
            pub max_value: i16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub chg_rate: u16,
            pub last_tick: u32,
            pub last_angle: i16,
        }
        impl Default for lv_arc_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_arc_ext_t {
            #[inline]
            pub fn dragging(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_dragging(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn type_(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn adjustable(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_adjustable(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(dragging: u16, type_: u16, adjustable: u16)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let dragging: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(dragging)
                                                    };
                                                dragging as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 2u8,
                                            {
                                                let type_: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let adjustable: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(adjustable)
                                                    };
                                                adjustable as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_ARC_PART_BG: _bindgen_ty_33 = 0;
        pub const LV_ARC_PART_INDIC: _bindgen_ty_33 = 1;
        pub const LV_ARC_PART_KNOB: _bindgen_ty_33 = 2;
        pub const _LV_ARC_PART_VIRTUAL_LAST: _bindgen_ty_33 = 3;
        pub const _LV_ARC_PART_REAL_LAST: _bindgen_ty_33 = 64;
        pub type _bindgen_ty_33 = u32;
        pub type lv_arc_part_t = u8;
        #[doc = " Create a arc objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new arc"]
        #[doc =
          " - __`copy`__: pointer to a arc object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created arc"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a arc objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new arc"]
                #[doc =
                  " - __`copy`__: pointer to a arc object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created arc"]
                pub fn lv_arc_create(par: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_create(par as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set the start angle of an arc. 0 deg: right, 90 bottom, etc."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`start`__: the start angle"]
        pub fn set_start_angle(arc: *mut lv_obj_t, start: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the start angle of an arc. 0 deg: right, 90 bottom, etc."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`start`__: the start angle"]
                pub fn lv_arc_set_start_angle(arc: *mut lv_obj_t, start: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_start_angle(arc as *mut lv_obj_t, start as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the start angle of an arc. 0 deg: right, 90 bottom, etc."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`end`__: the end angle"]
        pub fn set_end_angle(arc: *mut lv_obj_t, end: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the start angle of an arc. 0 deg: right, 90 bottom, etc."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`end`__: the end angle"]
                pub fn lv_arc_set_end_angle(arc: *mut lv_obj_t, end: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_end_angle(arc as *mut lv_obj_t, end as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the start and end angles"]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`start`__: the start angle"]
        #[doc = " - __`end`__: the end angle"]
        pub fn set_angles(arc: *mut lv_obj_t, start: u16, end: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the start and end angles"]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`start`__: the start angle"]
                #[doc = " - __`end`__: the end angle"]
                pub fn lv_arc_set_angles(arc: *mut lv_obj_t, start: u16,
                                         end: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_angles(arc as *mut lv_obj_t, start as u16,
                                  end as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the start angle of an arc background. 0 deg: right, 90 bottom, etc."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`start`__: the start angle"]
        pub fn set_bg_start_angle(arc: *mut lv_obj_t, start: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the start angle of an arc background. 0 deg: right, 90 bottom, etc."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`start`__: the start angle"]
                pub fn lv_arc_set_bg_start_angle(arc: *mut lv_obj_t,
                                                 start: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_bg_start_angle(arc as *mut lv_obj_t, start as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the start angle of an arc background. 0 deg: right, 90 bottom etc."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`end`__: the end angle"]
        pub fn set_bg_end_angle(arc: *mut lv_obj_t, end: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the start angle of an arc background. 0 deg: right, 90 bottom etc."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`end`__: the end angle"]
                pub fn lv_arc_set_bg_end_angle(arc: *mut lv_obj_t, end: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_bg_end_angle(arc as *mut lv_obj_t, end as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the start and end angles of the arc background"]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`start`__: the start angle"]
        #[doc = " - __`end`__: the end angle"]
        pub fn set_bg_angles(arc: *mut lv_obj_t, start: u16, end: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the start and end angles of the arc background"]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`start`__: the start angle"]
                #[doc = " - __`end`__: the end angle"]
                pub fn lv_arc_set_bg_angles(arc: *mut lv_obj_t, start: u16,
                                            end: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_bg_angles(arc as *mut lv_obj_t, start as u16,
                                     end as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the rotation for the whole arc"]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " - __`rotation_angle`__: rotation angle"]
        pub fn set_rotation(arc: *mut lv_obj_t, rotation_angle: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the rotation for the whole arc"]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " - __`rotation_angle`__: rotation angle"]
                pub fn lv_arc_set_rotation(arc: *mut lv_obj_t,
                                           rotation_angle: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_rotation(arc as *mut lv_obj_t,
                                    rotation_angle as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the type of arc."]
        #[doc = " - __`arc`__: pointer to arc object"]
        #[doc = " - __`type`__: arc type"]
        pub fn set_type(arc: *mut lv_obj_t, type_: lv_arc_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the type of arc."]
                #[doc = " - __`arc`__: pointer to arc object"]
                #[doc = " - __`type`__: arc type"]
                pub fn lv_arc_set_type(arc: *mut lv_obj_t,
                                       type_: lv_arc_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_type(arc as *mut lv_obj_t, type_ as lv_arc_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new value on the arc"]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " - __`value`__: new value"]
        pub fn set_value(arc: *mut lv_obj_t, value: i16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new value on the arc"]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " - __`value`__: new value"]
                pub fn lv_arc_set_value(arc: *mut lv_obj_t, value: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_value(arc as *mut lv_obj_t, value as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set minimum and the maximum values of a arc"]
        #[doc = " - __`arc`__: pointer to the arc object"]
        #[doc = " - __`min`__: minimum value"]
        #[doc = " - __`max`__: maximum value"]
        pub fn set_range(arc: *mut lv_obj_t, min: i16, max: i16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set minimum and the maximum values of a arc"]
                #[doc = " - __`arc`__: pointer to the arc object"]
                #[doc = " - __`min`__: minimum value"]
                #[doc = " - __`max`__: maximum value"]
                pub fn lv_arc_set_range(arc: *mut lv_obj_t, min: i16,
                                        max: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_range(arc as *mut lv_obj_t, min as i16,
                                 max as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the threshold of arc knob increments"]
        #[doc = " position."]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " - __`threshold`__: increment threshold"]
        pub fn set_chg_rate(arc: *mut lv_obj_t, threshold: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the threshold of arc knob increments"]
                #[doc = " position."]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " - __`threshold`__: increment threshold"]
                pub fn lv_arc_set_chg_rate(arc: *mut lv_obj_t,
                                           threshold: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_chg_rate(arc as *mut lv_obj_t, threshold as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set whether the arc is adjustable."]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc =
          " - __`adjustable`__: whether the arc has a knob that can be dragged"]
        pub fn set_adjustable(arc: *mut lv_obj_t, adjustable: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set whether the arc is adjustable."]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc =
                  " - __`adjustable`__: whether the arc has a knob that can be dragged"]
                pub fn lv_arc_set_adjustable(arc: *mut lv_obj_t,
                                             adjustable: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_arc_set_adjustable(arc as *mut lv_obj_t,
                                      adjustable as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the start angle of an arc."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " Return: the start angle [0..360]"]
        pub fn get_angle_start(arc: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the start angle of an arc."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " Return: the start angle [0..360]"]
                pub fn lv_arc_get_angle_start(arc: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_get_angle_start(arc as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the end angle of an arc."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " Return: the end angle [0..360]"]
        pub fn get_angle_end(arc: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the end angle of an arc."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " Return: the end angle [0..360]"]
                pub fn lv_arc_get_angle_end(arc: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_arc_get_angle_end(arc as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the start angle of an arc background."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " Return: the start angle [0..360]"]
        pub fn get_bg_angle_start(arc: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the start angle of an arc background."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " Return: the start angle [0..360]"]
                pub fn lv_arc_get_bg_angle_start(arc: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_get_bg_angle_start(arc as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the end angle of an arc background."]
        #[doc = " - __`arc`__: pointer to an arc object"]
        #[doc = " Return: the end angle [0..360]"]
        pub fn get_bg_angle_end(arc: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the end angle of an arc background."]
                #[doc = " - __`arc`__: pointer to an arc object"]
                #[doc = " Return: the end angle [0..360]"]
                pub fn lv_arc_get_bg_angle_end(arc: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_get_bg_angle_end(arc as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether the arc is type or not."]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " Return: arc type"]
        pub fn get_type(arc: *const lv_obj_t) -> MynewtResult<lv_arc_type_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether the arc is type or not."]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " Return: arc type"]
                pub fn lv_arc_get_type(arc: *const lv_obj_t)
                -> lv_arc_type_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_arc_get_type(arc as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the value of the of a arc"]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " Return: the value of the of the arc"]
        pub fn get_value(arc: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the value of the of a arc"]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " Return: the value of the of the arc"]
                pub fn lv_arc_get_value(arc: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_arc_get_value(arc as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the minimum value of a arc"]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " Return: the minimum value of the arc"]
        pub fn get_min_value(arc: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the minimum value of a arc"]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " Return: the minimum value of the arc"]
                pub fn lv_arc_get_min_value(arc: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_get_min_value(arc as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the maximum value of a arc"]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " Return: the maximum value of the arc"]
        pub fn get_max_value(arc: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the maximum value of a arc"]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " Return: the maximum value of the arc"]
                pub fn lv_arc_get_max_value(arc: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_get_max_value(arc as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Give the arc is being dragged or not"]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " Return: true: drag in progress false: not dragged"]
        pub fn is_dragged(arc: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Give the arc is being dragged or not"]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc = " Return: true: drag in progress false: not dragged"]
                pub fn lv_arc_is_dragged(arc: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_arc_is_dragged(arc as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether the arc is adjustable."]
        #[doc = " - __`arc`__: pointer to a arc object"]
        #[doc = " Return: whether the arc has a knob that can be dragged"]
        pub fn get_adjustable(arc: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether the arc is adjustable."]
                #[doc = " - __`arc`__: pointer to a arc object"]
                #[doc =
                  " Return: whether the arc has a knob that can be dragged"]
                pub fn lv_arc_get_adjustable(arc: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_arc_get_adjustable(arc as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Bar Widget API `lv_bar`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod bar {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_BAR_ANIM_STATE_START: u32 = 0;
        pub const LV_BAR_ANIM_STATE_END: u32 = 256;
        pub const LV_BAR_ANIM_STATE_INV: i32 = -1;
        pub const LV_BAR_ANIM_STATE_NORM: u32 = 8;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_BAR_TYPE_NORMAL: _bindgen_ty_41 = 0;
        pub const LV_BAR_TYPE_SYMMETRICAL: _bindgen_ty_41 = 1;
        pub const LV_BAR_TYPE_CUSTOM: _bindgen_ty_41 = 2;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_41 = u32;
        pub type lv_bar_type_t = u8;
        #[repr(C)]
        pub struct lv_bar_anim_t {
            pub bar: *mut lv_obj_t,
            pub anim_start: lv_anim_value_t,
            pub anim_end: lv_anim_value_t,
            pub anim_state: lv_anim_value_t,
        }
        impl Default for lv_bar_anim_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Data of bar"]
        #[repr(C)]
        pub struct lv_bar_ext_t {
            pub cur_value: i16,
            pub min_value: i16,
            pub max_value: i16,
            pub start_value: i16,
            pub indic_area: lv_area_t,
            pub anim_time: lv_anim_value_t,
            pub cur_value_anim: lv_bar_anim_t,
            pub start_value_anim: lv_bar_anim_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub style_indic: lv_style_list_t,
        }
        impl Default for lv_bar_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_bar_ext_t {
            #[inline]
            pub fn type_(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(type_: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let type_: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_BAR_PART_BG: _bindgen_ty_42 = 0;
        #[doc = " Bar background style."]
        pub const LV_BAR_PART_INDIC: _bindgen_ty_42 = 1;
        #[doc = " Bar fill area style."]
        pub const _LV_BAR_PART_VIRTUAL_LAST: _bindgen_ty_42 = 2;
        #[doc = " Bar parts"]
        pub type _bindgen_ty_42 = u32;
        pub type lv_bar_part_t = u8;
        #[doc = " Create a bar objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new bar"]
        #[doc =
          " - __`copy`__: pointer to a bar object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created bar"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a bar objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new bar"]
                #[doc =
                  " - __`copy`__: pointer to a bar object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created bar"]
                pub fn lv_bar_create(par: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_bar_create(par as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a new value on the bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " - __`value`__: new value"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn set_value(bar: *mut lv_obj_t, value: i16,
                         anim: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new value on the bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " - __`value`__: new value"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_bar_set_value(bar: *mut lv_obj_t, value: i16,
                                        anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_bar_set_value(bar as *mut lv_obj_t, value as i16,
                                 anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new start value on the bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " - __`value`__: new start value"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn set_start_value(bar: *mut lv_obj_t, start_value: i16,
                               anim: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new start value on the bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " - __`value`__: new start value"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_bar_set_start_value(bar: *mut lv_obj_t,
                                              start_value: i16,
                                              anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_bar_set_start_value(bar as *mut lv_obj_t,
                                       start_value as i16,
                                       anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set minimum and the maximum values of a bar"]
        #[doc = " - __`bar`__: pointer to the bar object"]
        #[doc = " - __`min`__: minimum value"]
        #[doc = " - __`max`__: maximum value"]
        pub fn set_range(bar: *mut lv_obj_t, min: i16, max: i16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set minimum and the maximum values of a bar"]
                #[doc = " - __`bar`__: pointer to the bar object"]
                #[doc = " - __`min`__: minimum value"]
                #[doc = " - __`max`__: maximum value"]
                pub fn lv_bar_set_range(bar: *mut lv_obj_t, min: i16,
                                        max: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_bar_set_range(bar as *mut lv_obj_t, min as i16,
                                 max as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the type of bar."]
        #[doc = " - __`bar`__: pointer to bar object"]
        #[doc = " - __`type`__: bar type"]
        pub fn set_type(bar: *mut lv_obj_t, type_: lv_bar_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the type of bar."]
                #[doc = " - __`bar`__: pointer to bar object"]
                #[doc = " - __`type`__: bar type"]
                pub fn lv_bar_set_type(bar: *mut lv_obj_t,
                                       type_: lv_bar_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_bar_set_type(bar as *mut lv_obj_t, type_ as lv_bar_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the animation time of the bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " - __`anim_time`__: the animation time in milliseconds."]
        pub fn set_anim_time(bar: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation time of the bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc =
                  " - __`anim_time`__: the animation time in milliseconds."]
                pub fn lv_bar_set_anim_time(bar: *mut lv_obj_t,
                                            anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_bar_set_anim_time(bar as *mut lv_obj_t, anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the value of a bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " Return: the value of the bar"]
        pub fn get_value(bar: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the value of a bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " Return: the value of the bar"]
                pub fn lv_bar_get_value(bar: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_bar_get_value(bar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the start value of a bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " Return: the start value of the bar"]
        pub fn get_start_value(bar: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the start value of a bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " Return: the start value of the bar"]
                pub fn lv_bar_get_start_value(bar: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_bar_get_start_value(bar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the minimum value of a bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " Return: the minimum value of the bar"]
        pub fn get_min_value(bar: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the minimum value of a bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " Return: the minimum value of the bar"]
                pub fn lv_bar_get_min_value(bar: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_bar_get_min_value(bar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the maximum value of a bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " Return: the maximum value of the bar"]
        pub fn get_max_value(bar: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the maximum value of a bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " Return: the maximum value of the bar"]
                pub fn lv_bar_get_max_value(bar: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_bar_get_max_value(bar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the type of bar."]
        #[doc = " - __`bar`__: pointer to bar object"]
        #[doc = " Return: bar type"]
        pub fn get_type(bar: *mut lv_obj_t) -> MynewtResult<lv_bar_type_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the type of bar."]
                #[doc = " - __`bar`__: pointer to bar object"]
                #[doc = " Return: bar type"]
                pub fn lv_bar_get_type(bar: *mut lv_obj_t)
                -> lv_bar_type_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_bar_get_type(bar as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation time of the bar"]
        #[doc = " - __`bar`__: pointer to a bar object"]
        #[doc = " Return: the animation time in milliseconds."]
        pub fn get_anim_time(bar: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation time of the bar"]
                #[doc = " - __`bar`__: pointer to a bar object"]
                #[doc = " Return: the animation time in milliseconds."]
                pub fn lv_bar_get_anim_time(bar: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_bar_get_anim_time(bar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Button Widget API `lv_btn`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod btn {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_BTN_STATE_RELEASED: _bindgen_ty_36 = 0;
        pub const LV_BTN_STATE_PRESSED: _bindgen_ty_36 = 1;
        pub const LV_BTN_STATE_DISABLED: _bindgen_ty_36 = 2;
        pub const LV_BTN_STATE_CHECKED_RELEASED: _bindgen_ty_36 = 3;
        pub const LV_BTN_STATE_CHECKED_PRESSED: _bindgen_ty_36 = 4;
        pub const LV_BTN_STATE_CHECKED_DISABLED: _bindgen_ty_36 = 5;
        pub const _LV_BTN_STATE_LAST: _bindgen_ty_36 = 6;
        #[doc = " Possible states of a button."]
        #[doc =
          " It can be used not only by buttons but other button-like objects too"]
        pub type _bindgen_ty_36 = u32;
        pub type lv_btn_state_t = u8;
        #[doc = " Extended data of button"]
        #[repr(C)]
        pub struct lv_btn_ext_t {
            #[doc = " Ext. of ancestor"]
            pub cont: lv_cont_ext_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_btn_ext_t {
            #[inline]
            fn default() -> lv_btn_ext_t {
                lv_btn_ext_t{cont: ::core::default::Default::default(),
                             _bitfield_1:
                                 ::core::default::Default::default(),}
            }
        }
        impl lv_btn_ext_t {
            #[inline]
            pub fn checkable(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_checkable(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(checkable: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let checkable: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(checkable)
                                                    };
                                                checkable as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_BTN_PART_MAIN: _bindgen_ty_37 = 0;
        pub const _LV_BTN_PART_VIRTUAL_LAST: _bindgen_ty_37 = 1;
        pub const _LV_BTN_PART_REAL_LAST: _bindgen_ty_37 = 64;
        #[doc = "Styles"]
        pub type _bindgen_ty_37 = u32;
        pub type lv_btn_part_t = u8;
        #[doc = " Create a button object"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new button"]
        #[doc =
          " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created button"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a button object"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new button"]
                #[doc =
                  " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created button"]
                pub fn lv_btn_create(par: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btn_create(par as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Enable the toggled states. On release the button will change from/to toggled state."]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " - __`tgl`__: true: enable toggled states, false: disable"]
        pub fn set_checkable(btn: *mut lv_obj_t, tgl: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the toggled states. On release the button will change from/to toggled state."]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc =
                  " - __`tgl`__: true: enable toggled states, false: disable"]
                pub fn lv_btn_set_checkable(btn: *mut lv_obj_t, tgl: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_set_checkable(btn as *mut lv_obj_t, tgl as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the state of the button"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc =
          " - __`state`__: the new state of the button (from lv_btn_state_t enum)"]
        pub fn set_state(btn: *mut lv_obj_t, state: lv_btn_state_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the state of the button"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc =
                  " - __`state`__: the new state of the button (from lv_btn_state_t enum)"]
                pub fn lv_btn_set_state(btn: *mut lv_obj_t,
                                        state: lv_btn_state_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_set_state(btn as *mut lv_obj_t,
                                 state as lv_btn_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Toggle the state of the button (ON->OFF, OFF->ON)"]
        #[doc = " - __`btn`__: pointer to a button object"]
        pub fn toggle(btn: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Toggle the state of the button (ON->OFF, OFF->ON)"]
                #[doc = " - __`btn`__: pointer to a button object"]
                pub fn lv_btn_toggle(btn: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_toggle(btn as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the layout on a button"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " - __`layout`__: a layout from 'lv_cont_layout_t'"]
        pub fn set_layout(btn: *mut lv_obj_t, layout: lv_layout_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the layout on a button"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " - __`layout`__: a layout from 'lv_cont_layout_t'"]
                pub fn lv_btn_set_layout(btn: *mut lv_obj_t,
                                         layout: lv_layout_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_set_layout(btn as *mut lv_obj_t,
                                  layout as lv_layout_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy in all 4 directions separately."]
        #[doc = " It tells how to change the button size automatically."]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " - __`left`__: left fit policy from `lv_fit_t`"]
        #[doc = " - __`right`__: right fit policy from `lv_fit_t`"]
        #[doc = " - __`top`__: top fit policy from `lv_fit_t`"]
        #[doc = " - __`bottom`__: bottom fit policy from `lv_fit_t`"]
        pub fn set_fit4(btn: *mut lv_obj_t, left: lv_fit_t, right: lv_fit_t,
                        top: lv_fit_t, bottom: lv_fit_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the fit policy in all 4 directions separately."]
                #[doc =
                  " It tells how to change the button size automatically."]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " - __`left`__: left fit policy from `lv_fit_t`"]
                #[doc = " - __`right`__: right fit policy from `lv_fit_t`"]
                #[doc = " - __`top`__: top fit policy from `lv_fit_t`"]
                #[doc = " - __`bottom`__: bottom fit policy from `lv_fit_t`"]
                pub fn lv_btn_set_fit4(btn: *mut lv_obj_t, left: lv_fit_t,
                                       right: lv_fit_t, top: lv_fit_t,
                                       bottom: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_set_fit4(btn as *mut lv_obj_t, left as lv_fit_t,
                                right as lv_fit_t, top as lv_fit_t,
                                bottom as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy horizontally and vertically separately."]
        #[doc = " It tells how to change the button size automatically."]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " - __`hor`__: horizontal fit policy from `lv_fit_t`"]
        #[doc = " - __`ver`__: vertical fit policy from `lv_fit_t`"]
        pub fn set_fit2(btn: *mut lv_obj_t, hor: lv_fit_t, ver: lv_fit_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the fit policy horizontally and vertically separately."]
                #[doc =
                  " It tells how to change the button size automatically."]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " - __`hor`__: horizontal fit policy from `lv_fit_t`"]
                #[doc = " - __`ver`__: vertical fit policy from `lv_fit_t`"]
                pub fn lv_btn_set_fit2(btn: *mut lv_obj_t, hor: lv_fit_t,
                                       ver: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_set_fit2(btn as *mut lv_obj_t, hor as lv_fit_t,
                                ver as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy in all 4 direction at once."]
        #[doc = " It tells how to change the button size automatically."]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " - __`fit`__: fit policy from `lv_fit_t`"]
        pub fn set_fit(btn: *mut lv_obj_t, fit: lv_fit_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the fit policy in all 4 direction at once."]
                #[doc =
                  " It tells how to change the button size automatically."]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " - __`fit`__: fit policy from `lv_fit_t`"]
                pub fn lv_btn_set_fit(btn: *mut lv_obj_t, fit: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btn_set_fit(btn as *mut lv_obj_t, fit as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the current state of the button"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " Return: the state of the button (from lv_btn_state_t enum)"]
        #[doc =
          " If the button is in disabled state `LV_BTN_STATE_DISABLED` will be ORed to the other button states."]
        pub fn get_state(btn: *const lv_obj_t)
         -> MynewtResult<lv_btn_state_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current state of the button"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc =
                  " Return: the state of the button (from lv_btn_state_t enum)"]
                #[doc =
                  " If the button is in disabled state `LV_BTN_STATE_DISABLED` will be ORed to the other button states."]
                pub fn lv_btn_get_state(btn: *const lv_obj_t)
                -> lv_btn_state_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_btn_get_state(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the toggle enable attribute of the button"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " Return: true: checkable enabled, false: disabled"]
        pub fn get_checkable(btn: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the toggle enable attribute of the button"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " Return: true: checkable enabled, false: disabled"]
                pub fn lv_btn_get_checkable(btn: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btn_get_checkable(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the layout of a button"]
        #[doc = " - __`btn`__: pointer to button object"]
        #[doc = " Return: the layout from 'lv_cont_layout_t'"]
        pub fn get_layout(btn: *const lv_obj_t) -> MynewtResult<lv_layout_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the layout of a button"]
                #[doc = " - __`btn`__: pointer to button object"]
                #[doc = " Return: the layout from 'lv_cont_layout_t'"]
                pub fn lv_btn_get_layout(btn: *const lv_obj_t)
                -> lv_layout_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_btn_get_layout(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the left fit mode"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_left(btn: *const lv_obj_t) -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the left fit mode"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_btn_get_fit_left(btn: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btn_get_fit_left(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the right fit mode"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_right(btn: *const lv_obj_t) -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the right fit mode"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_btn_get_fit_right(btn: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btn_get_fit_right(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the top fit mode"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_top(btn: *const lv_obj_t) -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the top fit mode"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_btn_get_fit_top(btn: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_btn_get_fit_top(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the bottom fit mode"]
        #[doc = " - __`btn`__: pointer to a button object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_bottom(btn: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the bottom fit mode"]
                #[doc = " - __`btn`__: pointer to a button object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_btn_get_fit_bottom(btn: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btn_get_fit_bottom(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Button Matrix Widget API `lv_btnmatrix`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod btnmatrix {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_BTNMATRIX_WIDTH_MASK: u32 = 7;
        pub const LV_BTNMATRIX_BTN_NONE: u32 = 65535;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_label_align_t = u8;
        #[doc = "< Button hidden"]
        pub const LV_BTNMATRIX_CTRL_HIDDEN: _bindgen_ty_41 = 8;
        #[doc = "< Do not repeat press this button."]
        pub const LV_BTNMATRIX_CTRL_NO_REPEAT: _bindgen_ty_41 = 16;
        #[doc = "< Disable this button."]
        pub const LV_BTNMATRIX_CTRL_DISABLED: _bindgen_ty_41 = 32;
        #[doc = "< Button *can* be toggled."]
        pub const LV_BTNMATRIX_CTRL_CHECKABLE: _bindgen_ty_41 = 64;
        #[doc = "< Button is currently toggled (e.g. checked)."]
        pub const LV_BTNMATRIX_CTRL_CHECK_STATE: _bindgen_ty_41 = 128;
        #[doc =
          "< 1: Send LV_EVENT_SELECTED on CLICK, 0: Send LV_EVENT_SELECTED on PRESS"]
        pub const LV_BTNMATRIX_CTRL_CLICK_TRIG: _bindgen_ty_41 = 256;
        #[doc = " Type to store button control bits (disabled, hidden etc.)"]
        #[doc = " The first 3 bits are used to store the width"]
        pub type _bindgen_ty_41 = u32;
        pub type lv_btnmatrix_ctrl_t = u16;
        #[repr(C)]
        pub struct lv_btnmatrix_ext_t {
            pub map_p: *mut *const ::cty::c_char,
            pub button_areas: *mut lv_area_t,
            pub ctrl_bits: *mut lv_btnmatrix_ctrl_t,
            pub style_btn: lv_style_list_t,
            pub btn_cnt: u16,
            pub btn_id_pr: u16,
            pub btn_id_focused: u16,
            pub btn_id_act: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_btnmatrix_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_btnmatrix_ext_t {
            #[inline]
            pub fn recolor(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_recolor(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn one_check(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_one_check(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(recolor: u8, one_check: u8, align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let recolor: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(recolor)
                                                    };
                                                recolor as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let one_check: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(one_check)
                                                    };
                                                one_check as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 2u8,
                                            {
                                                let align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(align)
                                                    };
                                                align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_BTNMATRIX_PART_BG: _bindgen_ty_42 = 0;
        pub const LV_BTNMATRIX_PART_BTN: _bindgen_ty_42 = 1;
        pub type _bindgen_ty_42 = u32;
        pub type lv_btnmatrix_part_t = u8;
        #[doc = " Create a button matrix objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new button matrix"]
        #[doc =
          " - __`copy`__: pointer to a button matrix object, if not NULL then the new object will be copied"]
        #[doc = " from it"]
        #[doc = " Return: pointer to the created button matrix"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a button matrix objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new button matrix"]
                #[doc =
                  " - __`copy`__: pointer to a button matrix object, if not NULL then the new object will be copied"]
                #[doc = " from it"]
                #[doc = " Return: pointer to the created button matrix"]
                pub fn lv_btnmatrix_create(par: *mut lv_obj_t,
                                           copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_create(par as *mut lv_obj_t,
                                        copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set a new map. Buttons will be created/deleted according to the map. The"]
        #[doc =
          " button matrix keeps a reference to the map and so the string array must not"]
        #[doc = " be deallocated during the life of the matrix."]
        #[doc = " - __`btnm`__: pointer to a button matrix object"]
        #[doc =
          " - __`map`__: pointer a string array. The last string has to be: \"\". Use \"\\n\" to make a line break."]
        pub fn set_map(btnm: *mut lv_obj_t, map: *mut *const ::cty::c_char)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new map. Buttons will be created/deleted according to the map. The"]
                #[doc =
                  " button matrix keeps a reference to the map and so the string array must not"]
                #[doc = " be deallocated during the life of the matrix."]
                #[doc = " - __`btnm`__: pointer to a button matrix object"]
                #[doc =
                  " - __`map`__: pointer a string array. The last string has to be: \"\". Use \"\\n\" to make a line break."]
                pub fn lv_btnmatrix_set_map(btnm: *mut lv_obj_t,
                                            map: *mut *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_map(btnm as *mut lv_obj_t,
                                     map as *mut *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the button control map (hidden, disabled etc.) for a button matrix. The"]
        #[doc =
          " control map array will be copied and so may be deallocated after this"]
        #[doc = " function returns."]
        #[doc = " - __`btnm`__: pointer to a button matrix object"]
        #[doc =
          " - __`ctrl_map`__: pointer to an array of `lv_btn_ctrl_t` control bytes. The"]
        #[doc =
          "                 length of the array and position of the elements must match"]
        #[doc =
          "                 the number and order of the individual buttons (i.e. excludes"]
        #[doc = "                 newline entries)."]
        #[doc =
          "                 An element of the map should look like e.g.:"]
        #[doc =
          "                 `ctrl_map[0] = width | LV_BTNMATRIX_CTRL_NO_REPEAT |  LV_BTNMATRIX_CTRL_TGL_ENABLE`"]
        pub fn set_ctrl_map(btnm: *mut lv_obj_t,
                            ctrl_map: *const lv_btnmatrix_ctrl_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the button control map (hidden, disabled etc.) for a button matrix. The"]
                #[doc =
                  " control map array will be copied and so may be deallocated after this"]
                #[doc = " function returns."]
                #[doc = " - __`btnm`__: pointer to a button matrix object"]
                #[doc =
                  " - __`ctrl_map`__: pointer to an array of `lv_btn_ctrl_t` control bytes. The"]
                #[doc =
                  "                 length of the array and position of the elements must match"]
                #[doc =
                  "                 the number and order of the individual buttons (i.e. excludes"]
                #[doc = "                 newline entries)."]
                #[doc =
                  "                 An element of the map should look like e.g.:"]
                #[doc =
                  "                 `ctrl_map[0] = width | LV_BTNMATRIX_CTRL_NO_REPEAT |  LV_BTNMATRIX_CTRL_TGL_ENABLE`"]
                pub fn lv_btnmatrix_set_ctrl_map(btnm: *mut lv_obj_t,
                                                 ctrl_map:
                                                     *const lv_btnmatrix_ctrl_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_ctrl_map(btnm as *mut lv_obj_t,
                                          ctrl_map as
                                              *const lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the focused button i.e. visually highlight it."]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc =
          " - __`id`__: index of the button to focus(`LV_BTNMATRIX_BTN_NONE` to remove focus)"]
        pub fn set_focused_btn(btnm: *mut lv_obj_t, id: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the focused button i.e. visually highlight it."]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " - __`id`__: index of the button to focus(`LV_BTNMATRIX_BTN_NONE` to remove focus)"]
                pub fn lv_btnmatrix_set_focused_btn(btnm: *mut lv_obj_t,
                                                    id: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_focused_btn(btnm as *mut lv_obj_t,
                                             id as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable recoloring of button's texts"]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc = " - __`en`__: true: enable recoloring; false: disable"]
        pub fn set_recolor(btnm: *const lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable recoloring of button's texts"]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " - __`en`__: true: enable recoloring; false: disable"]
                pub fn lv_btnmatrix_set_recolor(btnm: *const lv_obj_t,
                                                en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_recolor(btnm as *const lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the attributes of a button of the button matrix"]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc =
          " - __`btn_id`__: 0 based index of the button to modify. (Not counting new lines)"]
        pub fn set_btn_ctrl(btnm: *const lv_obj_t, btn_id: u16,
                            ctrl: lv_btnmatrix_ctrl_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the attributes of a button of the button matrix"]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " - __`btn_id`__: 0 based index of the button to modify. (Not counting new lines)"]
                pub fn lv_btnmatrix_set_btn_ctrl(btnm: *const lv_obj_t,
                                                 btn_id: u16,
                                                 ctrl: lv_btnmatrix_ctrl_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_btn_ctrl(btnm as *const lv_obj_t,
                                          btn_id as u16,
                                          ctrl as lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Clear the attributes of a button of the button matrix"]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc =
          " - __`btn_id`__: 0 based index of the button to modify. (Not counting new lines)"]
        pub fn clear_btn_ctrl(btnm: *const lv_obj_t, btn_id: u16,
                              ctrl: lv_btnmatrix_ctrl_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Clear the attributes of a button of the button matrix"]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " - __`btn_id`__: 0 based index of the button to modify. (Not counting new lines)"]
                pub fn lv_btnmatrix_clear_btn_ctrl(btnm: *const lv_obj_t,
                                                   btn_id: u16,
                                                   ctrl: lv_btnmatrix_ctrl_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_clear_btn_ctrl(btnm as *const lv_obj_t,
                                            btn_id as u16,
                                            ctrl as lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the attributes of all buttons of a button matrix"]
        #[doc = " - __`btnm`__: pointer to a button matrix object"]
        #[doc =
          " - __`ctrl`__: attribute(s) to set from `lv_btnmatrix_ctrl_t`. Values can be ORed."]
        pub fn set_btn_ctrl_all(btnm: *mut lv_obj_t,
                                ctrl: lv_btnmatrix_ctrl_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the attributes of all buttons of a button matrix"]
                #[doc = " - __`btnm`__: pointer to a button matrix object"]
                #[doc =
                  " - __`ctrl`__: attribute(s) to set from `lv_btnmatrix_ctrl_t`. Values can be ORed."]
                pub fn lv_btnmatrix_set_btn_ctrl_all(btnm: *mut lv_obj_t,
                                                     ctrl:
                                                         lv_btnmatrix_ctrl_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_btn_ctrl_all(btnm as *mut lv_obj_t,
                                              ctrl as lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Clear the attributes of all buttons of a button matrix"]
        #[doc = " - __`btnm`__: pointer to a button matrix object"]
        #[doc =
          " - __`ctrl`__: attribute(s) to set from `lv_btnmatrix_ctrl_t`. Values can be ORed."]
        #[doc =
          " - __`en`__: true: set the attributes; false: clear the attributes"]
        pub fn clear_btn_ctrl_all(btnm: *mut lv_obj_t,
                                  ctrl: lv_btnmatrix_ctrl_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Clear the attributes of all buttons of a button matrix"]
                #[doc = " - __`btnm`__: pointer to a button matrix object"]
                #[doc =
                  " - __`ctrl`__: attribute(s) to set from `lv_btnmatrix_ctrl_t`. Values can be ORed."]
                #[doc =
                  " - __`en`__: true: set the attributes; false: clear the attributes"]
                pub fn lv_btnmatrix_clear_btn_ctrl_all(btnm: *mut lv_obj_t,
                                                       ctrl:
                                                           lv_btnmatrix_ctrl_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_clear_btn_ctrl_all(btnm as *mut lv_obj_t,
                                                ctrl as lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a single buttons relative width."]
        #[doc =
          " This method will cause the matrix be regenerated and is a relatively"]
        #[doc =
          " expensive operation. It is recommended that initial width be specified using"]
        #[doc =
          " `lv_btnmatrix_set_ctrl_map` and this method only be used for dynamic changes."]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc = " - __`btn_id`__: 0 based index of the button to modify."]
        #[doc =
          " - __`width`__: Relative width compared to the buttons in the same row. [1..7]"]
        pub fn set_btn_width(btnm: *mut lv_obj_t, btn_id: u16, width: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a single buttons relative width."]
                #[doc =
                  " This method will cause the matrix be regenerated and is a relatively"]
                #[doc =
                  " expensive operation. It is recommended that initial width be specified using"]
                #[doc =
                  " `lv_btnmatrix_set_ctrl_map` and this method only be used for dynamic changes."]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " - __`btn_id`__: 0 based index of the button to modify."]
                #[doc =
                  " - __`width`__: Relative width compared to the buttons in the same row. [1..7]"]
                pub fn lv_btnmatrix_set_btn_width(btnm: *mut lv_obj_t,
                                                  btn_id: u16, width: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_btn_width(btnm as *mut lv_obj_t,
                                           btn_id as u16, width as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Make the button matrix like a selector widget (only one button may be toggled at a time)."]
        #[doc =
          " `Checkable` must be enabled on the buttons you want to be selected with `lv_btnmatrix_set_ctrl` or"]
        #[doc = " `lv_btnmatrix_set_btn_ctrl_all`."]
        #[doc = " - __`btnm`__: Button matrix object"]
        #[doc = " - __`one_chk`__: Whether \"one check\" mode is enabled"]
        pub fn set_one_check(btnm: *mut lv_obj_t, one_chk: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Make the button matrix like a selector widget (only one button may be toggled at a time)."]
                #[doc =
                  " `Checkable` must be enabled on the buttons you want to be selected with `lv_btnmatrix_set_ctrl` or"]
                #[doc = " `lv_btnmatrix_set_btn_ctrl_all`."]
                #[doc = " - __`btnm`__: Button matrix object"]
                #[doc =
                  " - __`one_chk`__: Whether \"one check\" mode is enabled"]
                pub fn lv_btnmatrix_set_one_check(btnm: *mut lv_obj_t,
                                                  one_chk: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_one_check(btnm as *mut lv_obj_t,
                                           one_chk as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the align of the map text (left, right or center)"]
        #[doc = " - __`btnm`__: pointer to a btnmatrix object"]
        #[doc =
          " - __`align`__: LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
        pub fn set_align(btnm: *mut lv_obj_t, align: lv_label_align_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the align of the map text (left, right or center)"]
                #[doc = " - __`btnm`__: pointer to a btnmatrix object"]
                #[doc =
                  " - __`align`__: LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
                pub fn lv_btnmatrix_set_align(btnm: *mut lv_obj_t,
                                              align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_btnmatrix_set_align(btnm as *mut lv_obj_t,
                                       align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the current map of a button matrix"]
        #[doc = " - __`btnm`__: pointer to a button matrix object"]
        #[doc = " Return: the current map"]
        pub fn get_map_array(btnm: *const lv_obj_t)
         -> MynewtResult<*mut *const ::cty::c_char> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current map of a button matrix"]
                #[doc = " - __`btnm`__: pointer to a button matrix object"]
                #[doc = " Return: the current map"]
                pub fn lv_btnmatrix_get_map_array(btnm: *const lv_obj_t)
                -> *mut *const ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_map_array(btnm as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check whether the button's text can use recolor or not"]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc = " Return: true: text recolor enable; false: disabled"]
        pub fn get_recolor(btnm: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Check whether the button's text can use recolor or not"]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc = " Return: true: text recolor enable; false: disabled"]
                pub fn lv_btnmatrix_get_recolor(btnm: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_recolor(btnm as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the index of the lastly \"activated\" button by the user (pressed, released etc)"]
        #[doc =
          " Useful in the the `event_cb` to get the text of the button, check if hidden etc."]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc =
          " Return:  index of the last released button (LV_BTNMATRIX_BTN_NONE: if unset)"]
        pub fn get_active_btn(btnm: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the index of the lastly \"activated\" button by the user (pressed, released etc)"]
                #[doc =
                  " Useful in the the `event_cb` to get the text of the button, check if hidden etc."]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " Return:  index of the last released button (LV_BTNMATRIX_BTN_NONE: if unset)"]
                pub fn lv_btnmatrix_get_active_btn(btnm: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_active_btn(btnm as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the focused button's index."]
        #[doc = " - __`btnm`__: pointer to button matrix object"]
        #[doc =
          " Return:  index of the focused button (LV_BTNMATRIX_BTN_NONE: if unset)"]
        pub fn get_focused_btn(btnm: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the focused button's index."]
                #[doc = " - __`btnm`__: pointer to button matrix object"]
                #[doc =
                  " Return:  index of the focused button (LV_BTNMATRIX_BTN_NONE: if unset)"]
                pub fn lv_btnmatrix_get_focused_btn(btnm: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_focused_btn(btnm as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the whether a control value is enabled or disabled for button of a button matrix"]
        #[doc = " - __`btnm`__: pointer to a button matrix object"]
        #[doc =
          " - __`btn_id`__: the index a button not counting new line characters. (E.g. the return value of"]
        #[doc = " lv_btnmatrix_get_pressed/released)"]
        #[doc =
          " - __`ctrl`__: control values to check (ORed value can be used)"]
        #[doc =
          " Return: true: long press repeat is disabled; false: long press repeat enabled"]
        pub fn get_btn_ctrl(btnm: *mut lv_obj_t, btn_id: u16,
                            ctrl: lv_btnmatrix_ctrl_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the whether a control value is enabled or disabled for button of a button matrix"]
                #[doc = " - __`btnm`__: pointer to a button matrix object"]
                #[doc =
                  " - __`btn_id`__: the index a button not counting new line characters. (E.g. the return value of"]
                #[doc = " lv_btnmatrix_get_pressed/released)"]
                #[doc =
                  " - __`ctrl`__: control values to check (ORed value can be used)"]
                #[doc =
                  " Return: true: long press repeat is disabled; false: long press repeat enabled"]
                pub fn lv_btnmatrix_get_btn_ctrl(btnm: *mut lv_obj_t,
                                                 btn_id: u16,
                                                 ctrl: lv_btnmatrix_ctrl_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_btn_ctrl(btnm as *mut lv_obj_t,
                                              btn_id as u16,
                                              ctrl as lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Find whether \"one toggle\" mode is enabled."]
        #[doc = " - __`btnm`__: Button matrix object"]
        #[doc = " Return: whether \"one toggle\" mode is enabled"]
        pub fn get_one_check(btnm: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Find whether \"one toggle\" mode is enabled."]
                #[doc = " - __`btnm`__: Button matrix object"]
                #[doc = " Return: whether \"one toggle\" mode is enabled"]
                pub fn lv_btnmatrix_get_one_check(btnm: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_one_check(btnm as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the align attribute"]
        #[doc = " @param  btnm pointer to a btnmatrix object"]
        #[doc =
          " Return: LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
        pub fn get_align(btnm: *const lv_obj_t)
         -> MynewtResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the align attribute"]
                #[doc = " @param  btnm pointer to a btnmatrix object"]
                #[doc =
                  " Return: LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
                pub fn lv_btnmatrix_get_align(btnm: *const lv_obj_t)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_btnmatrix_get_align(btnm as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Calendar Widget API `lv_calendar`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod calendar {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_CALENDAR_WEEK_STARTS_MONDAY: u32 = 0;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc =
          " Represents a date on the calendar object (platform-agnostic)."]
        #[repr(C)]
        pub struct lv_calendar_date_t {
            pub year: u16,
            pub month: i8,
            pub day: i8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_calendar_date_t {
            #[inline]
            fn default() -> lv_calendar_date_t {
                lv_calendar_date_t{year: ::core::default::Default::default(),
                                   month: ::core::default::Default::default(),
                                   day: ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_calendar_ext_t {
            pub today: lv_calendar_date_t,
            pub showed_date: lv_calendar_date_t,
            pub highlighted_dates: *mut lv_calendar_date_t,
            pub btn_pressing: i8,
            pub highlighted_dates_num: u16,
            pub pressed_date: lv_calendar_date_t,
            pub day_names: *mut *const ::cty::c_char,
            pub month_names: *mut *const ::cty::c_char,
            pub style_header: lv_style_list_t,
            pub style_day_names: lv_style_list_t,
            pub style_date_nums: lv_style_list_t,
        }
        impl Default for lv_calendar_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "< Background and \"normal\" date numbers style"]
        pub const LV_CALENDAR_PART_BG: _bindgen_ty_32 = 0;
        pub const LV_CALENDAR_PART_HEADER: _bindgen_ty_32 = 1;
        #[doc = " Calendar header style"]
        pub const LV_CALENDAR_PART_DAY_NAMES: _bindgen_ty_32 = 2;
        #[doc = " Day name style"]
        pub const LV_CALENDAR_PART_DATE: _bindgen_ty_32 = 3;
        #[doc = " Calendar parts"]
        pub type _bindgen_ty_32 = u32;
        pub type lv_calendar_part_t = u8;
        #[doc = " Create a calendar objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new calendar"]
        #[doc =
          " - __`copy`__: pointer to a calendar object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created calendar"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a calendar objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new calendar"]
                #[doc =
                  " - __`copy`__: pointer to a calendar object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created calendar"]
                pub fn lv_calendar_create(par: *mut lv_obj_t,
                                          copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_create(par as *mut lv_obj_t,
                                       copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the today's date"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " - __`today`__: pointer to an `lv_calendar_date_t` variable containing the date of today. The value"]
        #[doc = " will be saved it can be local variable too."]
        pub fn set_today_date(calendar: *mut lv_obj_t,
                              today: *mut lv_calendar_date_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the today's date"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " - __`today`__: pointer to an `lv_calendar_date_t` variable containing the date of today. The value"]
                #[doc = " will be saved it can be local variable too."]
                pub fn lv_calendar_set_today_date(calendar: *mut lv_obj_t,
                                                  today:
                                                      *mut lv_calendar_date_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_calendar_set_today_date(calendar as *mut lv_obj_t,
                                           today as *mut lv_calendar_date_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the currently showed"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " - __`showed`__: pointer to an `lv_calendar_date_t` variable containing the date to show. The value"]
        #[doc = " will be saved it can be local variable too."]
        pub fn set_showed_date(calendar: *mut lv_obj_t,
                               showed: *mut lv_calendar_date_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the currently showed"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " - __`showed`__: pointer to an `lv_calendar_date_t` variable containing the date to show. The value"]
                #[doc = " will be saved it can be local variable too."]
                pub fn lv_calendar_set_showed_date(calendar: *mut lv_obj_t,
                                                   showed:
                                                       *mut lv_calendar_date_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_calendar_set_showed_date(calendar as *mut lv_obj_t,
                                            showed as
                                                *mut lv_calendar_date_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the the highlighted dates"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " - __`highlighted`__: pointer to an `lv_calendar_date_t` array containing the dates. ONLY A POINTER"]
        #[doc = " WILL BE SAVED! CAN'T BE LOCAL ARRAY."]
        #[doc = " - __`date_num`__: number of dates in the array"]
        pub fn set_highlighted_dates(calendar: *mut lv_obj_t,
                                     highlighted: *mut lv_calendar_date_t,
                                     date_num: u16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the the highlighted dates"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " - __`highlighted`__: pointer to an `lv_calendar_date_t` array containing the dates. ONLY A POINTER"]
                #[doc = " WILL BE SAVED! CAN'T BE LOCAL ARRAY."]
                #[doc = " - __`date_num`__: number of dates in the array"]
                pub fn lv_calendar_set_highlighted_dates(calendar:
                                                             *mut lv_obj_t,
                                                         highlighted:
                                                             *mut lv_calendar_date_t,
                                                         date_num: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_calendar_set_highlighted_dates(calendar as *mut lv_obj_t,
                                                  highlighted as
                                                      *mut lv_calendar_date_t,
                                                  date_num as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the name of the days"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " - __`day_names`__: pointer to an array with the names. E.g. `const char * days[7] = {\"Sun\", \"Mon\","]
        #[doc =
          " ...}` Only the pointer will be saved so this variable can't be local which will be destroyed"]
        #[doc = " later."]
        pub fn set_day_names(calendar: *mut lv_obj_t,
                             day_names: *mut *const ::cty::c_char)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the name of the days"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " - __`day_names`__: pointer to an array with the names. E.g. `const char * days[7] = {\"Sun\", \"Mon\","]
                #[doc =
                  " ...}` Only the pointer will be saved so this variable can't be local which will be destroyed"]
                #[doc = " later."]
                pub fn lv_calendar_set_day_names(calendar: *mut lv_obj_t,
                                                 day_names:
                                                     *mut *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_calendar_set_day_names(calendar as *mut lv_obj_t,
                                          day_names as
                                              *mut *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the name of the month"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " - __`month_names`__: pointer to an array with the names. E.g. `const char * days[12] = {\"Jan\", \"Feb\","]
        #[doc =
          " ...}` Only the pointer will be saved so this variable can't be local which will be destroyed"]
        #[doc = " later."]
        pub fn set_month_names(calendar: *mut lv_obj_t,
                               month_names: *mut *const ::cty::c_char)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the name of the month"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " - __`month_names`__: pointer to an array with the names. E.g. `const char * days[12] = {\"Jan\", \"Feb\","]
                #[doc =
                  " ...}` Only the pointer will be saved so this variable can't be local which will be destroyed"]
                #[doc = " later."]
                pub fn lv_calendar_set_month_names(calendar: *mut lv_obj_t,
                                                   month_names:
                                                       *mut *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_calendar_set_month_names(calendar as *mut lv_obj_t,
                                            month_names as
                                                *mut *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the today's date"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " Return: return pointer to an `lv_calendar_date_t` variable containing the date of today."]
        pub fn get_today_date(calendar: *const lv_obj_t)
         -> MynewtResult<*mut lv_calendar_date_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the today's date"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " Return: return pointer to an `lv_calendar_date_t` variable containing the date of today."]
                pub fn lv_calendar_get_today_date(calendar: *const lv_obj_t)
                -> *mut lv_calendar_date_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_today_date(calendar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the currently showed"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " Return: pointer to an `lv_calendar_date_t` variable containing the date is being shown."]
        pub fn get_showed_date(calendar: *const lv_obj_t)
         -> MynewtResult<*mut lv_calendar_date_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the currently showed"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " Return: pointer to an `lv_calendar_date_t` variable containing the date is being shown."]
                pub fn lv_calendar_get_showed_date(calendar: *const lv_obj_t)
                -> *mut lv_calendar_date_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_showed_date(calendar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the the pressed date."]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " Return: pointer to an `lv_calendar_date_t` variable containing the pressed date."]
        #[doc = "         `NULL` if not date pressed (e.g. the header)"]
        pub fn get_pressed_date(calendar: *const lv_obj_t)
         -> MynewtResult<*mut lv_calendar_date_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the the pressed date."]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " Return: pointer to an `lv_calendar_date_t` variable containing the pressed date."]
                #[doc =
                  "         `NULL` if not date pressed (e.g. the header)"]
                pub fn lv_calendar_get_pressed_date(calendar: *const lv_obj_t)
                -> *mut lv_calendar_date_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_pressed_date(calendar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the the highlighted dates"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc =
          " Return: pointer to an `lv_calendar_date_t` array containing the dates."]
        pub fn get_highlighted_dates(calendar: *const lv_obj_t)
         -> MynewtResult<*mut lv_calendar_date_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the the highlighted dates"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc =
                  " Return: pointer to an `lv_calendar_date_t` array containing the dates."]
                pub fn lv_calendar_get_highlighted_dates(calendar:
                                                             *const lv_obj_t)
                -> *mut lv_calendar_date_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_highlighted_dates(calendar as
                                                          *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of the highlighted dates"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc = " Return: number of highlighted days"]
        pub fn get_highlighted_dates_num(calendar: *const lv_obj_t)
         -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of the highlighted dates"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc = " Return: number of highlighted days"]
                pub fn lv_calendar_get_highlighted_dates_num(calendar:
                                                                 *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_highlighted_dates_num(calendar as
                                                              *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the name of the days"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc = " Return: pointer to the array of day names"]
        pub fn get_day_names(calendar: *const lv_obj_t)
         -> MynewtResult<*mut *const ::cty::c_char> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the name of the days"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc = " Return: pointer to the array of day names"]
                pub fn lv_calendar_get_day_names(calendar: *const lv_obj_t)
                -> *mut *const ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_day_names(calendar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the name of the month"]
        #[doc = " - __`calendar`__: pointer to a calendar object"]
        #[doc = " Return: pointer to the array of month names"]
        pub fn get_month_names(calendar: *const lv_obj_t)
         -> MynewtResult<*mut *const ::cty::c_char> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the name of the month"]
                #[doc = " - __`calendar`__: pointer to a calendar object"]
                #[doc = " Return: pointer to the array of month names"]
                pub fn lv_calendar_get_month_names(calendar: *const lv_obj_t)
                -> *mut *const ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_calendar_get_month_names(calendar as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Canvas Widget API `lv_canvas`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod canvas {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub type lv_coord_t = i16;
        pub type lv_font_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[doc = " Describes the properties of a glyph."]
        #[repr(C)]
        pub struct lv_font_glyph_dsc_t {
            #[doc =
              "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
            pub adv_w: u16,
            #[doc = "< Width of the glyph's bounding box"]
            pub box_w: u16,
            #[doc = "< Height of the glyph's bounding box"]
            pub box_h: u16,
            #[doc = "< x offset of the bounding box"]
            pub ofs_x: i16,
            #[doc = "< y offset of the bounding box"]
            pub ofs_y: i16,
            #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
            pub bpp: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_font_glyph_dsc_t {
            #[inline]
            fn default() -> lv_font_glyph_dsc_t {
                lv_font_glyph_dsc_t{adv_w:
                                        ::core::default::Default::default(),
                                    box_w:
                                        ::core::default::Default::default(),
                                    box_h:
                                        ::core::default::Default::default(),
                                    ofs_x:
                                        ::core::default::Default::default(),
                                    ofs_y:
                                        ::core::default::Default::default(),
                                    bpp: ::core::default::Default::default(),}
            }
        }
        #[doc = " Describe the properties of a font"]
        #[repr(C)]
        pub struct _lv_font_struct {
            #[doc = " Get a glyph's  descriptor from a font"]
            pub get_glyph_dsc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *const _lv_font_struct,
                                                                           arg2:
                                                                               *mut lv_font_glyph_dsc_t,
                                                                           letter:
                                                                               u32,
                                                                           letter_next:
                                                                               u32)
                                                          -> bool>,
            #[doc = " Get a glyph's bitmap from a font"]
            pub get_glyph_bitmap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const _lv_font_struct,
                                                                              arg2:
                                                                                  u32)
                                                             -> *const u8>,
            #[doc = "< The real line height where any text fits"]
            pub line_height: lv_coord_t,
            #[doc = "< Base line measured from the top of the line_height"]
            pub base_line: lv_coord_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            #[doc =
              "< Distance between the top of the underline and base line (< 0 means below the base line)"]
            pub underline_position: i8,
            #[doc = "< Thickness of the underline"]
            pub underline_thickness: i8,
            #[doc =
              "< Store implementation specific or run_time data or caching here"]
            pub dsc: *mut ::cty::c_void,
            #[doc = "< Custom user data for font."]
            pub user_data: lv_font_user_data_t,
        }
        impl Default for _lv_font_struct {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl _lv_font_struct {
            #[inline]
            pub fn subpx(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_subpx(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(subpx: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let subpx: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(subpx)
                                                    };
                                                subpx as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_font_t = _lv_font_struct;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        pub type lv_blend_mode_t = u8;
        pub type lv_grad_dir_t = u8;
        pub type lv_text_decor_t = u8;
        pub type lv_style_int_t = i16;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_rect_dsc_t {
            pub radius: lv_style_int_t,
            pub bg_color: lv_color_t,
            pub bg_grad_color: lv_color_t,
            pub bg_grad_dir: lv_grad_dir_t,
            pub bg_main_color_stop: lv_style_int_t,
            pub bg_grad_color_stop: lv_style_int_t,
            pub bg_opa: lv_opa_t,
            pub bg_blend_mode: lv_blend_mode_t,
            pub border_color: lv_color_t,
            pub border_width: lv_style_int_t,
            pub border_side: lv_style_int_t,
            pub border_opa: lv_opa_t,
            pub border_blend_mode: lv_blend_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub outline_color: lv_color_t,
            pub outline_width: lv_style_int_t,
            pub outline_pad: lv_style_int_t,
            pub outline_opa: lv_opa_t,
            pub outline_blend_mode: lv_blend_mode_t,
            pub shadow_color: lv_color_t,
            pub shadow_width: lv_style_int_t,
            pub shadow_ofs_x: lv_style_int_t,
            pub shadow_ofs_y: lv_style_int_t,
            pub shadow_spread: lv_style_int_t,
            pub shadow_opa: lv_opa_t,
            pub shadow_blend_mode: lv_blend_mode_t,
            pub pattern_image: *const ::cty::c_void,
            pub pattern_font: *const lv_font_t,
            pub pattern_recolor: lv_color_t,
            pub pattern_opa: lv_opa_t,
            pub pattern_recolor_opa: lv_opa_t,
            pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub pattern_blend_mode: lv_blend_mode_t,
            pub value_str: *const ::cty::c_char,
            pub value_font: *const lv_font_t,
            pub value_opa: lv_opa_t,
            pub value_color: lv_color_t,
            pub value_ofs_x: lv_style_int_t,
            pub value_ofs_y: lv_style_int_t,
            pub value_letter_space: lv_style_int_t,
            pub value_line_space: lv_style_int_t,
            pub value_align: lv_align_t,
            pub value_blend_mode: lv_blend_mode_t,
        }
        impl Default for lv_draw_rect_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_rect_dsc_t {
            #[inline]
            pub fn border_post(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_border_post(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(border_post: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let border_post: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post)
                                                    };
                                                border_post as u64
                                            });
                __bindgen_bitfield_unit
            }
            #[inline]
            pub fn pattern_repeat(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_pattern_repeat(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_2.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_2(pattern_repeat: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let pattern_repeat: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_repeat)
                                                    };
                                                pattern_repeat as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_bidi_dir_t = u8;
        pub type lv_txt_flag_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_label_dsc_t {
            pub color: lv_color_t,
            pub sel_color: lv_color_t,
            pub font: *const lv_font_t,
            pub opa: lv_opa_t,
            pub line_space: lv_style_int_t,
            pub letter_space: lv_style_int_t,
            pub sel_start: u32,
            pub sel_end: u32,
            pub ofs_x: lv_coord_t,
            pub ofs_y: lv_coord_t,
            pub bidi_dir: lv_bidi_dir_t,
            pub flag: lv_txt_flag_t,
            pub decor: lv_text_decor_t,
            pub blend_mode: lv_blend_mode_t,
        }
        impl Default for lv_draw_label_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_line_dsc_t {
            pub color: lv_color_t,
            pub width: lv_style_int_t,
            pub dash_width: lv_style_int_t,
            pub dash_gap: lv_style_int_t,
            pub opa: lv_opa_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_draw_line_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_line_dsc_t {
            #[inline]
            pub fn blend_mode(&self) -> lv_blend_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_blend_mode(&mut self, val: lv_blend_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn round_start(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_round_start(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn round_end(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_round_end(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn raw_end(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_raw_end(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(blend_mode: lv_blend_mode_t,
                                  round_start: u8, round_end: u8, raw_end: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let blend_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode)
                                                    };
                                                blend_mode as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let round_start: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(round_start)
                                                    };
                                                round_start as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let round_end: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(round_end)
                                                    };
                                                round_end as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let raw_end: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(raw_end)
                                                    };
                                                raw_end as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_img_cf_t = u8;
        #[repr(C)]
        #[repr(align(4))]
        pub struct lv_img_header_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_img_header_t {
            #[inline]
            fn default() -> lv_img_header_t {
                lv_img_header_t{_bitfield_1:
                                    ::core::default::Default::default(),}
            }
        }
        impl lv_img_header_t {
            #[inline]
            pub fn cf(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_cf(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn always_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_always_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn reserved(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_reserved(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn w(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 11u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_w(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 11u8, val as u64)
                }
            }
            #[inline]
            pub fn h(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_h(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 11u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(cf: u32, always_zero: u32, reserved: u32,
                                  w: u32, h: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 5u8,
                                            {
                                                let cf: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(cf)
                                                    };
                                                cf as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 3u8,
                                            {
                                                let always_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(always_zero)
                                                    };
                                                always_zero as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let reserved: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(reserved)
                                                    };
                                                reserved as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 11u8,
                                            {
                                                let w: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(w)
                                                    };
                                                w as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 11u8,
                                            {
                                                let h: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(h)
                                                    };
                                                h as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Image header it is compatible with"]
        #[doc = " the result from image converter utility"]
        #[repr(C)]
        pub struct lv_img_dsc_t {
            pub header: lv_img_header_t,
            pub data_size: u32,
            pub data: *const u8,
        }
        impl Default for lv_img_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_draw_img_dsc_t {
            pub opa: lv_opa_t,
            pub angle: u16,
            pub pivot: lv_point_t,
            pub zoom: u16,
            pub recolor_opa: lv_opa_t,
            pub recolor: lv_color_t,
            pub blend_mode: lv_blend_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        impl Default for lv_draw_img_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_draw_img_dsc_t {
            #[inline]
            pub fn antialias(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_antialias(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(antialias: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let antialias: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialias)
                                                    };
                                                antialias as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_label_align_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_img_ext_t {
            pub src: *const ::cty::c_void,
            pub offset: lv_point_t,
            pub w: lv_coord_t,
            pub h: lv_coord_t,
            pub angle: u16,
            pub pivot: lv_point_t,
            pub zoom: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        impl Default for lv_img_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_img_ext_t {
            #[inline]
            pub fn src_type(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_src_type(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn auto_size(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_size(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn cf(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_cf(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn antialias(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_antialias(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(src_type: u8, auto_size: u8, cf: u8,
                                  antialias: u8)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let src_type: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(src_type)
                                                    };
                                                src_type as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let auto_size: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_size)
                                                    };
                                                auto_size as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let cf: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(cf)
                                                    };
                                                cf as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let antialias: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialias)
                                                    };
                                                antialias as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_canvas_ext_t {
            pub img: lv_img_ext_t,
            pub dsc: lv_img_dsc_t,
        }
        impl Default for lv_canvas_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub const LV_CANVAS_PART_MAIN: _bindgen_ty_36 = 0;
        pub type _bindgen_ty_36 = u32;
        pub type lv_canvas_part_t = u8;
        #[doc = " Create a canvas object"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new canvas"]
        #[doc =
          " - __`copy`__: pointer to a canvas object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created canvas"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a canvas object"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new canvas"]
                #[doc =
                  " - __`copy`__: pointer to a canvas object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created canvas"]
                pub fn lv_canvas_create(par: *mut lv_obj_t,
                                        copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_canvas_create(par as *mut lv_obj_t,
                                     copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a buffer for the canvas."]
        #[doc =
          " - __`buf`__: a buffer where the content of the canvas will be."]
        #[doc =
          " The required size is (lv_img_color_format_get_px_size(cf) * w) / 8 * h)"]
        #[doc = " It can be allocated with `lv_mem_alloc()` or"]
        #[doc =
          " it can be statically allocated array (e.g. static lv_color_t buf[100*50]) or"]
        #[doc = " it can be an address in RAM or external SRAM"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`w`__: width of the canvas"]
        #[doc = " - __`h`__: height of the canvas"]
        #[doc = " - __`cf`__: color format. `LV_IMG_CF_...`"]
        pub fn set_buffer(canvas: *mut lv_obj_t, buf: Ptr, w: lv_coord_t,
                          h: lv_coord_t, cf: lv_img_cf_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a buffer for the canvas."]
                #[doc =
                  " - __`buf`__: a buffer where the content of the canvas will be."]
                #[doc =
                  " The required size is (lv_img_color_format_get_px_size(cf) * w) / 8 * h)"]
                #[doc = " It can be allocated with `lv_mem_alloc()` or"]
                #[doc =
                  " it can be statically allocated array (e.g. static lv_color_t buf[100*50]) or"]
                #[doc = " it can be an address in RAM or external SRAM"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`w`__: width of the canvas"]
                #[doc = " - __`h`__: height of the canvas"]
                #[doc = " - __`cf`__: color format. `LV_IMG_CF_...`"]
                pub fn lv_canvas_set_buffer(canvas: *mut lv_obj_t,
                                            buf: *mut ::cty::c_void,
                                            w: lv_coord_t, h: lv_coord_t,
                                            cf: lv_img_cf_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_set_buffer(canvas as *mut lv_obj_t,
                                     buf as *mut ::cty::c_void,
                                     w as lv_coord_t, h as lv_coord_t,
                                     cf as lv_img_cf_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the color of a pixel on the canvas"]
        #[doc = " @param canvas"]
        #[doc = " - __`x`__: x coordinate of the point to set"]
        #[doc = " - __`y`__: x coordinate of the point to set"]
        #[doc = " - __`c`__: color of the point"]
        pub fn set_px(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t,
                      c: lv_color_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the color of a pixel on the canvas"]
                #[doc = " @param canvas"]
                #[doc = " - __`x`__: x coordinate of the point to set"]
                #[doc = " - __`y`__: x coordinate of the point to set"]
                #[doc = " - __`c`__: color of the point"]
                pub fn lv_canvas_set_px(canvas: *mut lv_obj_t, x: lv_coord_t,
                                        y: lv_coord_t, c: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_set_px(canvas as *mut lv_obj_t, x as lv_coord_t,
                                 y as lv_coord_t, c as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the palette color of a canvas with index format. Valid only for `LV_IMG_CF_INDEXED1/2/4/8`"]
        #[doc = " - __`canvas`__: pointer to canvas object"]
        #[doc = " - __`id`__: the palette color to set:"]
        #[doc = "   - for `LV_IMG_CF_INDEXED1`: 0..1"]
        #[doc = "   - for `LV_IMG_CF_INDEXED2`: 0..3"]
        #[doc = "   - for `LV_IMG_CF_INDEXED4`: 0..15"]
        #[doc = "   - for `LV_IMG_CF_INDEXED8`: 0..255"]
        #[doc = " - __`c`__: the color to set"]
        pub fn set_palette(canvas: *mut lv_obj_t, id: u8, c: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the palette color of a canvas with index format. Valid only for `LV_IMG_CF_INDEXED1/2/4/8`"]
                #[doc = " - __`canvas`__: pointer to canvas object"]
                #[doc = " - __`id`__: the palette color to set:"]
                #[doc = "   - for `LV_IMG_CF_INDEXED1`: 0..1"]
                #[doc = "   - for `LV_IMG_CF_INDEXED2`: 0..3"]
                #[doc = "   - for `LV_IMG_CF_INDEXED4`: 0..15"]
                #[doc = "   - for `LV_IMG_CF_INDEXED8`: 0..255"]
                #[doc = " - __`c`__: the color to set"]
                pub fn lv_canvas_set_palette(canvas: *mut lv_obj_t, id: u8,
                                             c: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_set_palette(canvas as *mut lv_obj_t, id as u8,
                                      c as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the color of a pixel on the canvas"]
        #[doc = " @param canvas"]
        #[doc = " - __`x`__: x coordinate of the point to set"]
        #[doc = " - __`y`__: x coordinate of the point to set"]
        #[doc = " Return: color of the point"]
        pub fn get_px(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the color of a pixel on the canvas"]
                #[doc = " @param canvas"]
                #[doc = " - __`x`__: x coordinate of the point to set"]
                #[doc = " - __`y`__: x coordinate of the point to set"]
                #[doc = " Return: color of the point"]
                pub fn lv_canvas_get_px(canvas: *mut lv_obj_t, x: lv_coord_t,
                                        y: lv_coord_t)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_canvas_get_px(canvas as *mut lv_obj_t, x as lv_coord_t,
                                     y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the image of the canvas as a pointer to an `lv_img_dsc_t` variable."]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " Return: pointer to the image descriptor."]
        pub fn get_img(canvas: *mut lv_obj_t)
         -> MynewtResult<*mut lv_img_dsc_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the image of the canvas as a pointer to an `lv_img_dsc_t` variable."]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " Return: pointer to the image descriptor."]
                pub fn lv_canvas_get_img(canvas: *mut lv_obj_t)
                -> *mut lv_img_dsc_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_canvas_get_img(canvas as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Copy a buffer to the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc =
          " - __`to_copy`__: buffer to copy. The color format has to match with the canvas's buffer color"]
        #[doc = " format"]
        #[doc = " - __`x`__: left side of the destination position"]
        #[doc = " - __`y`__: top side of the destination position"]
        #[doc = " - __`w`__: width of the buffer to copy"]
        #[doc = " - __`h`__: height of the buffer to copy"]
        pub fn copy_buf(canvas: *mut lv_obj_t, to_copy: *const ::cty::c_void,
                        x: lv_coord_t, y: lv_coord_t, w: lv_coord_t,
                        h: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Copy a buffer to the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc =
                  " - __`to_copy`__: buffer to copy. The color format has to match with the canvas's buffer color"]
                #[doc = " format"]
                #[doc = " - __`x`__: left side of the destination position"]
                #[doc = " - __`y`__: top side of the destination position"]
                #[doc = " - __`w`__: width of the buffer to copy"]
                #[doc = " - __`h`__: height of the buffer to copy"]
                pub fn lv_canvas_copy_buf(canvas: *mut lv_obj_t,
                                          to_copy: *const ::cty::c_void,
                                          x: lv_coord_t, y: lv_coord_t,
                                          w: lv_coord_t, h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_copy_buf(canvas as *mut lv_obj_t,
                                   to_copy as *const ::cty::c_void,
                                   x as lv_coord_t, y as lv_coord_t,
                                   w as lv_coord_t, h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Transform and image and store the result on a canvas."]
        #[doc =
          " - __`canvas`__: pointer to a canvas object to store the result of the transformation."]
        #[doc = " - __`img`__: pointer to an image descriptor to transform."]
        #[doc =
          "             Can be the image descriptor of an other canvas too (`lv_canvas_get_img()`)."]
        #[doc =
          " - __`angle`__: the angle of rotation (0..3600), 0.1 deg resolution"]
        #[doc = " - __`zoom`__: zoom factor (256 no zoom);"]
        #[doc =
          " - __`offset_x`__: offset X to tell where to put the result data on destination canvas"]
        #[doc =
          " - __`offset_y`__: offset X to tell where to put the result data on destination canvas"]
        #[doc =
          " - __`pivot_x`__: pivot X of rotation. Relative to the source canvas"]
        #[doc =
          "                Set to `source width / 2` to rotate around the center"]
        #[doc =
          " - __`pivot_y`__: pivot Y of rotation. Relative to the source canvas"]
        #[doc =
          "                Set to `source height / 2` to rotate around the center"]
        #[doc =
          " - __`antialias`__: apply anti-aliasing during the transformation. Looks better but slower."]
        pub fn transform(canvas: *mut lv_obj_t, img: *mut lv_img_dsc_t,
                         angle: i16, zoom: u16, offset_x: lv_coord_t,
                         offset_y: lv_coord_t, pivot_x: i32, pivot_y: i32,
                         antialias: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Transform and image and store the result on a canvas."]
                #[doc =
                  " - __`canvas`__: pointer to a canvas object to store the result of the transformation."]
                #[doc =
                  " - __`img`__: pointer to an image descriptor to transform."]
                #[doc =
                  "             Can be the image descriptor of an other canvas too (`lv_canvas_get_img()`)."]
                #[doc =
                  " - __`angle`__: the angle of rotation (0..3600), 0.1 deg resolution"]
                #[doc = " - __`zoom`__: zoom factor (256 no zoom);"]
                #[doc =
                  " - __`offset_x`__: offset X to tell where to put the result data on destination canvas"]
                #[doc =
                  " - __`offset_y`__: offset X to tell where to put the result data on destination canvas"]
                #[doc =
                  " - __`pivot_x`__: pivot X of rotation. Relative to the source canvas"]
                #[doc =
                  "                Set to `source width / 2` to rotate around the center"]
                #[doc =
                  " - __`pivot_y`__: pivot Y of rotation. Relative to the source canvas"]
                #[doc =
                  "                Set to `source height / 2` to rotate around the center"]
                #[doc =
                  " - __`antialias`__: apply anti-aliasing during the transformation. Looks better but slower."]
                pub fn lv_canvas_transform(canvas: *mut lv_obj_t,
                                           img: *mut lv_img_dsc_t, angle: i16,
                                           zoom: u16, offset_x: lv_coord_t,
                                           offset_y: lv_coord_t, pivot_x: i32,
                                           pivot_y: i32, antialias: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_transform(canvas as *mut lv_obj_t,
                                    img as *mut lv_img_dsc_t, angle as i16,
                                    zoom as u16, offset_x as lv_coord_t,
                                    offset_y as lv_coord_t, pivot_x as i32,
                                    pivot_y as i32, antialias as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Apply horizontal blur on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc =
          " - __`area`__: the area to blur. If `NULL` the whole canvas will be blurred."]
        #[doc = " - __`r`__: radius of the blur"]
        pub fn blur_hor(canvas: *mut lv_obj_t, area: *const lv_area_t, r: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Apply horizontal blur on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc =
                  " - __`area`__: the area to blur. If `NULL` the whole canvas will be blurred."]
                #[doc = " - __`r`__: radius of the blur"]
                pub fn lv_canvas_blur_hor(canvas: *mut lv_obj_t,
                                          area: *const lv_area_t, r: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_blur_hor(canvas as *mut lv_obj_t,
                                   area as *const lv_area_t, r as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Apply vertical blur on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc =
          " - __`area`__: the area to blur. If `NULL` the whole canvas will be blurred."]
        #[doc = " - __`r`__: radius of the blur"]
        pub fn blur_ver(canvas: *mut lv_obj_t, area: *const lv_area_t, r: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Apply vertical blur on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc =
                  " - __`area`__: the area to blur. If `NULL` the whole canvas will be blurred."]
                #[doc = " - __`r`__: radius of the blur"]
                pub fn lv_canvas_blur_ver(canvas: *mut lv_obj_t,
                                          area: *const lv_area_t, r: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_blur_ver(canvas as *mut lv_obj_t,
                                   area as *const lv_area_t, r as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Fill the canvas with color"]
        #[doc = " - __`canvas`__: pointer to a canvas"]
        #[doc = " - __`color`__: the background color"]
        #[doc = " - __`opa`__: the desired opacity"]
        pub fn fill_bg(canvas: *mut lv_obj_t, color: lv_color_t,
                       opa: lv_opa_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Fill the canvas with color"]
                #[doc = " - __`canvas`__: pointer to a canvas"]
                #[doc = " - __`color`__: the background color"]
                #[doc = " - __`opa`__: the desired opacity"]
                pub fn lv_canvas_fill_bg(canvas: *mut lv_obj_t,
                                         color: lv_color_t, opa: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_fill_bg(canvas as *mut lv_obj_t,
                                  color as lv_color_t, opa as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a rectangle on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`x`__: left coordinate of the rectangle"]
        #[doc = " - __`y`__: top coordinate of the rectangle"]
        #[doc = " - __`w`__: width of the rectangle"]
        #[doc = " - __`h`__: height of the rectangle"]
        #[doc = " - __`rect_dsc`__: descriptor of the rectangle"]
        pub fn draw_rect(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t,
                         w: lv_coord_t, h: lv_coord_t,
                         rect_dsc: *const lv_draw_rect_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a rectangle on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`x`__: left coordinate of the rectangle"]
                #[doc = " - __`y`__: top coordinate of the rectangle"]
                #[doc = " - __`w`__: width of the rectangle"]
                #[doc = " - __`h`__: height of the rectangle"]
                #[doc = " - __`rect_dsc`__: descriptor of the rectangle"]
                pub fn lv_canvas_draw_rect(canvas: *mut lv_obj_t,
                                           x: lv_coord_t, y: lv_coord_t,
                                           w: lv_coord_t, h: lv_coord_t,
                                           rect_dsc:
                                               *const lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_draw_rect(canvas as *mut lv_obj_t, x as lv_coord_t,
                                    y as lv_coord_t, w as lv_coord_t,
                                    h as lv_coord_t,
                                    rect_dsc as *const lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a text on the canvas."]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`x`__: left coordinate of the text"]
        #[doc = " - __`y`__: top coordinate of the text"]
        #[doc =
          " - __`max_w`__: max width of the text. The text will be wrapped to fit into this size"]
        #[doc =
          " - __`label_draw_dsc`__: pointer to a valid label descriptor `lv_draw_label_dsc_t`"]
        #[doc = " - __`txt`__: text to display"]
        #[doc =
          " - __`align`__: align of the text (`LV_LABEL_ALIGN_LEFT/RIGHT/CENTER`)"]
        pub fn draw_text(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t,
                         max_w: lv_coord_t,
                         label_draw_dsc: *mut lv_draw_label_dsc_t, txt: &Strn,
                         align: lv_label_align_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a text on the canvas."]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`x`__: left coordinate of the text"]
                #[doc = " - __`y`__: top coordinate of the text"]
                #[doc =
                  " - __`max_w`__: max width of the text. The text will be wrapped to fit into this size"]
                #[doc =
                  " - __`label_draw_dsc`__: pointer to a valid label descriptor `lv_draw_label_dsc_t`"]
                #[doc = " - __`txt`__: text to display"]
                #[doc =
                  " - __`align`__: align of the text (`LV_LABEL_ALIGN_LEFT/RIGHT/CENTER`)"]
                pub fn lv_canvas_draw_text(canvas: *mut lv_obj_t,
                                           x: lv_coord_t, y: lv_coord_t,
                                           max_w: lv_coord_t,
                                           label_draw_dsc:
                                               *mut lv_draw_label_dsc_t,
                                           txt: *const ::cty::c_char,
                                           align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_draw_text(canvas as *mut lv_obj_t, x as lv_coord_t,
                                    y as lv_coord_t, max_w as lv_coord_t,
                                    label_draw_dsc as
                                        *mut lv_draw_label_dsc_t,
                                    txt.as_ptr() as *const ::cty::c_char,
                                    align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw an image on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`x`__: left coordinate of the image"]
        #[doc = " - __`y`__: top coordinate of the image"]
        #[doc =
          " - __`src`__: image source. Can be a pointer an `lv_img_dsc_t` variable or a path an image."]
        #[doc =
          " - __`img_draw_dsc`__: pointer to a valid label descriptor `lv_draw_img_dsc_t`"]
        pub fn draw_img(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t,
                        src: *const ::cty::c_void,
                        img_draw_dsc: *const lv_draw_img_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw an image on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`x`__: left coordinate of the image"]
                #[doc = " - __`y`__: top coordinate of the image"]
                #[doc =
                  " - __`src`__: image source. Can be a pointer an `lv_img_dsc_t` variable or a path an image."]
                #[doc =
                  " - __`img_draw_dsc`__: pointer to a valid label descriptor `lv_draw_img_dsc_t`"]
                pub fn lv_canvas_draw_img(canvas: *mut lv_obj_t,
                                          x: lv_coord_t, y: lv_coord_t,
                                          src: *const ::cty::c_void,
                                          img_draw_dsc:
                                              *const lv_draw_img_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_draw_img(canvas as *mut lv_obj_t, x as lv_coord_t,
                                   y as lv_coord_t,
                                   src as *const ::cty::c_void,
                                   img_draw_dsc as *const lv_draw_img_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a line on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`points`__: point of the line"]
        #[doc = " - __`point_cnt`__: number of points"]
        #[doc =
          " - __`line_draw_dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
        pub fn draw_line(canvas: *mut lv_obj_t, points: *const lv_point_t,
                         point_cnt: u32,
                         line_draw_dsc: *const lv_draw_line_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a line on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`points`__: point of the line"]
                #[doc = " - __`point_cnt`__: number of points"]
                #[doc =
                  " - __`line_draw_dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
                pub fn lv_canvas_draw_line(canvas: *mut lv_obj_t,
                                           points: *const lv_point_t,
                                           point_cnt: u32,
                                           line_draw_dsc:
                                               *const lv_draw_line_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_draw_line(canvas as *mut lv_obj_t,
                                    points as *const lv_point_t,
                                    point_cnt as u32,
                                    line_draw_dsc as
                                        *const lv_draw_line_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw a polygon on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`points`__: point of the polygon"]
        #[doc = " - __`point_cnt`__: number of points"]
        #[doc =
          " - __`poly_draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
        pub fn draw_polygon(canvas: *mut lv_obj_t, points: *const lv_point_t,
                            point_cnt: u32,
                            poly_draw_dsc: *const lv_draw_rect_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw a polygon on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`points`__: point of the polygon"]
                #[doc = " - __`point_cnt`__: number of points"]
                #[doc =
                  " - __`poly_draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
                pub fn lv_canvas_draw_polygon(canvas: *mut lv_obj_t,
                                              points: *const lv_point_t,
                                              point_cnt: u32,
                                              poly_draw_dsc:
                                                  *const lv_draw_rect_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_draw_polygon(canvas as *mut lv_obj_t,
                                       points as *const lv_point_t,
                                       point_cnt as u32,
                                       poly_draw_dsc as
                                           *const lv_draw_rect_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Draw an arc on the canvas"]
        #[doc = " - __`canvas`__: pointer to a canvas object"]
        #[doc = " - __`x`__: origo x  of the arc"]
        #[doc = " - __`y`__: origo y of the arc"]
        #[doc = " - __`r`__: radius of the arc"]
        #[doc = " - __`start_angle`__: start angle in degrees"]
        #[doc = " - __`end_angle`__: end angle in degrees"]
        #[doc =
          " - __`arc_draw_dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
        pub fn draw_arc(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t,
                        r: lv_coord_t, start_angle: i32, end_angle: i32,
                        arc_draw_dsc: *const lv_draw_line_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Draw an arc on the canvas"]
                #[doc = " - __`canvas`__: pointer to a canvas object"]
                #[doc = " - __`x`__: origo x  of the arc"]
                #[doc = " - __`y`__: origo y of the arc"]
                #[doc = " - __`r`__: radius of the arc"]
                #[doc = " - __`start_angle`__: start angle in degrees"]
                #[doc = " - __`end_angle`__: end angle in degrees"]
                #[doc =
                  " - __`arc_draw_dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
                pub fn lv_canvas_draw_arc(canvas: *mut lv_obj_t,
                                          x: lv_coord_t, y: lv_coord_t,
                                          r: lv_coord_t, start_angle: i32,
                                          end_angle: i32,
                                          arc_draw_dsc:
                                              *const lv_draw_line_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_canvas_draw_arc(canvas as *mut lv_obj_t, x as lv_coord_t,
                                   y as lv_coord_t, r as lv_coord_t,
                                   start_angle as i32, end_angle as i32,
                                   arc_draw_dsc as *const lv_draw_line_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Chart Widget API `lv_chart`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod chart {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_CHART_AXIS_TICK_LABEL_MAX_LEN: u32 = 256;
        pub const LV_CHART_TICK_LENGTH_AUTO: u32 = 255;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "< Don't draw the series"]
        pub const LV_CHART_TYPE_NONE: _bindgen_ty_33 = 0;
        #[doc = "< Connect the points with lines"]
        pub const LV_CHART_TYPE_LINE: _bindgen_ty_33 = 1;
        #[doc = "< Draw columns"]
        pub const LV_CHART_TYPE_COLUMN: _bindgen_ty_33 = 2;
        #[doc = "< X/Y chart, points and/or lines"]
        pub const LV_CHART_TYPE_SCATTER: _bindgen_ty_33 = 3;
        #[doc = " Chart types"]
        pub type _bindgen_ty_33 = u32;
        pub type lv_chart_type_t = u8;
        #[doc =
          "< Shift old data to the left and add the new one o the right"]
        pub const LV_CHART_UPDATE_MODE_SHIFT: _bindgen_ty_34 = 0;
        #[doc = "< Add the new data in a circular way"]
        pub const LV_CHART_UPDATE_MODE_CIRCULAR: _bindgen_ty_34 = 1;
        #[doc = " Chart update mode for `lv_chart_set_next`"]
        pub type _bindgen_ty_34 = u32;
        pub type lv_chart_update_mode_t = u8;
        pub const LV_CHART_AXIS_PRIMARY_Y: _bindgen_ty_35 = 0;
        pub const LV_CHART_AXIS_SECONDARY_Y: _bindgen_ty_35 = 1;
        pub const _LV_CHART_AXIS_LAST: _bindgen_ty_35 = 2;
        pub type _bindgen_ty_35 = u32;
        pub type lv_chart_axis_t = u8;
        #[repr(C)]
        pub struct lv_chart_series_t {
            pub points: *mut lv_coord_t,
            pub color: lv_color_t,
            pub start_point: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_chart_series_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_chart_series_t {
            #[inline]
            pub fn ext_buf_assigned(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ext_buf_assigned(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn y_axis(&self) -> lv_chart_axis_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_y_axis(&mut self, val: lv_chart_axis_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(ext_buf_assigned: u8,
                                  y_axis: lv_chart_axis_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let ext_buf_assigned: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ext_buf_assigned)
                                                    };
                                                ext_buf_assigned as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let y_axis: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(y_axis)
                                                    };
                                                y_axis as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "< don't draw the last tick"]
        pub const LV_CHART_AXIS_SKIP_LAST_TICK: _bindgen_ty_36 = 0;
        #[doc = "< draw the last tick"]
        pub const LV_CHART_AXIS_DRAW_LAST_TICK: _bindgen_ty_36 = 1;
        #[doc = "< draw tick labels in an inverted order"]
        pub const LV_CHART_AXIS_INVERSE_LABELS_ORDER: _bindgen_ty_36 = 2;
        #[doc = " Data of axis"]
        pub type _bindgen_ty_36 = u32;
        pub type lv_chart_axis_options_t = u8;
        #[repr(C)]
        pub struct lv_chart_axis_cfg_t {
            pub list_of_values: *const ::cty::c_char,
            pub options: lv_chart_axis_options_t,
            pub num_tick_marks: u8,
            pub major_tick_len: u8,
            pub minor_tick_len: u8,
        }
        impl Default for lv_chart_axis_cfg_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_chart_ext_t {
            pub series_ll: lv_ll_t,
            pub ymin: [lv_coord_t; 2usize],
            pub ymax: [lv_coord_t; 2usize],
            pub hdiv_cnt: u8,
            pub vdiv_cnt: u8,
            pub point_cnt: u16,
            pub style_series_bg: lv_style_list_t,
            pub style_series: lv_style_list_t,
            pub type_: lv_chart_type_t,
            pub y_axis: lv_chart_axis_cfg_t,
            pub x_axis: lv_chart_axis_cfg_t,
            pub secondary_y_axis: lv_chart_axis_cfg_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_chart_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_chart_ext_t {
            #[inline]
            pub fn update_mode(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_update_mode(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(update_mode: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let update_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(update_mode)
                                                    };
                                                update_mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_CHART_PART_BG: _bindgen_ty_37 = 0;
        pub const LV_CHART_PART_SERIES_BG: _bindgen_ty_37 = 1;
        pub const LV_CHART_PART_SERIES: _bindgen_ty_37 = 2;
        pub type _bindgen_ty_37 = u32;
        #[doc = " Create a chart background objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new chart background"]
        #[doc =
          " - __`copy`__: pointer to a chart background object, if not NULL then the new object will be copied"]
        #[doc = " from it"]
        #[doc = " Return: pointer to the created chart background"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a chart background objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new chart background"]
                #[doc =
                  " - __`copy`__: pointer to a chart background object, if not NULL then the new object will be copied"]
                #[doc = " from it"]
                #[doc = " Return: pointer to the created chart background"]
                pub fn lv_chart_create(par: *mut lv_obj_t,
                                       copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_create(par as *mut lv_obj_t,
                                    copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Allocate and add a data series to the chart"]
        #[doc = " - __`chart`__: pointer to a chart object"]
        #[doc = " - __`color`__: color of the data series"]
        #[doc = " Return: pointer to the allocated data series"]
        pub fn add_series(chart: *mut lv_obj_t, color: lv_color_t)
         -> MynewtResult<*mut lv_chart_series_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Allocate and add a data series to the chart"]
                #[doc = " - __`chart`__: pointer to a chart object"]
                #[doc = " - __`color`__: color of the data series"]
                #[doc = " Return: pointer to the allocated data series"]
                pub fn lv_chart_add_series(chart: *mut lv_obj_t,
                                           color: lv_color_t)
                -> *mut lv_chart_series_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_add_series(chart as *mut lv_obj_t,
                                        color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Clear the point of a series"]
        #[doc = " - __`chart`__: pointer to a chart object"]
        #[doc = " - __`series`__: pointer to the chart's series to clear"]
        pub fn clear_series(chart: *mut lv_obj_t,
                            series: *mut lv_chart_series_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Clear the point of a series"]
                #[doc = " - __`chart`__: pointer to a chart object"]
                #[doc =
                  " - __`series`__: pointer to the chart's series to clear"]
                pub fn lv_chart_clear_series(chart: *mut lv_obj_t,
                                             series: *mut lv_chart_series_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_clear_series(chart as *mut lv_obj_t,
                                      series as *mut lv_chart_series_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the number of horizontal and vertical division lines"]
        #[doc = " - __`chart`__: pointer to a graph background object"]
        #[doc = " - __`hdiv`__: number of horizontal division lines"]
        #[doc = " - __`vdiv`__: number of vertical division lines"]
        pub fn set_div_line_count(chart: *mut lv_obj_t, hdiv: u8, vdiv: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the number of horizontal and vertical division lines"]
                #[doc =
                  " - __`chart`__: pointer to a graph background object"]
                #[doc = " - __`hdiv`__: number of horizontal division lines"]
                #[doc = " - __`vdiv`__: number of vertical division lines"]
                pub fn lv_chart_set_div_line_count(chart: *mut lv_obj_t,
                                                   hdiv: u8, vdiv: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_div_line_count(chart as *mut lv_obj_t,
                                            hdiv as u8, vdiv as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the minimal and maximal y values on an axis"]
        #[doc = " - __`chart`__: pointer to a graph background object"]
        #[doc =
          " - __`axis`__: `LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`"]
        #[doc = " - __`ymin`__: y minimum value"]
        #[doc = " - __`ymax`__: y maximum value"]
        pub fn set_y_range(chart: *mut lv_obj_t, axis: lv_chart_axis_t,
                           ymin: lv_coord_t, ymax: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the minimal and maximal y values on an axis"]
                #[doc =
                  " - __`chart`__: pointer to a graph background object"]
                #[doc =
                  " - __`axis`__: `LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`"]
                #[doc = " - __`ymin`__: y minimum value"]
                #[doc = " - __`ymax`__: y maximum value"]
                pub fn lv_chart_set_y_range(chart: *mut lv_obj_t,
                                            axis: lv_chart_axis_t,
                                            ymin: lv_coord_t,
                                            ymax: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_y_range(chart as *mut lv_obj_t,
                                     axis as lv_chart_axis_t,
                                     ymin as lv_coord_t, ymax as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new type for a chart"]
        #[doc = " - __`chart`__: pointer to a chart object"]
        #[doc =
          " - __`type`__: new type of the chart (from 'lv_chart_type_t' enum)"]
        pub fn set_type(chart: *mut lv_obj_t, type_: lv_chart_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new type for a chart"]
                #[doc = " - __`chart`__: pointer to a chart object"]
                #[doc =
                  " - __`type`__: new type of the chart (from 'lv_chart_type_t' enum)"]
                pub fn lv_chart_set_type(chart: *mut lv_obj_t,
                                         type_: lv_chart_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_type(chart as *mut lv_obj_t,
                                  type_ as lv_chart_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the number of points on a data line on a chart"]
        #[doc = " - __`chart`__: pointer r to chart object"]
        #[doc = " - __`point_cnt`__: new number of points on the data lines"]
        pub fn set_point_count(chart: *mut lv_obj_t, point_cnt: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the number of points on a data line on a chart"]
                #[doc = " - __`chart`__: pointer r to chart object"]
                #[doc =
                  " - __`point_cnt`__: new number of points on the data lines"]
                pub fn lv_chart_set_point_count(chart: *mut lv_obj_t,
                                                point_cnt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_point_count(chart as *mut lv_obj_t,
                                         point_cnt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Initialize all data points with a value"]
        #[doc = " - __`chart`__: pointer to chart object"]
        #[doc = " - __`ser`__: pointer to a data series on 'chart'"]
        #[doc = " - __`y`__: the new value  for all points"]
        pub fn init_points(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t,
                           y: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Initialize all data points with a value"]
                #[doc = " - __`chart`__: pointer to chart object"]
                #[doc = " - __`ser`__: pointer to a data series on 'chart'"]
                #[doc = " - __`y`__: the new value  for all points"]
                pub fn lv_chart_init_points(chart: *mut lv_obj_t,
                                            ser: *mut lv_chart_series_t,
                                            y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_init_points(chart as *mut lv_obj_t,
                                     ser as *mut lv_chart_series_t,
                                     y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the value of points from an array"]
        #[doc = " - __`chart`__: pointer to chart object"]
        #[doc = " - __`ser`__: pointer to a data series on 'chart'"]
        #[doc =
          " - __`y_array`__: array of 'lv_coord_t' points (with 'points count' elements )"]
        pub fn set_points(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t,
                          y_array: *mut lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the value of points from an array"]
                #[doc = " - __`chart`__: pointer to chart object"]
                #[doc = " - __`ser`__: pointer to a data series on 'chart'"]
                #[doc =
                  " - __`y_array`__: array of 'lv_coord_t' points (with 'points count' elements )"]
                pub fn lv_chart_set_points(chart: *mut lv_obj_t,
                                           ser: *mut lv_chart_series_t,
                                           y_array: *mut lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_points(chart as *mut lv_obj_t,
                                    ser as *mut lv_chart_series_t,
                                    y_array as *mut lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Shift all data right and set the most right data on a data line"]
        #[doc = " - __`chart`__: pointer to chart object"]
        #[doc = " - __`ser`__: pointer to a data series on 'chart'"]
        #[doc = " - __`y`__: the new value of the most right data"]
        pub fn set_next(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t,
                        y: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Shift all data right and set the most right data on a data line"]
                #[doc = " - __`chart`__: pointer to chart object"]
                #[doc = " - __`ser`__: pointer to a data series on 'chart'"]
                #[doc = " - __`y`__: the new value of the most right data"]
                pub fn lv_chart_set_next(chart: *mut lv_obj_t,
                                         ser: *mut lv_chart_series_t,
                                         y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_next(chart as *mut lv_obj_t,
                                  ser as *mut lv_chart_series_t,
                                  y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set update mode of the chart object."]
        #[doc = " - __`chart`__: pointer to a chart object"]
        #[doc = " - __`update`__: mode"]
        pub fn set_update_mode(chart: *mut lv_obj_t,
                               update_mode: lv_chart_update_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set update mode of the chart object."]
                #[doc = " - __`chart`__: pointer to a chart object"]
                #[doc = " - __`update`__: mode"]
                pub fn lv_chart_set_update_mode(chart: *mut lv_obj_t,
                                                update_mode:
                                                    lv_chart_update_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_update_mode(chart as *mut lv_obj_t,
                                         update_mode as
                                             lv_chart_update_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the length of the tick marks on the x axis"]
        #[doc = " - __`chart`__: pointer to the chart"]
        #[doc =
          " - __`major_tick_len`__: the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
        #[doc = "                       (where labels are added)"]
        #[doc =
          " - __`minor_tick_len`__: the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
        #[doc = "                       (where no labels are added)"]
        pub fn set_x_tick_length(chart: *mut lv_obj_t, major_tick_len: u8,
                                 minor_tick_len: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the length of the tick marks on the x axis"]
                #[doc = " - __`chart`__: pointer to the chart"]
                #[doc =
                  " - __`major_tick_len`__: the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
                #[doc = "                       (where labels are added)"]
                #[doc =
                  " - __`minor_tick_len`__: the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
                #[doc = "                       (where no labels are added)"]
                pub fn lv_chart_set_x_tick_length(chart: *mut lv_obj_t,
                                                  major_tick_len: u8,
                                                  minor_tick_len: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_x_tick_length(chart as *mut lv_obj_t,
                                           major_tick_len as u8,
                                           minor_tick_len as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the length of the tick marks on the y axis"]
        #[doc = " - __`chart`__: pointer to the chart"]
        #[doc =
          " - __`major_tick_len`__: the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
        #[doc = "                       (where labels are added)"]
        #[doc =
          " - __`minor_tick_len`__: the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
        #[doc = "                       (where no labels are added)"]
        pub fn set_y_tick_length(chart: *mut lv_obj_t, major_tick_len: u8,
                                 minor_tick_len: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the length of the tick marks on the y axis"]
                #[doc = " - __`chart`__: pointer to the chart"]
                #[doc =
                  " - __`major_tick_len`__: the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
                #[doc = "                       (where labels are added)"]
                #[doc =
                  " - __`minor_tick_len`__: the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
                #[doc = "                       (where no labels are added)"]
                pub fn lv_chart_set_y_tick_length(chart: *mut lv_obj_t,
                                                  major_tick_len: u8,
                                                  minor_tick_len: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_y_tick_length(chart as *mut lv_obj_t,
                                           major_tick_len as u8,
                                           minor_tick_len as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the length of the tick marks on the secondary y axis"]
        #[doc = " - __`chart`__: pointer to the chart"]
        #[doc =
          " - __`major_tick_len`__: the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
        #[doc = "                       (where labels are added)"]
        #[doc =
          " - __`minor_tick_len`__: the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
        #[doc = "                       (where no labels are added)"]
        pub fn set_secondary_y_tick_length(chart: *mut lv_obj_t,
                                           major_tick_len: u8,
                                           minor_tick_len: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the length of the tick marks on the secondary y axis"]
                #[doc = " - __`chart`__: pointer to the chart"]
                #[doc =
                  " - __`major_tick_len`__: the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
                #[doc = "                       (where labels are added)"]
                #[doc =
                  " - __`minor_tick_len`__: the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
                #[doc = "                       (where no labels are added)"]
                pub fn lv_chart_set_secondary_y_tick_length(chart:
                                                                *mut lv_obj_t,
                                                            major_tick_len:
                                                                u8,
                                                            minor_tick_len:
                                                                u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_secondary_y_tick_length(chart as *mut lv_obj_t,
                                                     major_tick_len as u8,
                                                     minor_tick_len as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the x-axis tick count and labels of a chart"]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`list_of_values`__:    list of string values, terminated with \\n, except the last"]
        #[doc =
          " - __`num_tick_marks`__:    if list_of_values is NULL: total number of ticks per axis"]
        #[doc =
          "                          else number of ticks between two value labels"]
        #[doc = " - __`options`__:           extra options"]
        pub fn set_x_tick_texts(chart: *mut lv_obj_t, list_of_values: &Strn,
                                num_tick_marks: u8,
                                options: lv_chart_axis_options_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the x-axis tick count and labels of a chart"]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`list_of_values`__:    list of string values, terminated with \\n, except the last"]
                #[doc =
                  " - __`num_tick_marks`__:    if list_of_values is NULL: total number of ticks per axis"]
                #[doc =
                  "                          else number of ticks between two value labels"]
                #[doc = " - __`options`__:           extra options"]
                pub fn lv_chart_set_x_tick_texts(chart: *mut lv_obj_t,
                                                 list_of_values:
                                                     *const ::cty::c_char,
                                                 num_tick_marks: u8,
                                                 options:
                                                     lv_chart_axis_options_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            list_of_values.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_x_tick_texts(chart as *mut lv_obj_t,
                                          list_of_values.as_ptr() as
                                              *const ::cty::c_char,
                                          num_tick_marks as u8,
                                          options as lv_chart_axis_options_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the secondary y-axis tick count and labels of a chart"]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`list_of_values`__:    list of string values, terminated with \\n, except the last"]
        #[doc =
          " - __`num_tick_marks`__:    if list_of_values is NULL: total number of ticks per axis"]
        #[doc =
          "                          else number of ticks between two value labels"]
        #[doc = " - __`options`__:           extra options"]
        pub fn set_secondary_y_tick_texts(chart: *mut lv_obj_t,
                                          list_of_values: &Strn,
                                          num_tick_marks: u8,
                                          options: lv_chart_axis_options_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the secondary y-axis tick count and labels of a chart"]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`list_of_values`__:    list of string values, terminated with \\n, except the last"]
                #[doc =
                  " - __`num_tick_marks`__:    if list_of_values is NULL: total number of ticks per axis"]
                #[doc =
                  "                          else number of ticks between two value labels"]
                #[doc = " - __`options`__:           extra options"]
                pub fn lv_chart_set_secondary_y_tick_texts(chart:
                                                               *mut lv_obj_t,
                                                           list_of_values:
                                                               *const ::cty::c_char,
                                                           num_tick_marks: u8,
                                                           options:
                                                               lv_chart_axis_options_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            list_of_values.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_secondary_y_tick_texts(chart as *mut lv_obj_t,
                                                    list_of_values.as_ptr() as
                                                        *const ::cty::c_char,
                                                    num_tick_marks as u8,
                                                    options as
                                                        lv_chart_axis_options_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the y-axis tick count and labels of a chart"]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`list_of_values`__:    list of string values, terminated with \\n, except the last"]
        #[doc =
          " - __`num_tick_marks`__:    if list_of_values is NULL: total number of ticks per axis"]
        #[doc =
          "                          else number of ticks between two value labels"]
        #[doc = " - __`options`__:           extra options"]
        pub fn set_y_tick_texts(chart: *mut lv_obj_t, list_of_values: &Strn,
                                num_tick_marks: u8,
                                options: lv_chart_axis_options_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the y-axis tick count and labels of a chart"]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`list_of_values`__:    list of string values, terminated with \\n, except the last"]
                #[doc =
                  " - __`num_tick_marks`__:    if list_of_values is NULL: total number of ticks per axis"]
                #[doc =
                  "                          else number of ticks between two value labels"]
                #[doc = " - __`options`__:           extra options"]
                pub fn lv_chart_set_y_tick_texts(chart: *mut lv_obj_t,
                                                 list_of_values:
                                                     *const ::cty::c_char,
                                                 num_tick_marks: u8,
                                                 options:
                                                     lv_chart_axis_options_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            list_of_values.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_y_tick_texts(chart as *mut lv_obj_t,
                                          list_of_values.as_ptr() as
                                              *const ::cty::c_char,
                                          num_tick_marks as u8,
                                          options as lv_chart_axis_options_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the index of the x-axis start point in the data array"]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`ser`__:               pointer to a data series on 'chart'"]
        #[doc =
          " - __`id`__:                the index of the x point in the data array"]
        pub fn set_x_start_point(chart: *mut lv_obj_t,
                                 ser: *mut lv_chart_series_t, id: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the index of the x-axis start point in the data array"]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`ser`__:               pointer to a data series on 'chart'"]
                #[doc =
                  " - __`id`__:                the index of the x point in the data array"]
                pub fn lv_chart_set_x_start_point(chart: *mut lv_obj_t,
                                                  ser: *mut lv_chart_series_t,
                                                  id: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_x_start_point(chart as *mut lv_obj_t,
                                           ser as *mut lv_chart_series_t,
                                           id as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set an external array of data points to use for the chart"]
        #[doc =
          " NOTE: It is the users responsibility to make sure the point_cnt matches the external array size."]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`ser`__:               pointer to a data series on 'chart'"]
        #[doc =
          " - __`array`__:             external array of points for chart"]
        pub fn set_ext_array(chart: *mut lv_obj_t,
                             ser: *mut lv_chart_series_t,
                             array: *mut lv_coord_t, point_cnt: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set an external array of data points to use for the chart"]
                #[doc =
                  " NOTE: It is the users responsibility to make sure the point_cnt matches the external array size."]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`ser`__:               pointer to a data series on 'chart'"]
                #[doc =
                  " - __`array`__:             external array of points for chart"]
                pub fn lv_chart_set_ext_array(chart: *mut lv_obj_t,
                                              ser: *mut lv_chart_series_t,
                                              array: *mut lv_coord_t,
                                              point_cnt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_ext_array(chart as *mut lv_obj_t,
                                       ser as *mut lv_chart_series_t,
                                       array as *mut lv_coord_t,
                                       point_cnt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set an individual point value in the chart series directly based on index"]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`ser`__:               pointer to a data series on 'chart'"]
        #[doc = " - __`value`__:             value to assign to array point"]
        #[doc =
          " - __`id`__:                the index of the x point in the array"]
        pub fn set_point_id(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t,
                            value: lv_coord_t, id: u16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set an individual point value in the chart series directly based on index"]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`ser`__:               pointer to a data series on 'chart'"]
                #[doc =
                  " - __`value`__:             value to assign to array point"]
                #[doc =
                  " - __`id`__:                the index of the x point in the array"]
                pub fn lv_chart_set_point_id(chart: *mut lv_obj_t,
                                             ser: *mut lv_chart_series_t,
                                             value: lv_coord_t, id: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_point_id(chart as *mut lv_obj_t,
                                      ser as *mut lv_chart_series_t,
                                      value as lv_coord_t, id as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the Y axis of a series"]
        #[doc = " - __`chart`__: pointer to a chart object"]
        #[doc = " - __`ser`__: pointer to series"]
        #[doc =
          " - __`axis`__: `LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`"]
        pub fn set_series_axis(chart: *mut lv_obj_t,
                               ser: *mut lv_chart_series_t,
                               axis: lv_chart_axis_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the Y axis of a series"]
                #[doc = " - __`chart`__: pointer to a chart object"]
                #[doc = " - __`ser`__: pointer to series"]
                #[doc =
                  " - __`axis`__: `LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`"]
                pub fn lv_chart_set_series_axis(chart: *mut lv_obj_t,
                                                ser: *mut lv_chart_series_t,
                                                axis: lv_chart_axis_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_set_series_axis(chart as *mut lv_obj_t,
                                         ser as *mut lv_chart_series_t,
                                         axis as lv_chart_axis_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the type of a chart"]
        #[doc = " - __`chart`__: pointer to chart object"]
        #[doc = " Return: type of the chart (from 'lv_chart_t' enum)"]
        pub fn get_type(chart: *const lv_obj_t)
         -> MynewtResult<lv_chart_type_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the type of a chart"]
                #[doc = " - __`chart`__: pointer to chart object"]
                #[doc = " Return: type of the chart (from 'lv_chart_t' enum)"]
                pub fn lv_chart_get_type(chart: *const lv_obj_t)
                -> lv_chart_type_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_get_type(chart as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the data point number per data line on chart"]
        #[doc = " - __`chart`__: pointer to chart object"]
        #[doc = " Return: point number on each data line"]
        pub fn get_point_count(chart: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the data point number per data line on chart"]
                #[doc = " - __`chart`__: pointer to chart object"]
                #[doc = " Return: point number on each data line"]
                pub fn lv_chart_get_point_count(chart: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_get_point_count(chart as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " get the current index of the x-axis start point in the data array"]
        #[doc =
          " - __`ser`__:               pointer to a data series on 'chart'"]
        #[doc =
          " Return:                  the index of the current x start point in the data array"]
        pub fn get_x_start_point(ser: *mut lv_chart_series_t)
         -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " get the current index of the x-axis start point in the data array"]
                #[doc =
                  " - __`ser`__:               pointer to a data series on 'chart'"]
                #[doc =
                  " Return:                  the index of the current x start point in the data array"]
                pub fn lv_chart_get_x_start_point(ser: *mut lv_chart_series_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_get_x_start_point(ser as *mut lv_chart_series_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get an individual point value in the chart series directly based on index"]
        #[doc = " - __`chart`__:             pointer to a chart object"]
        #[doc =
          " - __`ser`__:               pointer to a data series on 'chart'"]
        #[doc =
          " - __`id`__:                the index of the x point in the array"]
        #[doc = " Return:                  value of array point at index id"]
        pub fn get_point_id(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t,
                            id: u16) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get an individual point value in the chart series directly based on index"]
                #[doc =
                  " - __`chart`__:             pointer to a chart object"]
                #[doc =
                  " - __`ser`__:               pointer to a data series on 'chart'"]
                #[doc =
                  " - __`id`__:                the index of the x point in the array"]
                #[doc =
                  " Return:                  value of array point at index id"]
                pub fn lv_chart_get_point_id(chart: *mut lv_obj_t,
                                             ser: *mut lv_chart_series_t,
                                             id: u16)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_get_point_id(chart as *mut lv_obj_t,
                                          ser as *mut lv_chart_series_t,
                                          id as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the Y axis of a series"]
        #[doc = " - __`chart`__: pointer to a chart object"]
        #[doc = " - __`ser`__: pointer to series"]
        #[doc =
          " Return: `LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`"]
        pub fn get_series_axis(chart: *mut lv_obj_t,
                               ser: *mut lv_chart_series_t)
         -> MynewtResult<lv_chart_axis_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the Y axis of a series"]
                #[doc = " - __`chart`__: pointer to a chart object"]
                #[doc = " - __`ser`__: pointer to series"]
                #[doc =
                  " Return: `LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`"]
                pub fn lv_chart_get_series_axis(chart: *mut lv_obj_t,
                                                ser: *mut lv_chart_series_t)
                -> lv_chart_axis_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_chart_get_series_axis(chart as *mut lv_obj_t,
                                             ser as *mut lv_chart_series_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Refresh a chart if its data line has changed"]
        #[doc = " - __`chart`__: pointer to chart object"]
        pub fn refresh(chart: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Refresh a chart if its data line has changed"]
                #[doc = " - __`chart`__: pointer to chart object"]
                pub fn lv_chart_refresh(chart: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_chart_refresh(chart as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Checkbox Widget API `lv_checkbox`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod checkbox {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_btn_state_t = u8;
        #[doc = " Extended data of button"]
        #[repr(C)]
        pub struct lv_btn_ext_t {
            #[doc = " Ext. of ancestor"]
            pub cont: lv_cont_ext_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_btn_ext_t {
            #[inline]
            fn default() -> lv_btn_ext_t {
                lv_btn_ext_t{cont: ::core::default::Default::default(),
                             _bitfield_1:
                                 ::core::default::Default::default(),}
            }
        }
        impl lv_btn_ext_t {
            #[inline]
            pub fn checkable(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_checkable(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(checkable: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let checkable: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(checkable)
                                                    };
                                                checkable as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_checkbox_ext_t {
            pub bg_btn: lv_btn_ext_t,
            pub bullet: *mut lv_obj_t,
            pub label: *mut lv_obj_t,
        }
        impl Default for lv_checkbox_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "< Style of object background."]
        pub const LV_CHECKBOX_PART_BG: _bindgen_ty_41 = 0;
        pub const _LV_CHECKBOX_PART_VIRTUAL_LAST: _bindgen_ty_41 = 1;
        #[doc = "< Style of box (released)."]
        pub const LV_CHECKBOX_PART_BULLET: _bindgen_ty_41 = 64;
        pub const _LV_CHECKBOX_PART_REAL_LAST: _bindgen_ty_41 = 65;
        #[doc = " Checkbox styles."]
        pub type _bindgen_ty_41 = u32;
        pub type lv_checkbox_style_t = u8;
        #[doc = " Create a check box objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new check box"]
        #[doc =
          " - __`copy`__: pointer to a check box object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created check box"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a check box objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new check box"]
                #[doc =
                  " - __`copy`__: pointer to a check box object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created check box"]
                pub fn lv_checkbox_create(par: *mut lv_obj_t,
                                          copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_checkbox_create(par as *mut lv_obj_t,
                                       copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set the text of a check box. `txt` will be copied and may be deallocated"]
        #[doc = " after this function returns."]
        #[doc = " - __`cb`__: pointer to a check box"]
        #[doc =
          " - __`txt`__: the text of the check box. NULL to refresh with the current text."]
        pub fn set_text(cb: *mut lv_obj_t, txt: &Strn) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the text of a check box. `txt` will be copied and may be deallocated"]
                #[doc = " after this function returns."]
                #[doc = " - __`cb`__: pointer to a check box"]
                #[doc =
                  " - __`txt`__: the text of the check box. NULL to refresh with the current text."]
                pub fn lv_checkbox_set_text(cb: *mut lv_obj_t,
                                            txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_checkbox_set_text(cb as *mut lv_obj_t,
                                     txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the text of a check box. `txt` must not be deallocated during the life"]
        #[doc = " of this checkbox."]
        #[doc = " - __`cb`__: pointer to a check box"]
        #[doc =
          " - __`txt`__: the text of the check box. NULL to refresh with the current text."]
        pub fn set_text_static(cb: *mut lv_obj_t, txt: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the text of a check box. `txt` must not be deallocated during the life"]
                #[doc = " of this checkbox."]
                #[doc = " - __`cb`__: pointer to a check box"]
                #[doc =
                  " - __`txt`__: the text of the check box. NULL to refresh with the current text."]
                pub fn lv_checkbox_set_text_static(cb: *mut lv_obj_t,
                                                   txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_checkbox_set_text_static(cb as *mut lv_obj_t,
                                            txt.as_ptr() as
                                                *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the state of the check box"]
        #[doc = " - __`cb`__: pointer to a check box object"]
        #[doc =
          " - __`checked`__: true: make the check box checked; false: make it unchecked"]
        pub fn set_checked(cb: *mut lv_obj_t, checked: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the state of the check box"]
                #[doc = " - __`cb`__: pointer to a check box object"]
                #[doc =
                  " - __`checked`__: true: make the check box checked; false: make it unchecked"]
                pub fn lv_checkbox_set_checked(cb: *mut lv_obj_t,
                                               checked: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_checkbox_set_checked(cb as *mut lv_obj_t, checked as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Make the check box inactive (disabled)"]
        #[doc = " - __`cb`__: pointer to a check box object"]
        pub fn set_disabled(cb: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make the check box inactive (disabled)"]
                #[doc = " - __`cb`__: pointer to a check box object"]
                pub fn lv_checkbox_set_disabled(cb: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_checkbox_set_disabled(cb as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the state of a check box"]
        #[doc = " - __`cb`__: pointer to a check box object"]
        #[doc =
          " - __`state`__: the new state of the check box (from lv_btn_state_t enum)"]
        pub fn set_state(cb: *mut lv_obj_t, state: lv_btn_state_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the state of a check box"]
                #[doc = " - __`cb`__: pointer to a check box object"]
                #[doc =
                  " - __`state`__: the new state of the check box (from lv_btn_state_t enum)"]
                pub fn lv_checkbox_set_state(cb: *mut lv_obj_t,
                                             state: lv_btn_state_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_checkbox_set_state(cb as *mut lv_obj_t,
                                      state as lv_btn_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the current state of the check box"]
        #[doc = " - __`cb`__: pointer to a check box object"]
        #[doc = " Return: true: checked; false: not checked"]
        pub fn is_checked(cb: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current state of the check box"]
                #[doc = " - __`cb`__: pointer to a check box object"]
                #[doc = " Return: true: checked; false: not checked"]
                pub fn lv_checkbox_is_checked(cb: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_checkbox_is_checked(cb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether the check box is inactive or not."]
        #[doc = " - __`cb`__: pointer to a check box object"]
        #[doc = " Return: true: inactive; false: not inactive"]
        pub fn is_inactive(cb: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether the check box is inactive or not."]
                #[doc = " - __`cb`__: pointer to a check box object"]
                #[doc = " Return: true: inactive; false: not inactive"]
                pub fn lv_checkbox_is_inactive(cb: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_checkbox_is_inactive(cb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current state of a check box"]
        #[doc = " - __`cb`__: pointer to a check box object"]
        #[doc =
          " Return: the state of the check box (from lv_btn_state_t enum)"]
        pub fn get_state(cb: *const lv_obj_t)
         -> MynewtResult<lv_btn_state_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current state of a check box"]
                #[doc = " - __`cb`__: pointer to a check box object"]
                #[doc =
                  " Return: the state of the check box (from lv_btn_state_t enum)"]
                pub fn lv_checkbox_get_state(cb: *const lv_obj_t)
                -> lv_btn_state_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_checkbox_get_state(cb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Cont Widget API `lv_cont`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod cont {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_CONT_PART_MAIN: _bindgen_ty_34 = 0;
        pub const _LV_CONT_PART_VIRTUAL_LAST: _bindgen_ty_34 = 1;
        pub const _LV_CONT_PART_REAL_LAST: _bindgen_ty_34 = 64;
        pub type _bindgen_ty_34 = u32;
        #[doc = " Create a container objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new container"]
        #[doc =
          " - __`copy`__: pointer to a container object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created container"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a container objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new container"]
                #[doc =
                  " - __`copy`__: pointer to a container object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created container"]
                pub fn lv_cont_create(par: *mut lv_obj_t,
                                      copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cont_create(par as *mut lv_obj_t,
                                   copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a layout on a container"]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " - __`layout`__: a layout from 'lv_cont_layout_t'"]
        pub fn set_layout(cont: *mut lv_obj_t, layout: lv_layout_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a layout on a container"]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " - __`layout`__: a layout from 'lv_cont_layout_t'"]
                pub fn lv_cont_set_layout(cont: *mut lv_obj_t,
                                          layout: lv_layout_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cont_set_layout(cont as *mut lv_obj_t,
                                   layout as lv_layout_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy in all 4 directions separately."]
        #[doc = " It tell how to change the container's size automatically."]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " - __`left`__: left fit policy from `lv_fit_t`"]
        #[doc = " - __`right`__: right fit policy from `lv_fit_t`"]
        #[doc = " - __`top`__: top fit policy from `lv_fit_t`"]
        #[doc = " - __`bottom`__: bottom fit policy from `lv_fit_t`"]
        pub fn set_fit4(cont: *mut lv_obj_t, left: lv_fit_t, right: lv_fit_t,
                        top: lv_fit_t, bottom: lv_fit_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the fit policy in all 4 directions separately."]
                #[doc =
                  " It tell how to change the container's size automatically."]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " - __`left`__: left fit policy from `lv_fit_t`"]
                #[doc = " - __`right`__: right fit policy from `lv_fit_t`"]
                #[doc = " - __`top`__: top fit policy from `lv_fit_t`"]
                #[doc = " - __`bottom`__: bottom fit policy from `lv_fit_t`"]
                pub fn lv_cont_set_fit4(cont: *mut lv_obj_t, left: lv_fit_t,
                                        right: lv_fit_t, top: lv_fit_t,
                                        bottom: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cont_set_fit4(cont as *mut lv_obj_t, left as lv_fit_t,
                                 right as lv_fit_t, top as lv_fit_t,
                                 bottom as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy horizontally and vertically separately."]
        #[doc = " It tells how to change the container's size automatically."]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " - __`hor`__: horizontal fit policy from `lv_fit_t`"]
        #[doc = " - __`ver`__: vertical fit policy from `lv_fit_t`"]
        pub fn set_fit2(cont: *mut lv_obj_t, hor: lv_fit_t, ver: lv_fit_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the fit policy horizontally and vertically separately."]
                #[doc =
                  " It tells how to change the container's size automatically."]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " - __`hor`__: horizontal fit policy from `lv_fit_t`"]
                #[doc = " - __`ver`__: vertical fit policy from `lv_fit_t`"]
                pub fn lv_cont_set_fit2(cont: *mut lv_obj_t, hor: lv_fit_t,
                                        ver: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cont_set_fit2(cont as *mut lv_obj_t, hor as lv_fit_t,
                                 ver as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy in all 4 direction at once."]
        #[doc = " It tells how to change the container's size automatically."]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " - __`fit`__: fit policy from `lv_fit_t`"]
        pub fn set_fit(cont: *mut lv_obj_t, fit: lv_fit_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the fit policy in all 4 direction at once."]
                #[doc =
                  " It tells how to change the container's size automatically."]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " - __`fit`__: fit policy from `lv_fit_t`"]
                pub fn lv_cont_set_fit(cont: *mut lv_obj_t, fit: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cont_set_fit(cont as *mut lv_obj_t, fit as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the layout of a container"]
        #[doc = " - __`cont`__: pointer to container object"]
        #[doc = " Return: the layout from 'lv_cont_layout_t'"]
        pub fn get_layout(cont: *const lv_obj_t)
         -> MynewtResult<lv_layout_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the layout of a container"]
                #[doc = " - __`cont`__: pointer to container object"]
                #[doc = " Return: the layout from 'lv_cont_layout_t'"]
                pub fn lv_cont_get_layout(cont: *const lv_obj_t)
                -> lv_layout_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cont_get_layout(cont as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get left fit mode of a container"]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_left(cont: *const lv_obj_t) -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get left fit mode of a container"]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_cont_get_fit_left(cont: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cont_get_fit_left(cont as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get right fit mode of a container"]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_right(cont: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get right fit mode of a container"]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_cont_get_fit_right(cont: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cont_get_fit_right(cont as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get top fit mode of a container"]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_top(cont: *const lv_obj_t) -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get top fit mode of a container"]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_cont_get_fit_top(cont: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cont_get_fit_top(cont as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get bottom fit mode of a container"]
        #[doc = " - __`cont`__: pointer to a container object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_fit_bottom(cont: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get bottom fit mode of a container"]
                #[doc = " - __`cont`__: pointer to a container object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_cont_get_fit_bottom(cont: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cont_get_fit_bottom(cont as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL CPicker Widget API `lv_cpicker`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod cpicker {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[repr(C)]
        pub struct lv_color_hsv_t {
            pub h: u16,
            pub s: u8,
            pub v: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color_hsv_t {
            #[inline]
            fn default() -> lv_color_hsv_t {
                lv_color_hsv_t{h: ::core::default::Default::default(),
                               s: ::core::default::Default::default(),
                               v: ::core::default::Default::default(),}
            }
        }
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_CPICKER_TYPE_RECT: _bindgen_ty_32 = 0;
        pub const LV_CPICKER_TYPE_DISC: _bindgen_ty_32 = 1;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_32 = u32;
        pub type lv_cpicker_type_t = u8;
        pub const LV_CPICKER_COLOR_MODE_HUE: _bindgen_ty_33 = 0;
        pub const LV_CPICKER_COLOR_MODE_SATURATION: _bindgen_ty_33 = 1;
        pub const LV_CPICKER_COLOR_MODE_VALUE: _bindgen_ty_33 = 2;
        pub type _bindgen_ty_33 = u32;
        pub type lv_cpicker_color_mode_t = u8;
        #[repr(C)]
        pub struct lv_cpicker_ext_t {
            pub hsv: lv_color_hsv_t,
            pub knob: lv_cpicker_ext_t__bindgen_ty_1,
            pub last_click_time: u32,
            pub last_change_time: u32,
            pub last_press_point: lv_point_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[repr(C)]
        pub struct lv_cpicker_ext_t__bindgen_ty_1 {
            pub style_list: lv_style_list_t,
            pub pos: lv_point_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_cpicker_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_cpicker_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn colored(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_colored(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(colored: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let colored: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(colored)
                                                    };
                                                colored as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_cpicker_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_cpicker_ext_t {
            #[inline]
            pub fn color_mode(&self) -> lv_cpicker_color_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_color_mode(&mut self, val: lv_cpicker_color_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn color_mode_fixed(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_color_mode_fixed(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn type_(&self) -> lv_cpicker_type_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: lv_cpicker_type_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(color_mode: lv_cpicker_color_mode_t,
                                  color_mode_fixed: u8,
                                  type_: lv_cpicker_type_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let color_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(color_mode)
                                                    };
                                                color_mode as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let color_mode_fixed: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(color_mode_fixed)
                                                    };
                                                color_mode_fixed as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let type_: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_CPICKER_PART_MAIN: _bindgen_ty_34 = 0;
        pub const LV_CPICKER_PART_KNOB: _bindgen_ty_34 = 1;
        pub const _LV_CPICKER_PART_VIRTUAL_LAST: _bindgen_ty_34 = 2;
        pub const _LV_CPICKER_PART_REAL_LAST: _bindgen_ty_34 = 64;
        pub type _bindgen_ty_34 = u32;
        #[doc = " Create a colorpicker objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new colorpicker"]
        #[doc =
          " - __`copy`__: pointer to a colorpicker object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created colorpicker"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a colorpicker objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new colorpicker"]
                #[doc =
                  " - __`copy`__: pointer to a colorpicker object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created colorpicker"]
                pub fn lv_cpicker_create(par: *mut lv_obj_t,
                                         copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_create(par as *mut lv_obj_t,
                                      copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a new type for a colorpicker"]
        #[doc = " - __`cpicker`__: pointer to a colorpicker object"]
        #[doc =
          " - __`type`__: new type of the colorpicker (from 'lv_cpicker_type_t' enum)"]
        pub fn set_type(cpicker: *mut lv_obj_t, type_: lv_cpicker_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new type for a colorpicker"]
                #[doc = " - __`cpicker`__: pointer to a colorpicker object"]
                #[doc =
                  " - __`type`__: new type of the colorpicker (from 'lv_cpicker_type_t' enum)"]
                pub fn lv_cpicker_set_type(cpicker: *mut lv_obj_t,
                                           type_: lv_cpicker_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cpicker_set_type(cpicker as *mut lv_obj_t,
                                    type_ as lv_cpicker_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the current hue of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`hue`__: current selected hue [0..360]"]
        #[doc = " Return: true if changed, otherwise false"]
        pub fn set_hue(cpicker: *mut lv_obj_t, hue: u16)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the current hue of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " - __`hue`__: current selected hue [0..360]"]
                #[doc = " Return: true if changed, otherwise false"]
                pub fn lv_cpicker_set_hue(cpicker: *mut lv_obj_t, hue: u16)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_set_hue(cpicker as *mut lv_obj_t, hue as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the current saturation of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`saturation`__: current selected saturation [0..100]"]
        #[doc = " Return: true if changed, otherwise false"]
        pub fn set_saturation(cpicker: *mut lv_obj_t, saturation: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the current saturation of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc =
                  " - __`saturation`__: current selected saturation [0..100]"]
                #[doc = " Return: true if changed, otherwise false"]
                pub fn lv_cpicker_set_saturation(cpicker: *mut lv_obj_t,
                                                 saturation: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_set_saturation(cpicker as *mut lv_obj_t,
                                              saturation as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the current value of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`val`__: current selected value [0..100]"]
        #[doc = " Return: true if changed, otherwise false"]
        pub fn set_value(cpicker: *mut lv_obj_t, val: u8)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the current value of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " - __`val`__: current selected value [0..100]"]
                #[doc = " Return: true if changed, otherwise false"]
                pub fn lv_cpicker_set_value(cpicker: *mut lv_obj_t, val: u8)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_set_value(cpicker as *mut lv_obj_t, val as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the current hsv of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`hsv`__: current selected hsv"]
        #[doc = " Return: true if changed, otherwise false"]
        pub fn set_hsv(cpicker: *mut lv_obj_t, hsv: lv_color_hsv_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the current hsv of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " - __`hsv`__: current selected hsv"]
                #[doc = " Return: true if changed, otherwise false"]
                pub fn lv_cpicker_set_hsv(cpicker: *mut lv_obj_t,
                                          hsv: lv_color_hsv_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_set_hsv(cpicker as *mut lv_obj_t,
                                       hsv as lv_color_hsv_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the current color of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`color`__: current selected color"]
        #[doc = " Return: true if changed, otherwise false"]
        pub fn set_color(cpicker: *mut lv_obj_t, color: lv_color_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the current color of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " - __`color`__: current selected color"]
                #[doc = " Return: true if changed, otherwise false"]
                pub fn lv_cpicker_set_color(cpicker: *mut lv_obj_t,
                                            color: lv_color_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_set_color(cpicker as *mut lv_obj_t,
                                         color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the current color mode."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`mode`__: color mode (hue/sat/val)"]
        pub fn set_color_mode(cpicker: *mut lv_obj_t,
                              mode: lv_cpicker_color_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the current color mode."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " - __`mode`__: color mode (hue/sat/val)"]
                pub fn lv_cpicker_set_color_mode(cpicker: *mut lv_obj_t,
                                                 mode:
                                                     lv_cpicker_color_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cpicker_set_color_mode(cpicker as *mut lv_obj_t,
                                          mode as lv_cpicker_color_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set if the color mode is changed on long press on center"]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " - __`fixed`__: color mode cannot be changed on long press"]
        pub fn set_color_mode_fixed(cpicker: *mut lv_obj_t, fixed: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set if the color mode is changed on long press on center"]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc =
                  " - __`fixed`__: color mode cannot be changed on long press"]
                pub fn lv_cpicker_set_color_mode_fixed(cpicker: *mut lv_obj_t,
                                                       fixed: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cpicker_set_color_mode_fixed(cpicker as *mut lv_obj_t,
                                                fixed as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Make the knob to be colored to the current color"]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc =
          " - __`en`__: true: color the knob; false: not color the knob"]
        pub fn set_knob_colored(cpicker: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make the knob to be colored to the current color"]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc =
                  " - __`en`__: true: color the knob; false: not color the knob"]
                pub fn lv_cpicker_set_knob_colored(cpicker: *mut lv_obj_t,
                                                   en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_cpicker_set_knob_colored(cpicker as *mut lv_obj_t,
                                            en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the current color mode."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: color mode (hue/sat/val)"]
        pub fn get_color_mode(cpicker: *mut lv_obj_t)
         -> MynewtResult<lv_cpicker_color_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current color mode."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: color mode (hue/sat/val)"]
                pub fn lv_cpicker_get_color_mode(cpicker: *mut lv_obj_t)
                -> lv_cpicker_color_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_color_mode(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get if the color mode is changed on long press on center"]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: mode cannot be changed on long press"]
        pub fn get_color_mode_fixed(cpicker: *mut lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get if the color mode is changed on long press on center"]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: mode cannot be changed on long press"]
                pub fn lv_cpicker_get_color_mode_fixed(cpicker: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_color_mode_fixed(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current hue of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: current selected hue"]
        pub fn get_hue(cpicker: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current hue of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: current selected hue"]
                pub fn lv_cpicker_get_hue(cpicker: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_hue(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current saturation of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: current selected saturation"]
        pub fn get_saturation(cpicker: *mut lv_obj_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current saturation of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: current selected saturation"]
                pub fn lv_cpicker_get_saturation(cpicker: *mut lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_saturation(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current hue of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: current selected value"]
        pub fn get_value(cpicker: *mut lv_obj_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current hue of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: current selected value"]
                pub fn lv_cpicker_get_value(cpicker: *mut lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_value(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current selected hsv of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: current selected hsv"]
        pub fn get_hsv(cpicker: *mut lv_obj_t)
         -> MynewtResult<lv_color_hsv_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current selected hsv of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: current selected hsv"]
                pub fn lv_cpicker_get_hsv(cpicker: *mut lv_obj_t)
                -> lv_color_hsv_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_hsv(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current selected color of a colorpicker."]
        #[doc = " - __`cpicker`__: pointer to colorpicker object"]
        #[doc = " Return: current selected color"]
        pub fn get_color(cpicker: *mut lv_obj_t) -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current selected color of a colorpicker."]
                #[doc = " - __`cpicker`__: pointer to colorpicker object"]
                #[doc = " Return: current selected color"]
                pub fn lv_cpicker_get_color(cpicker: *mut lv_obj_t)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_color(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Whether the knob is colored to the current color or not"]
        #[doc = " - __`cpicker`__: pointer to color picker object"]
        #[doc = " Return: true: color the knob; false: not color the knob"]
        pub fn get_knob_colored(cpicker: *mut lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Whether the knob is colored to the current color or not"]
                #[doc = " - __`cpicker`__: pointer to color picker object"]
                #[doc =
                  " Return: true: color the knob; false: not color the knob"]
                pub fn lv_cpicker_get_knob_colored(cpicker: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_cpicker_get_knob_colored(cpicker as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Dropdown Widget API `lv_dropdown`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod dropdown {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_DROPDOWN_DEF_ANIM_TIME: u32 = 200;
        pub const LV_DROPDOWN_POS_LAST: u32 = 65535;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_DROPDOWN_DIR_DOWN: _bindgen_ty_42 = 0;
        pub const LV_DROPDOWN_DIR_UP: _bindgen_ty_42 = 1;
        pub const LV_DROPDOWN_DIR_LEFT: _bindgen_ty_42 = 2;
        pub const LV_DROPDOWN_DIR_RIGHT: _bindgen_ty_42 = 3;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_42 = u32;
        pub type lv_dropdown_dir_t = u8;
        #[repr(C)]
        pub struct lv_dropdown_ext_t {
            pub page: *mut lv_obj_t,
            pub text: *const ::cty::c_char,
            pub symbol: *const ::cty::c_char,
            pub options: *mut ::cty::c_char,
            pub style_selected: lv_style_list_t,
            pub style_page: lv_style_list_t,
            pub style_scrlbar: lv_style_list_t,
            pub max_height: lv_coord_t,
            pub option_cnt: u16,
            pub sel_opt_id: u16,
            pub sel_opt_id_orig: u16,
            pub pr_opt_id: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 5usize],
        }
        impl Default for lv_dropdown_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_dropdown_ext_t {
            #[inline]
            pub fn dir(&self) -> lv_dropdown_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_dir(&mut self, val: lv_dropdown_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn show_selected(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_show_selected(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn static_txt(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_static_txt(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(dir: lv_dropdown_dir_t, show_selected: u8,
                                  static_txt: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(dir)
                                                    };
                                                dir as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let show_selected: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(show_selected)
                                                    };
                                                show_selected as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let static_txt: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(static_txt)
                                                    };
                                                static_txt as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_DROPDOWN_PART_MAIN: _bindgen_ty_43 = 0;
        pub const LV_DROPDOWN_PART_LIST: _bindgen_ty_43 = 64;
        pub const LV_DROPDOWN_PART_SCROLLBAR: _bindgen_ty_43 = 65;
        pub const LV_DROPDOWN_PART_SELECTED: _bindgen_ty_43 = 66;
        pub type _bindgen_ty_43 = u32;
        pub type lv_dropdown_part_t = u8;
        #[doc = " GLOBAL PROTOTYPES"]
        #[doc = " Create a drop down list objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new drop down list"]
        #[doc =
          " - __`copy`__: pointer to a drop down list object, if not NULL then the new object will be copied"]
        #[doc = " from it"]
        #[doc = " Return: pointer to the created drop down list"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " GLOBAL PROTOTYPES"]
                #[doc = " Create a drop down list objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new drop down list"]
                #[doc =
                  " - __`copy`__: pointer to a drop down list object, if not NULL then the new object will be copied"]
                #[doc = " from it"]
                #[doc = " Return: pointer to the created drop down list"]
                pub fn lv_dropdown_create(par: *mut lv_obj_t,
                                          copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_dropdown_create(par as *mut lv_obj_t,
                                       copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set text of the ddlist (Displayed on the button if `show_selected = false`)"]
        #[doc = " - __`ddlist`__: pointer to a drop down list object"]
        #[doc =
          " - __`txt`__: the text as a string (Only it's pointer is saved)"]
        pub fn set_text(ddlist: *mut lv_obj_t, txt: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set text of the ddlist (Displayed on the button if `show_selected = false`)"]
                #[doc = " - __`ddlist`__: pointer to a drop down list object"]
                #[doc =
                  " - __`txt`__: the text as a string (Only it's pointer is saved)"]
                pub fn lv_dropdown_set_text(ddlist: *mut lv_obj_t,
                                            txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_text(ddlist as *mut lv_obj_t,
                                     txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Clear any options in a drop down list.  Static or dynamic."]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        pub fn clear_options(ddlist: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Clear any options in a drop down list.  Static or dynamic."]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                pub fn lv_dropdown_clear_options(ddlist: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_clear_options(ddlist as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the options in a drop down list from a string"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc =
          " - __`options`__: a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
        #[doc =
          " The options string can be destroyed after calling this function"]
        pub fn set_options(ddlist: *mut lv_obj_t, options: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the options in a drop down list from a string"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " - __`options`__: a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
                #[doc =
                  " The options string can be destroyed after calling this function"]
                pub fn lv_dropdown_set_options(ddlist: *mut lv_obj_t,
                                               options: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            options.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_options(ddlist as *mut lv_obj_t,
                                        options.as_ptr() as
                                            *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the options in a drop down list from a string"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc =
          " - __`options`__: a static string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
        pub fn set_options_static(ddlist: *mut lv_obj_t, options: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the options in a drop down list from a string"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " - __`options`__: a static string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
                pub fn lv_dropdown_set_options_static(ddlist: *mut lv_obj_t,
                                                      options:
                                                          *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            options.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_options_static(ddlist as *mut lv_obj_t,
                                               options.as_ptr() as
                                                   *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Add an options to a drop down list from a string.  Only works for dynamic options."]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc = " - __`option`__: a string without '\\n'. E.g. \"Four\""]
        #[doc =
          " - __`pos`__:  the insert position, indexed from 0, LV_DROPDOWN_POS_LAST = end of string"]
        pub fn add_option(ddlist: *mut lv_obj_t, option: &Strn, pos: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Add an options to a drop down list from a string.  Only works for dynamic options."]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " - __`option`__: a string without '\\n'. E.g. \"Four\""]
                #[doc =
                  " - __`pos`__:  the insert position, indexed from 0, LV_DROPDOWN_POS_LAST = end of string"]
                pub fn lv_dropdown_add_option(ddlist: *mut lv_obj_t,
                                              option: *const ::cty::c_char,
                                              pos: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            option.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_add_option(ddlist as *mut lv_obj_t,
                                       option.as_ptr() as
                                           *const ::cty::c_char, pos as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the selected option"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc =
          " - __`sel_opt`__: id of the selected option (0 ... number of option - 1);"]
        pub fn set_selected(ddlist: *mut lv_obj_t, sel_opt: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the selected option"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " - __`sel_opt`__: id of the selected option (0 ... number of option - 1);"]
                pub fn lv_dropdown_set_selected(ddlist: *mut lv_obj_t,
                                                sel_opt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_selected(ddlist as *mut lv_obj_t,
                                         sel_opt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the direction of the a drop down list"]
        #[doc = " - __`ddlist`__: pointer to a drop down list object"]
        #[doc = " - __`dir`__: LV_DROPDOWN_DIR_LEF/RIGHT/TOP/BOTTOM"]
        pub fn set_dir(ddlist: *mut lv_obj_t, dir: lv_dropdown_dir_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the direction of the a drop down list"]
                #[doc = " - __`ddlist`__: pointer to a drop down list object"]
                #[doc = " - __`dir`__: LV_DROPDOWN_DIR_LEF/RIGHT/TOP/BOTTOM"]
                pub fn lv_dropdown_set_dir(ddlist: *mut lv_obj_t,
                                           dir: lv_dropdown_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_dir(ddlist as *mut lv_obj_t,
                                    dir as lv_dropdown_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the maximal height for the drop down list"]
        #[doc = " - __`ddlist`__: pointer to a drop down list"]
        #[doc = " - __`h`__: the maximal height"]
        pub fn set_max_height(ddlist: *mut lv_obj_t, h: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the maximal height for the drop down list"]
                #[doc = " - __`ddlist`__: pointer to a drop down list"]
                #[doc = " - __`h`__: the maximal height"]
                pub fn lv_dropdown_set_max_height(ddlist: *mut lv_obj_t,
                                                  h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_max_height(ddlist as *mut lv_obj_t,
                                           h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set an arrow or other symbol to display when the drop-down list is closed."]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc =
          " - __`symbol`__: a text like `LV_SYMBOL_DOWN` or NULL to not draw icon"]
        pub fn set_symbol(ddlist: *mut lv_obj_t, symbol: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set an arrow or other symbol to display when the drop-down list is closed."]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " - __`symbol`__: a text like `LV_SYMBOL_DOWN` or NULL to not draw icon"]
                pub fn lv_dropdown_set_symbol(ddlist: *mut lv_obj_t,
                                              symbol: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            symbol.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_symbol(ddlist as *mut lv_obj_t,
                                       symbol.as_ptr() as
                                           *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set whether the ddlist highlight the last selected option and display its text or not"]
        #[doc = " - __`ddlist`__: pointer to a drop down list object"]
        #[doc = " - __`show`__: true/false"]
        pub fn set_show_selected(ddlist: *mut lv_obj_t, show: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set whether the ddlist highlight the last selected option and display its text or not"]
                #[doc = " - __`ddlist`__: pointer to a drop down list object"]
                #[doc = " - __`show`__: true/false"]
                pub fn lv_dropdown_set_show_selected(ddlist: *mut lv_obj_t,
                                                     show: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_set_show_selected(ddlist as *mut lv_obj_t,
                                              show as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the selected option"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc =
          " Return: id of the selected option (0 ... number of option - 1);"]
        pub fn get_selected(ddlist: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the selected option"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " Return: id of the selected option (0 ... number of option - 1);"]
                pub fn lv_dropdown_get_selected(ddlist: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_dropdown_get_selected(ddlist as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the total number of options"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc = " Return: the total number of options in the list"]
        pub fn get_option_cnt(ddlist: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the total number of options"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc = " Return: the total number of options in the list"]
                pub fn lv_dropdown_get_option_cnt(ddlist: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_dropdown_get_option_cnt(ddlist as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current selected option as a string"]
        #[doc = " - __`ddlist`__: pointer to ddlist object"]
        #[doc = " - __`buf`__: pointer to an array to store the string"]
        #[doc = " - __`buf_size`__: size of `buf` in bytes. 0: to ignore it."]
        pub fn get_selected_str(ddlist: *const lv_obj_t,
                                buf: *mut ::cty::c_char, buf_size: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current selected option as a string"]
                #[doc = " - __`ddlist`__: pointer to ddlist object"]
                #[doc =
                  " - __`buf`__: pointer to an array to store the string"]
                #[doc =
                  " - __`buf_size`__: size of `buf` in bytes. 0: to ignore it."]
                pub fn lv_dropdown_get_selected_str(ddlist: *const lv_obj_t,
                                                    buf: *mut ::cty::c_char,
                                                    buf_size: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_get_selected_str(ddlist as *const lv_obj_t,
                                             buf as *mut ::cty::c_char,
                                             buf_size as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the fix height value."]
        #[doc = " - __`ddlist`__: pointer to a drop down list object"]
        #[doc = " Return: the height if the ddlist is opened (0: auto size)"]
        pub fn get_max_height(ddlist: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the fix height value."]
                #[doc = " - __`ddlist`__: pointer to a drop down list object"]
                #[doc =
                  " Return: the height if the ddlist is opened (0: auto size)"]
                pub fn lv_dropdown_get_max_height(ddlist: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_dropdown_get_max_height(ddlist as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the symbol to draw when the drop-down list is closed"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc = " Return: the symbol or NULL if not enabled"]
        pub fn get_dir(ddlist: *const lv_obj_t)
         -> MynewtResult<lv_dropdown_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the symbol to draw when the drop-down list is closed"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc = " Return: the symbol or NULL if not enabled"]
                pub fn lv_dropdown_get_dir(ddlist: *const lv_obj_t)
                -> lv_dropdown_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_dropdown_get_dir(ddlist as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get whether the ddlist highlight the last selected option and display its text or not"]
        #[doc = " - __`ddlist`__: pointer to a drop down list object"]
        #[doc = " Return: true/false"]
        pub fn get_show_selected(ddlist: *mut lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get whether the ddlist highlight the last selected option and display its text or not"]
                #[doc = " - __`ddlist`__: pointer to a drop down list object"]
                #[doc = " Return: true/false"]
                pub fn lv_dropdown_get_show_selected(ddlist: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_dropdown_get_show_selected(ddlist as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Open the drop down list with or without animation"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        pub fn open(ddlist: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Open the drop down list with or without animation"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                pub fn lv_dropdown_open(ddlist: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_open(ddlist as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Close (Collapse) the drop down list"]
        #[doc = " - __`ddlist`__: pointer to drop down list object"]
        #[doc =
          " - __`anim_en`__: LV_ANIM_ON: use animation; LV_ANOM_OFF: not use animations"]
        pub fn close(ddlist: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Close (Collapse) the drop down list"]
                #[doc = " - __`ddlist`__: pointer to drop down list object"]
                #[doc =
                  " - __`anim_en`__: LV_ANIM_ON: use animation; LV_ANOM_OFF: not use animations"]
                pub fn lv_dropdown_close(ddlist: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_dropdown_close(ddlist as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Gauge Widget API `lv_gauge`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod gauge {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_linemeter_ext_t {
            pub scale_angle: u16,
            pub angle_ofs: u16,
            pub line_cnt: u16,
            pub cur_value: i32,
            pub min_value: i32,
            pub max_value: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_linemeter_ext_t {
            #[inline]
            fn default() -> lv_linemeter_ext_t {
                lv_linemeter_ext_t{scale_angle:
                                       ::core::default::Default::default(),
                                   angle_ofs:
                                       ::core::default::Default::default(),
                                   line_cnt:
                                       ::core::default::Default::default(),
                                   cur_value:
                                       ::core::default::Default::default(),
                                   min_value:
                                       ::core::default::Default::default(),
                                   max_value:
                                       ::core::default::Default::default(),
                                   _bitfield_1:
                                       ::core::default::Default::default(),
                                   __bindgen_padding_0:
                                       ::core::default::Default::default(),}
            }
        }
        impl lv_linemeter_ext_t {
            #[inline]
            pub fn mirrored(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mirrored(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(mirrored: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let mirrored: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mirrored)
                                                    };
                                                mirrored as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        pub type lv_gauge_format_cb_t =
         ::core::option::Option<unsafe extern "C" fn(gauge: *mut lv_obj_t,
                                                     buf: *mut ::cty::c_char,
                                                     bufsize: ::cty::c_int,
                                                     value: i32)>;
        #[repr(C)]
        pub struct lv_gauge_ext_t {
            pub lmeter: lv_linemeter_ext_t,
            pub values: *mut i32,
            pub needle_colors: *const lv_color_t,
            pub needle_img: *const ::cty::c_void,
            pub needle_img_pivot: lv_point_t,
            pub style_needle: lv_style_list_t,
            pub style_strong: lv_style_list_t,
            pub needle_count: u8,
            pub label_count: u8,
            pub format_cb: lv_gauge_format_cb_t,
        }
        impl Default for lv_gauge_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub const LV_GAUGE_PART_MAIN: _bindgen_ty_37 = 0;
        pub const LV_GAUGE_PART_MAJOR: _bindgen_ty_37 = 1;
        pub const LV_GAUGE_PART_NEEDLE: _bindgen_ty_37 = 2;
        pub const _LV_GAUGE_PART_VIRTUAL_LAST: _bindgen_ty_37 = 1;
        pub const _LV_GAUGE_PART_REAL_LAST: _bindgen_ty_37 = 64;
        pub type _bindgen_ty_37 = u32;
        pub type lv_gauge_style_t = u8;
        #[doc = " Create a gauge objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new gauge"]
        #[doc =
          " - __`copy`__: pointer to a gauge object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created gauge"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a gauge objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new gauge"]
                #[doc =
                  " - __`copy`__: pointer to a gauge object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created gauge"]
                pub fn lv_gauge_create(par: *mut lv_obj_t,
                                       copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_create(par as *mut lv_obj_t,
                                    copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the number of needles"]
        #[doc = " - __`gauge`__: pointer to gauge object"]
        #[doc = " - __`needle_cnt`__: new count of needles"]
        #[doc =
          " - __`colors`__: an array of colors for needles (with 'num' elements)"]
        pub fn set_needle_count(gauge: *mut lv_obj_t, needle_cnt: u8,
                                colors: *const lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the number of needles"]
                #[doc = " - __`gauge`__: pointer to gauge object"]
                #[doc = " - __`needle_cnt`__: new count of needles"]
                #[doc =
                  " - __`colors`__: an array of colors for needles (with 'num' elements)"]
                pub fn lv_gauge_set_needle_count(gauge: *mut lv_obj_t,
                                                 needle_cnt: u8,
                                                 colors: *const lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_needle_count(gauge as *mut lv_obj_t,
                                          needle_cnt as u8,
                                          colors as *const lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the value of a needle"]
        #[doc = " - __`gauge`__: pointer to a gauge"]
        #[doc = " - __`needle_id`__: the id of the needle"]
        #[doc = " - __`value`__: the new value"]
        pub fn set_value(gauge: *mut lv_obj_t, needle_id: u8, value: i32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the value of a needle"]
                #[doc = " - __`gauge`__: pointer to a gauge"]
                #[doc = " - __`needle_id`__: the id of the needle"]
                #[doc = " - __`value`__: the new value"]
                pub fn lv_gauge_set_value(gauge: *mut lv_obj_t, needle_id: u8,
                                          value: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_value(gauge as *mut lv_obj_t, needle_id as u8,
                                   value as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set minimum and the maximum values of a gauge"]
        #[doc = " - __`gauge`__: pointer to he gauge object"]
        #[doc = " - __`min`__: minimum value"]
        #[doc = " - __`max`__: maximum value"]
        pub fn set_range(gauge: *mut lv_obj_t, min: i32, max: i32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set minimum and the maximum values of a gauge"]
                #[doc = " - __`gauge`__: pointer to he gauge object"]
                #[doc = " - __`min`__: minimum value"]
                #[doc = " - __`max`__: maximum value"]
                pub fn lv_gauge_set_range(gauge: *mut lv_obj_t, min: i32,
                                          max: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_range(gauge as *mut lv_obj_t, min as i32,
                                   max as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a critical value on the scale. After this value 'line.color' scale lines will be drawn"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " - __`value`__: the critical value"]
        pub fn set_critical_value(gauge: *mut lv_obj_t, value: i32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a critical value on the scale. After this value 'line.color' scale lines will be drawn"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " - __`value`__: the critical value"]
                pub fn lv_gauge_set_critical_value(gauge: *mut lv_obj_t,
                                                   value: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_critical_value(gauge as *mut lv_obj_t,
                                            value as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the scale settings of a gauge"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " - __`angle`__: angle of the scale (0..360)"]
        #[doc = " - __`line_cnt`__: count of scale lines."]
        #[doc = " To get a given \"subdivision\" lines between labels:"]
        #[doc = " `line_cnt = (sub_div + 1) * (label_cnt - 1) + 1 `"]
        #[doc = " - __`label_cnt`__: count of scale labels."]
        pub fn set_scale(gauge: *mut lv_obj_t, angle: u16, line_cnt: u8,
                         label_cnt: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scale settings of a gauge"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " - __`angle`__: angle of the scale (0..360)"]
                #[doc = " - __`line_cnt`__: count of scale lines."]
                #[doc =
                  " To get a given \"subdivision\" lines between labels:"]
                #[doc = " `line_cnt = (sub_div + 1) * (label_cnt - 1) + 1 `"]
                #[doc = " - __`label_cnt`__: count of scale labels."]
                pub fn lv_gauge_set_scale(gauge: *mut lv_obj_t, angle: u16,
                                          line_cnt: u8, label_cnt: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_scale(gauge as *mut lv_obj_t, angle as u16,
                                   line_cnt as u8, label_cnt as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the set an offset for the gauge's angles to rotate it."]
        #[doc = " - __`gauge`__: pointer to a line meter object"]
        #[doc = " - __`angle`__: angle offset (0..360), rotates clockwise"]
        pub fn set_angle_offset(gauge: *mut lv_obj_t, angle: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the set an offset for the gauge's angles to rotate it."]
                #[doc = " - __`gauge`__: pointer to a line meter object"]
                #[doc =
                  " - __`angle`__: angle offset (0..360), rotates clockwise"]
                pub fn lv_gauge_set_angle_offset(gauge: *mut lv_obj_t,
                                                 angle: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_angle_offset(gauge as *mut lv_obj_t,
                                          angle as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set an image to display as needle(s)."]
        #[doc =
          " The needle image should be horizontal and pointing to the right (`--->`)."]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc =
          " - __`img_src`__: pointer to an `lv_img_dsc_t` variable or a path to an image"]
        #[doc = "        (not an `lv_img` object)"]
        #[doc =
          " - __`pivot_x`__: the X coordinate of rotation center of the image"]
        #[doc =
          " - __`pivot_y`__: the Y coordinate of rotation center of the image"]
        pub fn set_needle_img(gauge: *mut lv_obj_t, img: *const ::cty::c_void,
                              pivot_x: lv_coord_t, pivot_y: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set an image to display as needle(s)."]
                #[doc =
                  " The needle image should be horizontal and pointing to the right (`--->`)."]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc =
                  " - __`img_src`__: pointer to an `lv_img_dsc_t` variable or a path to an image"]
                #[doc = "        (not an `lv_img` object)"]
                #[doc =
                  " - __`pivot_x`__: the X coordinate of rotation center of the image"]
                #[doc =
                  " - __`pivot_y`__: the Y coordinate of rotation center of the image"]
                pub fn lv_gauge_set_needle_img(gauge: *mut lv_obj_t,
                                               img: *const ::cty::c_void,
                                               pivot_x: lv_coord_t,
                                               pivot_y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_needle_img(gauge as *mut lv_obj_t,
                                        img as *const ::cty::c_void,
                                        pivot_x as lv_coord_t,
                                        pivot_y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Assign a function to format gauge values"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc =
          " - __`format_cb`__: pointer to function of lv_gauge_format_cb_t"]
        pub fn set_formatter_cb(gauge: *mut lv_obj_t,
                                format_cb: lv_gauge_format_cb_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Assign a function to format gauge values"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc =
                  " - __`format_cb`__: pointer to function of lv_gauge_format_cb_t"]
                pub fn lv_gauge_set_formatter_cb(gauge: *mut lv_obj_t,
                                                 format_cb:
                                                     lv_gauge_format_cb_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_gauge_set_formatter_cb(gauge as *mut lv_obj_t,
                                          format_cb as lv_gauge_format_cb_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the value of a needle"]
        #[doc = " - __`gauge`__: pointer to gauge object"]
        #[doc = " - __`needle`__: the id of the needle"]
        #[doc = " Return: the value of the needle [min,max]"]
        pub fn get_value(gauge: *const lv_obj_t, needle: u8)
         -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the value of a needle"]
                #[doc = " - __`gauge`__: pointer to gauge object"]
                #[doc = " - __`needle`__: the id of the needle"]
                #[doc = " Return: the value of the needle [min,max]"]
                pub fn lv_gauge_get_value(gauge: *const lv_obj_t, needle: u8)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_value(gauge as *const lv_obj_t,
                                       needle as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the count of needles on a gauge"]
        #[doc = " - __`gauge`__: pointer to gauge"]
        #[doc = " Return: count of needles"]
        pub fn get_needle_count(gauge: *const lv_obj_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the count of needles on a gauge"]
                #[doc = " - __`gauge`__: pointer to gauge"]
                #[doc = " Return: count of needles"]
                pub fn lv_gauge_get_needle_count(gauge: *const lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_needle_count(gauge as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the minimum value of a gauge"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: the minimum value of the gauge"]
        pub fn get_min_value(lmeter: *const lv_obj_t) -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the minimum value of a gauge"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: the minimum value of the gauge"]
                pub fn lv_gauge_get_min_value(lmeter: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_min_value(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the maximum value of a gauge"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: the maximum value of the gauge"]
        pub fn get_max_value(lmeter: *const lv_obj_t) -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the maximum value of a gauge"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: the maximum value of the gauge"]
                pub fn lv_gauge_get_max_value(lmeter: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_max_value(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get a critical value on the scale."]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: the critical value"]
        pub fn get_critical_value(gauge: *const lv_obj_t)
         -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get a critical value on the scale."]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: the critical value"]
                pub fn lv_gauge_get_critical_value(gauge: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_critical_value(gauge as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the number of labels (and the thicker lines too)"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: count of labels"]
        pub fn get_label_count(gauge: *const lv_obj_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the number of labels (and the thicker lines too)"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: count of labels"]
                pub fn lv_gauge_get_label_count(gauge: *const lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_label_count(gauge as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scale number of a gauge"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: number of the scale units"]
        pub fn get_line_count(gauge: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scale number of a gauge"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: number of the scale units"]
                pub fn lv_gauge_get_line_count(gauge: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_line_count(gauge as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scale angle of a gauge"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: angle of the scale"]
        pub fn get_scale_angle(gauge: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scale angle of a gauge"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: angle of the scale"]
                pub fn lv_gauge_get_scale_angle(gauge: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_scale_angle(gauge as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the offset for the gauge."]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: angle offset (0..360)"]
        pub fn get_angle_offset(gauge: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the offset for the gauge."]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc = " Return: angle offset (0..360)"]
                pub fn lv_gauge_get_angle_offset(gauge: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_angle_offset(gauge as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get an image to display as needle(s)."]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc =
          " Return: pointer to an `lv_img_dsc_t` variable or a path to an image"]
        #[doc = "        (not an `lv_img` object). `NULL` if not used."]
        pub fn get_needle_img(gauge: *mut lv_obj_t)
         -> MynewtResult<*const ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get an image to display as needle(s)."]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc =
                  " Return: pointer to an `lv_img_dsc_t` variable or a path to an image"]
                #[doc =
                  "        (not an `lv_img` object). `NULL` if not used."]
                pub fn lv_gauge_get_needle_img(gauge: *mut lv_obj_t)
                -> *const ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_needle_img(gauge as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the X coordinate of the rotation center of the needle image"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: the X coordinate of rotation center of the image"]
        pub fn get_needle_img_pivot_x(gauge: *mut lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the X coordinate of the rotation center of the needle image"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc =
                  " Return: the X coordinate of rotation center of the image"]
                pub fn lv_gauge_get_needle_img_pivot_x(gauge: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_needle_img_pivot_x(gauge as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the Y coordinate of the rotation center of the needle image"]
        #[doc = " - __`gauge`__: pointer to a gauge object"]
        #[doc = " Return: the X coordinate of rotation center of the image"]
        pub fn get_needle_img_pivot_y(gauge: *mut lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the Y coordinate of the rotation center of the needle image"]
                #[doc = " - __`gauge`__: pointer to a gauge object"]
                #[doc =
                  " Return: the X coordinate of rotation center of the image"]
                pub fn lv_gauge_get_needle_img_pivot_y(gauge: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_gauge_get_needle_img_pivot_y(gauge as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Image Widget API `lv_img`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod img {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_IMG_CF_INDEXED: u32 = 1;
        pub const LV_IMG_CF_ALPHA: u32 = 1;
        pub const LV_IMG_CACHE_DEF_SIZE: u32 = 1;
        pub const LV_IMGBTN_TILED: u32 = 0;
        pub const LV_IMG_PX_SIZE_ALPHA_BYTE: u32 = 3;
        pub const LV_IMG_ZOOM_NONE: u32 = 256;
        pub type lv_coord_t = i16;
        pub type lv_img_decoder_user_data_t = *mut ::cty::c_void;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_color16_t {
            pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
            pub full: __BindgenUnionField<u16>,
            pub bindgen_union_field: u16,
        }
        #[repr(C)]
        #[repr(align(2))]
        pub struct lv_color16_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_color16_t__bindgen_ty_1 {
            #[inline]
            fn default() -> lv_color16_t__bindgen_ty_1 {
                lv_color16_t__bindgen_ty_1{_bitfield_1:
                                               ::core::default::Default::default(),}
            }
        }
        impl lv_color16_t__bindgen_ty_1 {
            #[inline]
            pub fn green_h(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_h(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn red(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_red(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn blue(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_blue(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn green_l(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_green_l(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(green_h: u16, red: u16, blue: u16,
                                  green_l: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let green_h: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_h)
                                                    };
                                                green_h as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let red: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(red)
                                                    };
                                                red as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 5u8,
                                            {
                                                let blue: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(blue)
                                                    };
                                                blue as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 3u8,
                                            {
                                                let green_l: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(green_l)
                                                    };
                                                green_l as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_color16_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_color_t = lv_color16_t;
        #[doc = "! @cond Doxygen_Suppress"]
        pub type lv_opa_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub const LV_IMG_CF_UNKNOWN: _bindgen_ty_23 = 0;
        #[doc = "< Contains the file as it is. Needs custom decoder function"]
        pub const LV_IMG_CF_RAW: _bindgen_ty_23 = 1;
        #[doc =
          "< Contains the file as it is. The image has alpha. Needs custom decoder"]
        #[doc = "function"]
        pub const LV_IMG_CF_RAW_ALPHA: _bindgen_ty_23 = 2;
        #[doc =
          "< Contains the file as it is. The image is chroma keyed. Needs"]
        #[doc = "custom decoder function"]
        pub const LV_IMG_CF_RAW_CHROMA_KEYED: _bindgen_ty_23 = 3;
        #[doc =
          "< Color format and depth should match with LV_COLOR settings"]
        pub const LV_IMG_CF_TRUE_COLOR: _bindgen_ty_23 = 4;
        #[doc =
          "< Same as `LV_IMG_CF_TRUE_COLOR` but every pixel has an alpha byte"]
        pub const LV_IMG_CF_TRUE_COLOR_ALPHA: _bindgen_ty_23 = 5;
        #[doc = "< Same as `LV_IMG_CF_TRUE_COLOR` but LV_COLOR_TRANSP pixels"]
        #[doc = "will be transparent"]
        pub const LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: _bindgen_ty_23 = 6;
        #[doc =
          "< Can have 2 different colors in a palette (always chroma keyed)"]
        pub const LV_IMG_CF_INDEXED_1BIT: _bindgen_ty_23 = 7;
        #[doc =
          "< Can have 4 different colors in a palette (always chroma keyed)"]
        pub const LV_IMG_CF_INDEXED_2BIT: _bindgen_ty_23 = 8;
        #[doc =
          "< Can have 16 different colors in a palette (always chroma keyed)"]
        pub const LV_IMG_CF_INDEXED_4BIT: _bindgen_ty_23 = 9;
        #[doc =
          "< Can have 256 different colors in a palette (always chroma keyed)"]
        pub const LV_IMG_CF_INDEXED_8BIT: _bindgen_ty_23 = 10;
        #[doc = "< Can have one color and it can be drawn or not"]
        pub const LV_IMG_CF_ALPHA_1BIT: _bindgen_ty_23 = 11;
        #[doc = "< Can have one color but 4 different alpha value"]
        pub const LV_IMG_CF_ALPHA_2BIT: _bindgen_ty_23 = 12;
        #[doc = "< Can have one color but 16 different alpha value"]
        pub const LV_IMG_CF_ALPHA_4BIT: _bindgen_ty_23 = 13;
        #[doc = "< Can have one color but 256 different alpha value"]
        pub const LV_IMG_CF_ALPHA_8BIT: _bindgen_ty_23 = 14;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_15: _bindgen_ty_23 = 15;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_16: _bindgen_ty_23 = 16;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_17: _bindgen_ty_23 = 17;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_18: _bindgen_ty_23 = 18;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_19: _bindgen_ty_23 = 19;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_20: _bindgen_ty_23 = 20;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_21: _bindgen_ty_23 = 21;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_22: _bindgen_ty_23 = 22;
        #[doc = "< Reserved for further use."]
        pub const LV_IMG_CF_RESERVED_23: _bindgen_ty_23 = 23;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_0: _bindgen_ty_23 = 24;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_1: _bindgen_ty_23 = 25;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_2: _bindgen_ty_23 = 26;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_3: _bindgen_ty_23 = 27;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_4: _bindgen_ty_23 = 28;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_5: _bindgen_ty_23 = 29;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_6: _bindgen_ty_23 = 30;
        #[doc = "< User holder encoding format."]
        pub const LV_IMG_CF_USER_ENCODED_7: _bindgen_ty_23 = 31;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_23 = u32;
        pub type lv_img_cf_t = u8;
        #[repr(C)]
        #[repr(align(4))]
        pub struct lv_img_header_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_img_header_t {
            #[inline]
            fn default() -> lv_img_header_t {
                lv_img_header_t{_bitfield_1:
                                    ::core::default::Default::default(),}
            }
        }
        impl lv_img_header_t {
            #[inline]
            pub fn cf(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_cf(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn always_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_always_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn reserved(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_reserved(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn w(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 11u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_w(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 11u8, val as u64)
                }
            }
            #[inline]
            pub fn h(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_h(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 11u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(cf: u32, always_zero: u32, reserved: u32,
                                  w: u32, h: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u16> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 5u8,
                                            {
                                                let cf: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(cf)
                                                    };
                                                cf as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 3u8,
                                            {
                                                let always_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(always_zero)
                                                    };
                                                always_zero as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let reserved: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(reserved)
                                                    };
                                                reserved as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 11u8,
                                            {
                                                let w: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(w)
                                                    };
                                                w as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 11u8,
                                            {
                                                let h: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(h)
                                                    };
                                                h as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Image header it is compatible with"]
        #[doc = " the result from image converter utility"]
        #[repr(C)]
        pub struct lv_img_dsc_t {
            pub header: lv_img_header_t,
            pub data_size: u32,
            pub data: *const u8,
        }
        impl Default for lv_img_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_img_transform_dsc_t {
            pub cfg: lv_img_transform_dsc_t__bindgen_ty_1,
            pub res: lv_img_transform_dsc_t__bindgen_ty_2,
            pub tmp: lv_img_transform_dsc_t__bindgen_ty_3,
        }
        #[repr(C)]
        pub struct lv_img_transform_dsc_t__bindgen_ty_1 {
            pub src: *const ::cty::c_void,
            pub src_w: lv_coord_t,
            pub src_h: lv_coord_t,
            pub pivot_x: lv_coord_t,
            pub pivot_y: lv_coord_t,
            pub angle: i16,
            pub zoom: u16,
            pub color: lv_color_t,
            pub cf: lv_img_cf_t,
            pub antialias: bool,
        }
        impl Default for lv_img_transform_dsc_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_img_transform_dsc_t__bindgen_ty_2 {
            pub color: lv_color_t,
            pub opa: lv_opa_t,
        }
        impl Default for lv_img_transform_dsc_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_img_transform_dsc_t__bindgen_ty_3 {
            pub img_dsc: lv_img_dsc_t,
            pub pivot_x_256: i32,
            pub pivot_y_256: i32,
            pub sinma: i32,
            pub cosma: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub zoom_inv: u32,
            pub xs: lv_coord_t,
            pub ys: lv_coord_t,
            pub xs_int: lv_coord_t,
            pub ys_int: lv_coord_t,
            pub pxi: u32,
            pub px_size: u8,
        }
        impl Default for lv_img_transform_dsc_t__bindgen_ty_3 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_img_transform_dsc_t__bindgen_ty_3 {
            #[inline]
            pub fn chroma_keyed(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_chroma_keyed(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_alpha(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_has_alpha(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn native_color(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_native_color(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(chroma_keyed: u8, has_alpha: u8,
                                  native_color: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let chroma_keyed: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(chroma_keyed)
                                                    };
                                                chroma_keyed as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let has_alpha: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_alpha)
                                                    };
                                                has_alpha as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let native_color: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(native_color)
                                                    };
                                                native_color as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_img_transform_dsc_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Allocate an image buffer in RAM"]
        #[doc = " - __`w`__: width of image"]
        #[doc = " - __`h`__: height of image"]
        #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
        #[doc = " Return: an allocated image, or NULL on failure"]
        pub fn buf_alloc(w: lv_coord_t, h: lv_coord_t, cf: lv_img_cf_t)
         -> MynewtResult<*mut lv_img_dsc_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Allocate an image buffer in RAM"]
                #[doc = " - __`w`__: width of image"]
                #[doc = " - __`h`__: height of image"]
                #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
                #[doc = " Return: an allocated image, or NULL on failure"]
                pub fn lv_img_buf_alloc(w: lv_coord_t, h: lv_coord_t,
                                        cf: lv_img_cf_t)
                -> *mut lv_img_dsc_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_buf_alloc(w as lv_coord_t, h as lv_coord_t,
                                     cf as lv_img_cf_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the color of an image's pixel"]
        #[doc = " - __`dsc`__: an image descriptor"]
        #[doc = " - __`x`__: x coordinate of the point to get"]
        #[doc = " - __`y`__: x coordinate of the point to get"]
        #[doc =
          " - __`color`__: the color of the image. In case of `LV_IMG_CF_ALPHA_1/2/4/8` this color is used."]
        #[doc = " Not used in other cases."]
        #[doc = " - __`safe`__: true: check out of bounds"]
        #[doc = " Return: color of the point"]
        pub fn buf_get_px_color(dsc: *mut lv_img_dsc_t, x: lv_coord_t,
                                y: lv_coord_t, color: lv_color_t)
         -> MynewtResult<lv_color_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the color of an image's pixel"]
                #[doc = " - __`dsc`__: an image descriptor"]
                #[doc = " - __`x`__: x coordinate of the point to get"]
                #[doc = " - __`y`__: x coordinate of the point to get"]
                #[doc =
                  " - __`color`__: the color of the image. In case of `LV_IMG_CF_ALPHA_1/2/4/8` this color is used."]
                #[doc = " Not used in other cases."]
                #[doc = " - __`safe`__: true: check out of bounds"]
                #[doc = " Return: color of the point"]
                pub fn lv_img_buf_get_px_color(dsc: *mut lv_img_dsc_t,
                                               x: lv_coord_t, y: lv_coord_t,
                                               color: lv_color_t)
                -> lv_color_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_buf_get_px_color(dsc as *mut lv_img_dsc_t,
                                            x as lv_coord_t, y as lv_coord_t,
                                            color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the alpha value of an image's pixel"]
        #[doc = " - __`dsc`__: pointer to an image descriptor"]
        #[doc = " - __`x`__: x coordinate of the point to set"]
        #[doc = " - __`y`__: x coordinate of the point to set"]
        #[doc = " - __`safe`__: true: check out of bounds"]
        #[doc = " Return: alpha value of the point"]
        pub fn buf_get_px_alpha(dsc: *mut lv_img_dsc_t, x: lv_coord_t,
                                y: lv_coord_t) -> MynewtResult<lv_opa_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the alpha value of an image's pixel"]
                #[doc = " - __`dsc`__: pointer to an image descriptor"]
                #[doc = " - __`x`__: x coordinate of the point to set"]
                #[doc = " - __`y`__: x coordinate of the point to set"]
                #[doc = " - __`safe`__: true: check out of bounds"]
                #[doc = " Return: alpha value of the point"]
                pub fn lv_img_buf_get_px_alpha(dsc: *mut lv_img_dsc_t,
                                               x: lv_coord_t, y: lv_coord_t)
                -> lv_opa_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_buf_get_px_alpha(dsc as *mut lv_img_dsc_t,
                                            x as lv_coord_t, y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set the color of a pixel of an image. The alpha channel won't be affected."]
        #[doc = " - __`dsc`__: pointer to an image descriptor"]
        #[doc = " - __`x`__: x coordinate of the point to set"]
        #[doc = " - __`y`__: x coordinate of the point to set"]
        #[doc = " - __`c`__: color of the point"]
        #[doc = " - __`safe`__: true: check out of bounds"]
        pub fn buf_set_px_color(dsc: *mut lv_img_dsc_t, x: lv_coord_t,
                                y: lv_coord_t, c: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the color of a pixel of an image. The alpha channel won't be affected."]
                #[doc = " - __`dsc`__: pointer to an image descriptor"]
                #[doc = " - __`x`__: x coordinate of the point to set"]
                #[doc = " - __`y`__: x coordinate of the point to set"]
                #[doc = " - __`c`__: color of the point"]
                #[doc = " - __`safe`__: true: check out of bounds"]
                pub fn lv_img_buf_set_px_color(dsc: *mut lv_img_dsc_t,
                                               x: lv_coord_t, y: lv_coord_t,
                                               c: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_buf_set_px_color(dsc as *mut lv_img_dsc_t,
                                        x as lv_coord_t, y as lv_coord_t,
                                        c as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the alpha value of a pixel of an image. The color won't be affected"]
        #[doc = " - __`dsc`__: pointer to an image descriptor"]
        #[doc = " - __`x`__: x coordinate of the point to set"]
        #[doc = " - __`y`__: x coordinate of the point to set"]
        #[doc = " - __`opa`__: the desired opacity"]
        #[doc = " - __`safe`__: true: check out of bounds"]
        pub fn buf_set_px_alpha(dsc: *mut lv_img_dsc_t, x: lv_coord_t,
                                y: lv_coord_t, opa: lv_opa_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the alpha value of a pixel of an image. The color won't be affected"]
                #[doc = " - __`dsc`__: pointer to an image descriptor"]
                #[doc = " - __`x`__: x coordinate of the point to set"]
                #[doc = " - __`y`__: x coordinate of the point to set"]
                #[doc = " - __`opa`__: the desired opacity"]
                #[doc = " - __`safe`__: true: check out of bounds"]
                pub fn lv_img_buf_set_px_alpha(dsc: *mut lv_img_dsc_t,
                                               x: lv_coord_t, y: lv_coord_t,
                                               opa: lv_opa_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_buf_set_px_alpha(dsc as *mut lv_img_dsc_t,
                                        x as lv_coord_t, y as lv_coord_t,
                                        opa as lv_opa_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the palette color of an indexed image. Valid only for `LV_IMG_CF_INDEXED1/2/4/8`"]
        #[doc = " - __`dsc`__: pointer to an image descriptor"]
        #[doc = " - __`id`__: the palette color to set:"]
        #[doc = "   - for `LV_IMG_CF_INDEXED1`: 0..1"]
        #[doc = "   - for `LV_IMG_CF_INDEXED2`: 0..3"]
        #[doc = "   - for `LV_IMG_CF_INDEXED4`: 0..15"]
        #[doc = "   - for `LV_IMG_CF_INDEXED8`: 0..255"]
        #[doc = " - __`c`__: the color to set"]
        pub fn buf_set_palette(dsc: *mut lv_img_dsc_t, id: u8, c: lv_color_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the palette color of an indexed image. Valid only for `LV_IMG_CF_INDEXED1/2/4/8`"]
                #[doc = " - __`dsc`__: pointer to an image descriptor"]
                #[doc = " - __`id`__: the palette color to set:"]
                #[doc = "   - for `LV_IMG_CF_INDEXED1`: 0..1"]
                #[doc = "   - for `LV_IMG_CF_INDEXED2`: 0..3"]
                #[doc = "   - for `LV_IMG_CF_INDEXED4`: 0..15"]
                #[doc = "   - for `LV_IMG_CF_INDEXED8`: 0..255"]
                #[doc = " - __`c`__: the color to set"]
                pub fn lv_img_buf_set_palette(dsc: *mut lv_img_dsc_t, id: u8,
                                              c: lv_color_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_buf_set_palette(dsc as *mut lv_img_dsc_t, id as u8,
                                       c as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Free an allocated image buffer"]
        #[doc = " - __`dsc`__: image buffer to free"]
        pub fn buf_free(dsc: *mut lv_img_dsc_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Free an allocated image buffer"]
                #[doc = " - __`dsc`__: image buffer to free"]
                pub fn lv_img_buf_free(dsc: *mut lv_img_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_buf_free(dsc as *mut lv_img_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get the memory consumption of a raw bitmap, given color format and dimensions."]
        #[doc = " - __`w`__: width"]
        #[doc = " - __`h`__: height"]
        #[doc = " - __`cf`__: color format"]
        #[doc = " Return: size in bytes"]
        pub fn buf_get_img_size(w: lv_coord_t, h: lv_coord_t, cf: lv_img_cf_t)
         -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the memory consumption of a raw bitmap, given color format and dimensions."]
                #[doc = " - __`w`__: width"]
                #[doc = " - __`h`__: height"]
                #[doc = " - __`cf`__: color format"]
                #[doc = " Return: size in bytes"]
                pub fn lv_img_buf_get_img_size(w: lv_coord_t, h: lv_coord_t,
                                               cf: lv_img_cf_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_buf_get_img_size(w as lv_coord_t, h as lv_coord_t,
                                            cf as lv_img_cf_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub const LV_IMG_SRC_VARIABLE: _bindgen_ty_24 = 0;
        #[doc = " Binary/C variable"]
        pub const LV_IMG_SRC_FILE: _bindgen_ty_24 = 1;
        #[doc = " File in filesystem"]
        pub const LV_IMG_SRC_SYMBOL: _bindgen_ty_24 = 2;
        #[doc = " Symbol (@ref lv_symbol_def.h)"]
        pub const LV_IMG_SRC_UNKNOWN: _bindgen_ty_24 = 3;
        #[doc = " Source of image."]
        pub type _bindgen_ty_24 = u32;
        pub type lv_img_src_t = u8;
        #[doc = " Get info from an image and store in the `header`"]
        #[doc =
          " - __`src`__: the image source. Can be a pointer to a C array or a file name (Use"]
        #[doc = " `lv_img_src_get_type` to determine the type)"]
        #[doc = " - __`header`__: store the info here"]
        #[doc =
          " Return: LV_RES_OK: info written correctly; LV_RES_INV: failed"]
        pub type lv_img_decoder_info_f_t =
         ::core::option::Option<unsafe extern "C" fn(decoder:
                                                         *mut _lv_img_decoder,
                                                     src:
                                                         *const ::cty::c_void,
                                                     header:
                                                         *mut lv_img_header_t)
                                    -> lv_res_t>;
        #[doc =
          " Open an image for decoding. Prepare it as it is required to read it later"]
        #[doc =
          " - __`decoder`__: pointer to the decoder the function associated with"]
        #[doc =
          " - __`dsc`__: pointer to decoder descriptor. `src`, `style` are already initialized in it."]
        pub type lv_img_decoder_open_f_t =
         ::core::option::Option<unsafe extern "C" fn(decoder:
                                                         *mut _lv_img_decoder,
                                                     dsc:
                                                         *mut _lv_img_decoder_dsc)
                                    -> lv_res_t>;
        #[doc =
          " Decode `len` pixels starting from the given `x`, `y` coordinates and store them in `buf`."]
        #[doc =
          " Required only if the \"open\" function can't return with the whole decoded pixel array."]
        #[doc =
          " - __`decoder`__: pointer to the decoder the function associated with"]
        #[doc = " - __`dsc`__: pointer to decoder descriptor"]
        #[doc = " - __`x`__: start x coordinate"]
        #[doc = " - __`y`__: start y coordinate"]
        #[doc = " - __`len`__: number of pixels to decode"]
        #[doc = " - __`buf`__: a buffer to store the decoded pixels"]
        #[doc = " Return: LV_RES_OK: ok; LV_RES_INV: failed"]
        pub type lv_img_decoder_read_line_f_t =
         ::core::option::Option<unsafe extern "C" fn(decoder:
                                                         *mut _lv_img_decoder,
                                                     dsc:
                                                         *mut _lv_img_decoder_dsc,
                                                     x: lv_coord_t,
                                                     y: lv_coord_t,
                                                     len: lv_coord_t,
                                                     buf: *mut u8)
                                    -> lv_res_t>;
        #[doc = " Close the pending decoding. Free resources etc."]
        #[doc =
          " - __`decoder`__: pointer to the decoder the function associated with"]
        #[doc = " - __`dsc`__: pointer to decoder descriptor"]
        pub type lv_img_decoder_close_f_t =
         ::core::option::Option<unsafe extern "C" fn(decoder:
                                                         *mut _lv_img_decoder,
                                                     dsc:
                                                         *mut _lv_img_decoder_dsc)>;
        #[repr(C)]
        pub struct _lv_img_decoder {
            pub info_cb: lv_img_decoder_info_f_t,
            pub open_cb: lv_img_decoder_open_f_t,
            pub read_line_cb: lv_img_decoder_read_line_f_t,
            pub close_cb: lv_img_decoder_close_f_t,
            pub user_data: lv_img_decoder_user_data_t,
        }
        impl Default for _lv_img_decoder {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_img_decoder_t = _lv_img_decoder;
        #[doc =
          "Describe an image decoding session. Stores data about the decoding"]
        #[repr(C)]
        pub struct _lv_img_decoder_dsc {
            #[doc = "The decoder which was able to open the image source"]
            pub decoder: *mut lv_img_decoder_t,
            #[doc =
              "The image source. A file path like \"S:my_img.png\" or pointer to an `lv_img_dsc_t` variable"]
            pub src: *const ::cty::c_void,
            #[doc = "Style to draw the image."]
            pub color: lv_color_t,
            #[doc =
              "Type of the source: file or variable. Can be set in `open` function if required"]
            pub src_type: lv_img_src_t,
            #[doc =
              "Info about the opened image: color format, size, etc. MUST be set in `open` function"]
            pub header: lv_img_header_t,
            #[doc =
              " Pointer to a buffer where the image's data (pixels) are stored in a decoded, plain format."]
            #[doc = "  MUST be set in `open` function"]
            pub img_data: *const u8,
            #[doc = " How much time did it take to open the image. [ms]"]
            #[doc =
              "  If not set `lv_img_cache` will measure and set the time to open"]
            pub time_to_open: u32,
            #[doc =
              "A text to display instead of the image when the image can't be opened."]
            #[doc = " Can be set in `open` function or set NULL."]
            pub error_msg: *const ::cty::c_char,
            #[doc = "Store any custom data here is required"]
            pub user_data: *mut ::cty::c_void,
        }
        impl Default for _lv_img_decoder_dsc {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_img_decoder_dsc_t = _lv_img_decoder_dsc;
        #[doc = " Get information about an image."]
        #[doc =
          " Try the created image decoder one by one. Once one is able to get info that info will be used."]
        #[doc = " - __`src`__: the image source. Can be"]
        #[doc =
          "  1) File name: E.g. \"S:folder/img1.png\" (The drivers needs to registered via `lv_fs_add_drv()`)"]
        #[doc = "  2) Variable: Pointer to an `lv_img_dsc_t` variable"]
        #[doc = "  3) Symbol: E.g. `LV_SYMBOL_OK`"]
        #[doc = " - __`header`__: the image info will be stored here"]
        #[doc =
          " Return: LV_RES_OK: success; LV_RES_INV: wasn't able to get info about the image"]
        pub fn decoder_get_info(src: &Strn, header: *mut lv_img_header_t)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get information about an image."]
                #[doc =
                  " Try the created image decoder one by one. Once one is able to get info that info will be used."]
                #[doc = " - __`src`__: the image source. Can be"]
                #[doc =
                  "  1) File name: E.g. \"S:folder/img1.png\" (The drivers needs to registered via `lv_fs_add_drv()`)"]
                #[doc =
                  "  2) Variable: Pointer to an `lv_img_dsc_t` variable"]
                #[doc = "  3) Symbol: E.g. `LV_SYMBOL_OK`"]
                #[doc = " - __`header`__: the image info will be stored here"]
                #[doc =
                  " Return: LV_RES_OK: success; LV_RES_INV: wasn't able to get info about the image"]
                pub fn lv_img_decoder_get_info(src: *const ::cty::c_char,
                                               header: *mut lv_img_header_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            src.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_decoder_get_info(src.as_ptr() as
                                                *const ::cty::c_char,
                                            header as *mut lv_img_header_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Open an image."]
        #[doc =
          " Try the created image decoder one by one. Once one is able to open the image that decoder is save in `dsc`"]
        #[doc =
          " - __`dsc`__: describe a decoding session. Simply a pointer to an `lv_img_decoder_dsc_t` variable."]
        #[doc = " - __`src`__: the image source. Can be"]
        #[doc =
          "  1) File name: E.g. \"S:folder/img1.png\" (The drivers needs to registered via `lv_fs_add_drv()`)"]
        #[doc = "  2) Variable: Pointer to an `lv_img_dsc_t` variable"]
        #[doc = "  3) Symbol: E.g. `LV_SYMBOL_OK`"]
        #[doc =
          " - __`color`__: The color of the image with `LV_IMG_CF_ALPHA_...`"]
        #[doc =
          " Return: LV_RES_OK: opened the image. `dsc->img_data` and `dsc->header` are set."]
        #[doc =
          "         LV_RES_INV: none of the registered image decoders were able to open the image."]
        pub fn decoder_open(dsc: *mut lv_img_decoder_dsc_t,
                            src: *const ::cty::c_void, color: lv_color_t)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Open an image."]
                #[doc =
                  " Try the created image decoder one by one. Once one is able to open the image that decoder is save in `dsc`"]
                #[doc =
                  " - __`dsc`__: describe a decoding session. Simply a pointer to an `lv_img_decoder_dsc_t` variable."]
                #[doc = " - __`src`__: the image source. Can be"]
                #[doc =
                  "  1) File name: E.g. \"S:folder/img1.png\" (The drivers needs to registered via `lv_fs_add_drv()`)"]
                #[doc =
                  "  2) Variable: Pointer to an `lv_img_dsc_t` variable"]
                #[doc = "  3) Symbol: E.g. `LV_SYMBOL_OK`"]
                #[doc =
                  " - __`color`__: The color of the image with `LV_IMG_CF_ALPHA_...`"]
                #[doc =
                  " Return: LV_RES_OK: opened the image. `dsc->img_data` and `dsc->header` are set."]
                #[doc =
                  "         LV_RES_INV: none of the registered image decoders were able to open the image."]
                pub fn lv_img_decoder_open(dsc: *mut lv_img_decoder_dsc_t,
                                           src: *const ::cty::c_void,
                                           color: lv_color_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_decoder_open(dsc as *mut lv_img_decoder_dsc_t,
                                        src as *const ::cty::c_void,
                                        color as lv_color_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Read a line from an opened image"]
        #[doc =
          " - __`dsc`__: pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`"]
        #[doc = " - __`x`__: start X coordinate (from left)"]
        #[doc = " - __`y`__: start Y coordinate (from top)"]
        #[doc = " - __`len`__: number of pixels to read"]
        #[doc = " - __`buf`__: store the data here"]
        #[doc = " Return: LV_RES_OK: success; LV_RES_INV: an error occurred"]
        pub fn decoder_read_line(dsc: *mut lv_img_decoder_dsc_t,
                                 x: lv_coord_t, y: lv_coord_t,
                                 len: lv_coord_t, buf: *mut u8)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Read a line from an opened image"]
                #[doc =
                  " - __`dsc`__: pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`"]
                #[doc = " - __`x`__: start X coordinate (from left)"]
                #[doc = " - __`y`__: start Y coordinate (from top)"]
                #[doc = " - __`len`__: number of pixels to read"]
                #[doc = " - __`buf`__: store the data here"]
                #[doc =
                  " Return: LV_RES_OK: success; LV_RES_INV: an error occurred"]
                pub fn lv_img_decoder_read_line(dsc:
                                                    *mut lv_img_decoder_dsc_t,
                                                x: lv_coord_t, y: lv_coord_t,
                                                len: lv_coord_t, buf: *mut u8)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_decoder_read_line(dsc as *mut lv_img_decoder_dsc_t,
                                             x as lv_coord_t, y as lv_coord_t,
                                             len as lv_coord_t,
                                             buf as *mut u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Close a decoding session"]
        #[doc =
          " - __`dsc`__: pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`"]
        pub fn decoder_close(dsc: *mut lv_img_decoder_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Close a decoding session"]
                #[doc =
                  " - __`dsc`__: pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`"]
                pub fn lv_img_decoder_close(dsc: *mut lv_img_decoder_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_close(dsc as *mut lv_img_decoder_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Create a new image decoder"]
        #[doc = " Return: pointer to the new image decoder"]
        pub fn decoder_create() -> MynewtResult<*mut lv_img_decoder_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a new image decoder"]
                #[doc = " Return: pointer to the new image decoder"]
                pub fn lv_img_decoder_create()
                -> *mut lv_img_decoder_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_decoder_create();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Delete an image decoder"]
        #[doc = " - __`decoder`__: pointer to an image decoder"]
        pub fn decoder_delete(decoder: *mut lv_img_decoder_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Delete an image decoder"]
                #[doc = " - __`decoder`__: pointer to an image decoder"]
                pub fn lv_img_decoder_delete(decoder: *mut lv_img_decoder_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_delete(decoder as *mut lv_img_decoder_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a callback to get information about the image"]
        #[doc = " - __`decoder`__: pointer to an image decoder"]
        #[doc =
          " - __`info_cb`__: a function to collect info about an image (fill an `lv_img_header_t` struct)"]
        pub fn decoder_set_info_cb(decoder: *mut lv_img_decoder_t,
                                   info_cb: lv_img_decoder_info_f_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a callback to get information about the image"]
                #[doc = " - __`decoder`__: pointer to an image decoder"]
                #[doc =
                  " - __`info_cb`__: a function to collect info about an image (fill an `lv_img_header_t` struct)"]
                pub fn lv_img_decoder_set_info_cb(decoder:
                                                      *mut lv_img_decoder_t,
                                                  info_cb:
                                                      lv_img_decoder_info_f_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_set_info_cb(decoder as *mut lv_img_decoder_t,
                                           info_cb as
                                               lv_img_decoder_info_f_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a callback to open an image"]
        #[doc = " - __`decoder`__: pointer to an image decoder"]
        #[doc = " - __`open_cb`__: a function to open an image"]
        pub fn decoder_set_open_cb(decoder: *mut lv_img_decoder_t,
                                   open_cb: lv_img_decoder_open_f_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a callback to open an image"]
                #[doc = " - __`decoder`__: pointer to an image decoder"]
                #[doc = " - __`open_cb`__: a function to open an image"]
                pub fn lv_img_decoder_set_open_cb(decoder:
                                                      *mut lv_img_decoder_t,
                                                  open_cb:
                                                      lv_img_decoder_open_f_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_set_open_cb(decoder as *mut lv_img_decoder_t,
                                           open_cb as
                                               lv_img_decoder_open_f_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a callback to a decoded line of an image"]
        #[doc = " - __`decoder`__: pointer to an image decoder"]
        #[doc =
          " - __`read_line_cb`__: a function to read a line of an image"]
        pub fn decoder_set_read_line_cb(decoder: *mut lv_img_decoder_t,
                                        read_line_cb:
                                            lv_img_decoder_read_line_f_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a callback to a decoded line of an image"]
                #[doc = " - __`decoder`__: pointer to an image decoder"]
                #[doc =
                  " - __`read_line_cb`__: a function to read a line of an image"]
                pub fn lv_img_decoder_set_read_line_cb(decoder:
                                                           *mut lv_img_decoder_t,
                                                       read_line_cb:
                                                           lv_img_decoder_read_line_f_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_set_read_line_cb(decoder as
                                                    *mut lv_img_decoder_t,
                                                read_line_cb as
                                                    lv_img_decoder_read_line_f_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a callback to close a decoding session. E.g. close files and free other resources."]
        #[doc = " - __`decoder`__: pointer to an image decoder"]
        #[doc = " - __`close_cb`__: a function to close a decoding session"]
        pub fn decoder_set_close_cb(decoder: *mut lv_img_decoder_t,
                                    close_cb: lv_img_decoder_close_f_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a callback to close a decoding session. E.g. close files and free other resources."]
                #[doc = " - __`decoder`__: pointer to an image decoder"]
                #[doc =
                  " - __`close_cb`__: a function to close a decoding session"]
                pub fn lv_img_decoder_set_close_cb(decoder:
                                                       *mut lv_img_decoder_t,
                                                   close_cb:
                                                       lv_img_decoder_close_f_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_set_close_cb(decoder as *mut lv_img_decoder_t,
                                            close_cb as
                                                lv_img_decoder_close_f_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get info about a built-in image"]
        #[doc = " - __`decoder`__: the decoder where this function belongs"]
        #[doc =
          " - __`src`__: the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol"]
        #[doc = " - __`header`__: store the image data here"]
        #[doc =
          " Return: LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error."]
        pub fn decoder_built_in_info(decoder: *mut lv_img_decoder_t,
                                     src: *const ::cty::c_void,
                                     header: *mut lv_img_header_t)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get info about a built-in image"]
                #[doc =
                  " - __`decoder`__: the decoder where this function belongs"]
                #[doc =
                  " - __`src`__: the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol"]
                #[doc = " - __`header`__: store the image data here"]
                #[doc =
                  " Return: LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error."]
                pub fn lv_img_decoder_built_in_info(decoder:
                                                        *mut lv_img_decoder_t,
                                                    src: *const ::cty::c_void,
                                                    header:
                                                        *mut lv_img_header_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_decoder_built_in_info(decoder as
                                                     *mut lv_img_decoder_t,
                                                 src as *const ::cty::c_void,
                                                 header as
                                                     *mut lv_img_header_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Open a built in image"]
        #[doc = " - __`decoder`__: the decoder where this function belongs"]
        #[doc =
          " - __`dsc`__: pointer to decoder descriptor. `src`, `style` are already initialized in it."]
        #[doc =
          " Return: LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error."]
        pub fn decoder_built_in_open(decoder: *mut lv_img_decoder_t,
                                     dsc: *mut lv_img_decoder_dsc_t)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Open a built in image"]
                #[doc =
                  " - __`decoder`__: the decoder where this function belongs"]
                #[doc =
                  " - __`dsc`__: pointer to decoder descriptor. `src`, `style` are already initialized in it."]
                #[doc =
                  " Return: LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error."]
                pub fn lv_img_decoder_built_in_open(decoder:
                                                        *mut lv_img_decoder_t,
                                                    dsc:
                                                        *mut lv_img_decoder_dsc_t)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_decoder_built_in_open(decoder as
                                                     *mut lv_img_decoder_t,
                                                 dsc as
                                                     *mut lv_img_decoder_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Decode `len` pixels starting from the given `x`, `y` coordinates and store them in `buf`."]
        #[doc =
          " Required only if the \"open\" function can't return with the whole decoded pixel array."]
        #[doc =
          " - __`decoder`__: pointer to the decoder the function associated with"]
        #[doc = " - __`dsc`__: pointer to decoder descriptor"]
        #[doc = " - __`x`__: start x coordinate"]
        #[doc = " - __`y`__: start y coordinate"]
        #[doc = " - __`len`__: number of pixels to decode"]
        #[doc = " - __`buf`__: a buffer to store the decoded pixels"]
        #[doc = " Return: LV_RES_OK: ok; LV_RES_INV: failed"]
        pub fn decoder_built_in_read_line(decoder: *mut lv_img_decoder_t,
                                          dsc: *mut lv_img_decoder_dsc_t,
                                          x: lv_coord_t, y: lv_coord_t,
                                          len: lv_coord_t, buf: *mut u8)
         -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Decode `len` pixels starting from the given `x`, `y` coordinates and store them in `buf`."]
                #[doc =
                  " Required only if the \"open\" function can't return with the whole decoded pixel array."]
                #[doc =
                  " - __`decoder`__: pointer to the decoder the function associated with"]
                #[doc = " - __`dsc`__: pointer to decoder descriptor"]
                #[doc = " - __`x`__: start x coordinate"]
                #[doc = " - __`y`__: start y coordinate"]
                #[doc = " - __`len`__: number of pixels to decode"]
                #[doc = " - __`buf`__: a buffer to store the decoded pixels"]
                #[doc = " Return: LV_RES_OK: ok; LV_RES_INV: failed"]
                pub fn lv_img_decoder_built_in_read_line(decoder:
                                                             *mut lv_img_decoder_t,
                                                         dsc:
                                                             *mut lv_img_decoder_dsc_t,
                                                         x: lv_coord_t,
                                                         y: lv_coord_t,
                                                         len: lv_coord_t,
                                                         buf: *mut u8)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_decoder_built_in_read_line(decoder as
                                                          *mut lv_img_decoder_t,
                                                      dsc as
                                                          *mut lv_img_decoder_dsc_t,
                                                      x as lv_coord_t,
                                                      y as lv_coord_t,
                                                      len as lv_coord_t,
                                                      buf as *mut u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Close the pending decoding. Free resources etc."]
        #[doc =
          " - __`decoder`__: pointer to the decoder the function associated with"]
        #[doc = " - __`dsc`__: pointer to decoder descriptor"]
        pub fn decoder_built_in_close(decoder: *mut lv_img_decoder_t,
                                      dsc: *mut lv_img_decoder_dsc_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Close the pending decoding. Free resources etc."]
                #[doc =
                  " - __`decoder`__: pointer to the decoder the function associated with"]
                #[doc = " - __`dsc`__: pointer to decoder descriptor"]
                pub fn lv_img_decoder_built_in_close(decoder:
                                                         *mut lv_img_decoder_t,
                                                     dsc:
                                                         *mut lv_img_decoder_dsc_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_decoder_built_in_close(decoder as
                                                  *mut lv_img_decoder_t,
                                              dsc as
                                                  *mut lv_img_decoder_dsc_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the type of an image source"]
        #[doc = " - __`src`__: pointer to an image source:"]
        #[doc =
          "  - pointer to an 'lv_img_t' variable (image stored internally and compiled into the code)"]
        #[doc = "  - a path to a file (e.g. \"S:/folder/image.bin\")"]
        #[doc = "  - or a symbol (e.g. LV_SYMBOL_CLOSE)"]
        #[doc =
          " Return: type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN"]
        pub fn src_get_type(src: *const ::cty::c_void)
         -> MynewtResult<lv_img_src_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the type of an image source"]
                #[doc = " - __`src`__: pointer to an image source:"]
                #[doc =
                  "  - pointer to an 'lv_img_t' variable (image stored internally and compiled into the code)"]
                #[doc = "  - a path to a file (e.g. \"S:/folder/image.bin\")"]
                #[doc = "  - or a symbol (e.g. LV_SYMBOL_CLOSE)"]
                #[doc =
                  " Return: type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN"]
                pub fn lv_img_src_get_type(src: *const ::cty::c_void)
                -> lv_img_src_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_src_get_type(src as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the pixel size of a color format in bits"]
        #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
        #[doc = " Return: the pixel size in bits"]
        pub fn cf_get_px_size(cf: lv_img_cf_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the pixel size of a color format in bits"]
                #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
                #[doc = " Return: the pixel size in bits"]
                pub fn lv_img_cf_get_px_size(cf: lv_img_cf_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_cf_get_px_size(cf as lv_img_cf_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check if a color format is chroma keyed or not"]
        #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
        #[doc = " Return: true: chroma keyed; false: not chroma keyed"]
        pub fn cf_is_chroma_keyed(cf: lv_img_cf_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if a color format is chroma keyed or not"]
                #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
                #[doc =
                  " Return: true: chroma keyed; false: not chroma keyed"]
                pub fn lv_img_cf_is_chroma_keyed(cf: lv_img_cf_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_cf_is_chroma_keyed(cf as lv_img_cf_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check if a color format has alpha channel or not"]
        #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
        #[doc =
          " Return: true: has alpha channel; false: doesn't have alpha channel"]
        pub fn cf_has_alpha(cf: lv_img_cf_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if a color format has alpha channel or not"]
                #[doc = " - __`cf`__: a color format (`LV_IMG_CF_...`)"]
                #[doc =
                  " Return: true: has alpha channel; false: doesn't have alpha channel"]
                pub fn lv_img_cf_has_alpha(cf: lv_img_cf_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_cf_has_alpha(cf as lv_img_cf_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_img_ext_t {
            pub src: *const ::cty::c_void,
            pub offset: lv_point_t,
            pub w: lv_coord_t,
            pub h: lv_coord_t,
            pub angle: u16,
            pub pivot: lv_point_t,
            pub zoom: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        impl Default for lv_img_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_img_ext_t {
            #[inline]
            pub fn src_type(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_src_type(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn auto_size(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_size(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn cf(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_cf(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 5u8, val as u64)
                }
            }
            #[inline]
            pub fn antialias(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_antialias(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(src_type: u8, auto_size: u8, cf: u8,
                                  antialias: u8)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let src_type: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(src_type)
                                                    };
                                                src_type as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let auto_size: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_size)
                                                    };
                                                auto_size as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 5u8,
                                            {
                                                let cf: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(cf)
                                                    };
                                                cf as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let antialias: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(antialias)
                                                    };
                                                antialias as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_IMG_PART_MAIN: _bindgen_ty_35 = 0;
        pub type _bindgen_ty_35 = u32;
        pub type lv_img_part_t = u8;
        #[doc = " Create an image objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new button"]
        #[doc =
          " - __`copy`__: pointer to a image object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created image"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create an image objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new button"]
                #[doc =
                  " - __`copy`__: pointer to a image object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created image"]
                pub fn lv_img_create(par: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_create(par as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the pixel map to display by the image"]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " - __`data`__: the image data"]
        pub fn set_src(img: *mut lv_obj_t, src_img: *const ::cty::c_void)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the pixel map to display by the image"]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc = " - __`data`__: the image data"]
                pub fn lv_img_set_src(img: *mut lv_obj_t,
                                      src_img: *const ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_src(img as *mut lv_obj_t,
                               src_img as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the auto size feature."]
        #[doc =
          " If enabled the object size will be same as the picture size."]
        #[doc = " - __`img`__: pointer to an image"]
        #[doc =
          " - __`en`__: true: auto size enable, false: auto size disable"]
        pub fn set_auto_size(img: *mut lv_obj_t, autosize_en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable the auto size feature."]
                #[doc =
                  " If enabled the object size will be same as the picture size."]
                #[doc = " - __`img`__: pointer to an image"]
                #[doc =
                  " - __`en`__: true: auto size enable, false: auto size disable"]
                pub fn lv_img_set_auto_size(img: *mut lv_obj_t,
                                            autosize_en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_auto_size(img as *mut lv_obj_t,
                                     autosize_en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set an offset for the source of an image."]
        #[doc = " so the image will be displayed from the new origin."]
        #[doc = " - __`img`__: pointer to an image"]
        #[doc = " - __`x:`__: the new offset along x axis."]
        pub fn set_offset_x(img: *mut lv_obj_t, x: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set an offset for the source of an image."]
                #[doc =
                  " so the image will be displayed from the new origin."]
                #[doc = " - __`img`__: pointer to an image"]
                #[doc = " - __`x:`__: the new offset along x axis."]
                pub fn lv_img_set_offset_x(img: *mut lv_obj_t, x: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_offset_x(img as *mut lv_obj_t, x as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set an offset for the source of an image."]
        #[doc = " so the image will be displayed from the new origin."]
        #[doc = " - __`img`__: pointer to an image"]
        #[doc = " - __`y:`__: the new offset along y axis."]
        pub fn set_offset_y(img: *mut lv_obj_t, y: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set an offset for the source of an image."]
                #[doc =
                  " so the image will be displayed from the new origin."]
                #[doc = " - __`img`__: pointer to an image"]
                #[doc = " - __`y:`__: the new offset along y axis."]
                pub fn lv_img_set_offset_y(img: *mut lv_obj_t, y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_offset_y(img as *mut lv_obj_t, y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the rotation center of the image."]
        #[doc = " The image will be rotated around this point"]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " - __`pivot_x`__: rotation center x of the image"]
        #[doc = " - __`pivot_y`__: rotation center y of the image"]
        pub fn set_pivot(img: *mut lv_obj_t, pivot_x: lv_coord_t,
                         pivot_y: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the rotation center of the image."]
                #[doc = " The image will be rotated around this point"]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc = " - __`pivot_x`__: rotation center x of the image"]
                #[doc = " - __`pivot_y`__: rotation center y of the image"]
                pub fn lv_img_set_pivot(img: *mut lv_obj_t,
                                        pivot_x: lv_coord_t,
                                        pivot_y: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_pivot(img as *mut lv_obj_t, pivot_x as lv_coord_t,
                                 pivot_y as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the rotation angle of the image."]
        #[doc =
          " The image will be rotated around the set pivot set by `lv_img_set_pivot()`"]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc =
          " - __`angle`__: rotation angle in degree with 0.1 degree resolution (0..3600: clock wise)"]
        pub fn set_angle(img: *mut lv_obj_t, angle: i16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the rotation angle of the image."]
                #[doc =
                  " The image will be rotated around the set pivot set by `lv_img_set_pivot()`"]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc =
                  " - __`angle`__: rotation angle in degree with 0.1 degree resolution (0..3600: clock wise)"]
                pub fn lv_img_set_angle(img: *mut lv_obj_t, angle: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_angle(img as *mut lv_obj_t, angle as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the zoom factor of the image."]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " - __`zoom`__: the zoom factor."]
        #[doc = " - 256 or LV_ZOOM_IMG_NONE for no zoom"]
        #[doc = " - <256: scale down"]
        #[doc = " - >256 scale up"]
        #[doc = " - 128 half size"]
        #[doc = " - 512 double size"]
        pub fn set_zoom(img: *mut lv_obj_t, zoom: u16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the zoom factor of the image."]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc = " - __`zoom`__: the zoom factor."]
                #[doc = " - 256 or LV_ZOOM_IMG_NONE for no zoom"]
                #[doc = " - <256: scale down"]
                #[doc = " - >256 scale up"]
                #[doc = " - 128 half size"]
                #[doc = " - 512 double size"]
                pub fn lv_img_set_zoom(img: *mut lv_obj_t, zoom: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_zoom(img as *mut lv_obj_t, zoom as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable/disable anti-aliasing for the transformations (rotate, zoom) or not"]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc =
          " - __`antialias`__: true: anti-aliased; false: not anti-aliased"]
        pub fn set_antialias(img: *mut lv_obj_t, antialias: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable/disable anti-aliasing for the transformations (rotate, zoom) or not"]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc =
                  " - __`antialias`__: true: anti-aliased; false: not anti-aliased"]
                pub fn lv_img_set_antialias(img: *mut lv_obj_t,
                                            antialias: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_set_antialias(img as *mut lv_obj_t, antialias as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the source of the image"]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " Return: the image source (symbol, file name or C array)"]
        pub fn get_src(img: *mut lv_obj_t)
         -> MynewtResult<*const ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the source of the image"]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc =
                  " Return: the image source (symbol, file name or C array)"]
                pub fn lv_img_get_src(img: *mut lv_obj_t)
                -> *const ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_get_src(img as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the auto size enable attribute"]
        #[doc = " - __`img`__: pointer to an image"]
        #[doc =
          " Return: true: auto size is enabled, false: auto size is disabled"]
        pub fn get_auto_size(img: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the auto size enable attribute"]
                #[doc = " - __`img`__: pointer to an image"]
                #[doc =
                  " Return: true: auto size is enabled, false: auto size is disabled"]
                pub fn lv_img_get_auto_size(img: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_img_get_auto_size(img as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the offset.x attribute of the img object."]
        #[doc = " - __`img`__: pointer to an image"]
        #[doc = " Return: offset.x value."]
        pub fn get_offset_x(img: *mut lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the offset.x attribute of the img object."]
                #[doc = " - __`img`__: pointer to an image"]
                #[doc = " Return: offset.x value."]
                pub fn lv_img_get_offset_x(img: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_get_offset_x(img as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the offset.y attribute of the img object."]
        #[doc = " - __`img`__: pointer to an image"]
        #[doc = " Return: offset.y value."]
        pub fn get_offset_y(img: *mut lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the offset.y attribute of the img object."]
                #[doc = " - __`img`__: pointer to an image"]
                #[doc = " Return: offset.y value."]
                pub fn lv_img_get_offset_y(img: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_get_offset_y(img as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the rotation angle of the image."]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " Return: rotation angle in degree (0..359)"]
        pub fn get_angle(img: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the rotation angle of the image."]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc = " Return: rotation angle in degree (0..359)"]
                pub fn lv_img_get_angle(img: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_get_angle(img as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the rotation center of the image."]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " - __`center`__: rotation center of the image"]
        pub fn get_pivot(img: *mut lv_obj_t, center: *mut lv_point_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the rotation center of the image."]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc = " - __`center`__: rotation center of the image"]
                pub fn lv_img_get_pivot(img: *mut lv_obj_t,
                                        center: *mut lv_point_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_img_get_pivot(img as *mut lv_obj_t,
                                 center as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the zoom factor of the image."]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " Return: zoom factor (256: no zoom)"]
        pub fn get_zoom(img: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the zoom factor of the image."]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc = " Return: zoom factor (256: no zoom)"]
                pub fn lv_img_get_zoom(img: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_get_zoom(img as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get whether the transformations (rotate, zoom) are anti-aliased or not"]
        #[doc = " - __`img`__: pointer to an image object"]
        #[doc = " Return: true: anti-aliased; false: not anti-aliased"]
        pub fn get_antialias(img: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get whether the transformations (rotate, zoom) are anti-aliased or not"]
                #[doc = " - __`img`__: pointer to an image object"]
                #[doc =
                  " Return: true: anti-aliased; false: not anti-aliased"]
                pub fn lv_img_get_antialias(img: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_img_get_antialias(img as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Image Button Widget API `lv_imgbtn`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod imgbtn {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_IMGBTN_TILED: u32 = 0;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_img_cf_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_btn_state_t = u8;
        #[doc = " Extended data of button"]
        #[repr(C)]
        pub struct lv_btn_ext_t {
            #[doc = " Ext. of ancestor"]
            pub cont: lv_cont_ext_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_btn_ext_t {
            #[inline]
            fn default() -> lv_btn_ext_t {
                lv_btn_ext_t{cont: ::core::default::Default::default(),
                             _bitfield_1:
                                 ::core::default::Default::default(),}
            }
        }
        impl lv_btn_ext_t {
            #[inline]
            pub fn checkable(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_checkable(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(checkable: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let checkable: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(checkable)
                                                    };
                                                checkable as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_imgbtn_ext_t {
            pub btn: lv_btn_ext_t,
            pub img_src_mid: [*const ::cty::c_void; 6usize],
            pub act_cf: lv_img_cf_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        impl Default for lv_imgbtn_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_imgbtn_ext_t {
            #[inline]
            pub fn tiled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_tiled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(tiled: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let tiled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(tiled)
                                                    };
                                                tiled as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_IMGBTN_PART_MAIN: _bindgen_ty_38 = 0;
        pub type _bindgen_ty_38 = u32;
        pub type lv_imgbtn_part_t = u8;
        #[doc = " Create a image button objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new image button"]
        #[doc =
          " - __`copy`__: pointer to a image button object, if not NULL then the new object will be copied from"]
        #[doc = " it"]
        #[doc = " Return: pointer to the created image button"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a image button objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new image button"]
                #[doc =
                  " - __`copy`__: pointer to a image button object, if not NULL then the new object will be copied from"]
                #[doc = " it"]
                #[doc = " Return: pointer to the created image button"]
                pub fn lv_imgbtn_create(par: *mut lv_obj_t,
                                        copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_imgbtn_create(par as *mut lv_obj_t,
                                     copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set images for a state of the image button"]
        #[doc = " - __`imgbtn`__: pointer to an image button object"]
        #[doc =
          " - __`state`__: for which state set the new image (from `lv_btn_state_t`) `"]
        #[doc =
          " - __`src`__: pointer to an image source (a C array or path to a file)"]
        pub fn set_src(imgbtn: *mut lv_obj_t, state: lv_btn_state_t,
                       src: *const ::cty::c_void) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set images for a state of the image button"]
                #[doc = " - __`imgbtn`__: pointer to an image button object"]
                #[doc =
                  " - __`state`__: for which state set the new image (from `lv_btn_state_t`) `"]
                #[doc =
                  " - __`src`__: pointer to an image source (a C array or path to a file)"]
                pub fn lv_imgbtn_set_src(imgbtn: *mut lv_obj_t,
                                         state: lv_btn_state_t,
                                         src: *const ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_imgbtn_set_src(imgbtn as *mut lv_obj_t,
                                  state as lv_btn_state_t,
                                  src as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the toggled states. On release the button will change from/to toggled state."]
        #[doc = " - __`imgbtn`__: pointer to an image button object"]
        #[doc = " - __`tgl`__: true: enable toggled states, false: disable"]
        pub fn set_checkable(imgbtn: *mut lv_obj_t, tgl: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the toggled states. On release the button will change from/to toggled state."]
                #[doc = " - __`imgbtn`__: pointer to an image button object"]
                #[doc =
                  " - __`tgl`__: true: enable toggled states, false: disable"]
                pub fn lv_imgbtn_set_checkable(imgbtn: *mut lv_obj_t,
                                               tgl: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_imgbtn_set_checkable(imgbtn as *mut lv_obj_t, tgl as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the state of the image button"]
        #[doc = " - __`imgbtn`__: pointer to an image button object"]
        #[doc =
          " - __`state`__: the new state of the button (from lv_btn_state_t enum)"]
        pub fn set_state(imgbtn: *mut lv_obj_t, state: lv_btn_state_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the state of the image button"]
                #[doc = " - __`imgbtn`__: pointer to an image button object"]
                #[doc =
                  " - __`state`__: the new state of the button (from lv_btn_state_t enum)"]
                pub fn lv_imgbtn_set_state(imgbtn: *mut lv_obj_t,
                                           state: lv_btn_state_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_imgbtn_set_state(imgbtn as *mut lv_obj_t,
                                    state as lv_btn_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Toggle the state of the image button (ON->OFF, OFF->ON)"]
        #[doc = " - __`imgbtn`__: pointer to a image button object"]
        pub fn toggle(imgbtn: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Toggle the state of the image button (ON->OFF, OFF->ON)"]
                #[doc = " - __`imgbtn`__: pointer to a image button object"]
                pub fn lv_imgbtn_toggle(imgbtn: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_imgbtn_toggle(imgbtn as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the images in a  given state"]
        #[doc = " - __`imgbtn`__: pointer to an image button object"]
        #[doc =
          " - __`state`__: the state where to get the image (from `lv_btn_state_t`) `"]
        #[doc =
          " Return: pointer to an image source (a C array or path to a file)"]
        pub fn get_src(imgbtn: *mut lv_obj_t, state: lv_btn_state_t)
         -> MynewtResult<*const ::cty::c_void> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the images in a  given state"]
                #[doc = " - __`imgbtn`__: pointer to an image button object"]
                #[doc =
                  " - __`state`__: the state where to get the image (from `lv_btn_state_t`) `"]
                #[doc =
                  " Return: pointer to an image source (a C array or path to a file)"]
                pub fn lv_imgbtn_get_src(imgbtn: *mut lv_obj_t,
                                         state: lv_btn_state_t)
                -> *const ::cty::c_void;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_imgbtn_get_src(imgbtn as *mut lv_obj_t,
                                      state as lv_btn_state_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current state of the image button"]
        #[doc = " - __`imgbtn`__: pointer to a image button object"]
        #[doc = " Return: the state of the button (from lv_btn_state_t enum)"]
        pub fn get_state(imgbtn: *const lv_obj_t)
         -> MynewtResult<lv_btn_state_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current state of the image button"]
                #[doc = " - __`imgbtn`__: pointer to a image button object"]
                #[doc =
                  " Return: the state of the button (from lv_btn_state_t enum)"]
                pub fn lv_imgbtn_get_state(imgbtn: *const lv_obj_t)
                -> lv_btn_state_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_imgbtn_get_state(imgbtn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the toggle enable attribute of the image button"]
        #[doc = " - __`imgbtn`__: pointer to a image button object"]
        #[doc = " Return: true: toggle enabled, false: disabled"]
        pub fn get_checkable(imgbtn: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the toggle enable attribute of the image button"]
                #[doc = " - __`imgbtn`__: pointer to a image button object"]
                #[doc = " Return: true: toggle enabled, false: disabled"]
                pub fn lv_imgbtn_get_checkable(imgbtn: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_imgbtn_get_checkable(imgbtn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Keyboard Widget API `lv_keyboard`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod keyboard {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_btnmatrix_ctrl_t = u16;
        #[repr(C)]
        pub struct lv_btnmatrix_ext_t {
            pub map_p: *mut *const ::cty::c_char,
            pub button_areas: *mut lv_area_t,
            pub ctrl_bits: *mut lv_btnmatrix_ctrl_t,
            pub style_btn: lv_style_list_t,
            pub btn_cnt: u16,
            pub btn_id_pr: u16,
            pub btn_id_focused: u16,
            pub btn_id_act: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_btnmatrix_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_btnmatrix_ext_t {
            #[inline]
            pub fn recolor(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_recolor(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn one_check(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_one_check(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(recolor: u8, one_check: u8, align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let recolor: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(recolor)
                                                    };
                                                recolor as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let one_check: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(one_check)
                                                    };
                                                one_check as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 2u8,
                                            {
                                                let align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(align)
                                                    };
                                                align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_KEYBOARD_MODE_TEXT_LOWER: _bindgen_ty_43 = 0;
        pub const LV_KEYBOARD_MODE_TEXT_UPPER: _bindgen_ty_43 = 1;
        pub const LV_KEYBOARD_MODE_SPECIAL: _bindgen_ty_43 = 2;
        pub const LV_KEYBOARD_MODE_NUM: _bindgen_ty_43 = 3;
        #[doc = " Current keyboard mode."]
        pub type _bindgen_ty_43 = u32;
        pub type lv_keyboard_mode_t = u8;
        #[repr(C)]
        pub struct lv_keyboard_ext_t {
            pub btnm: lv_btnmatrix_ext_t,
            pub ta: *mut lv_obj_t,
            pub mode: lv_keyboard_mode_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        impl Default for lv_keyboard_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_keyboard_ext_t {
            #[inline]
            pub fn cursor_mng(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_cursor_mng(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(cursor_mng: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let cursor_mng: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(cursor_mng)
                                                    };
                                                cursor_mng as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_KEYBOARD_PART_BG: _bindgen_ty_44 = 0;
        pub const LV_KEYBOARD_PART_BTN: _bindgen_ty_44 = 1;
        pub type _bindgen_ty_44 = u32;
        pub type lv_keyboard_style_t = u8;
        #[doc = " Create a keyboard objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new keyboard"]
        #[doc =
          " - __`copy`__: pointer to a keyboard object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created keyboard"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a keyboard objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new keyboard"]
                #[doc =
                  " - __`copy`__: pointer to a keyboard object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created keyboard"]
                pub fn lv_keyboard_create(par: *mut lv_obj_t,
                                          copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_keyboard_create(par as *mut lv_obj_t,
                                       copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Assign a Text Area to the Keyboard. The pressed characters will be put there."]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc = " - __`ta`__: pointer to a Text Area object to write there"]
        pub fn set_textarea(kb: *mut lv_obj_t, ta: *mut lv_obj_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Assign a Text Area to the Keyboard. The pressed characters will be put there."]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc =
                  " - __`ta`__: pointer to a Text Area object to write there"]
                pub fn lv_keyboard_set_textarea(kb: *mut lv_obj_t,
                                                ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_keyboard_set_textarea(kb as *mut lv_obj_t,
                                         ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new a mode (text or number map)"]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc = " - __`mode`__: the mode from 'lv_keyboard_mode_t'"]
        pub fn set_mode(kb: *mut lv_obj_t, mode: lv_keyboard_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new a mode (text or number map)"]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc = " - __`mode`__: the mode from 'lv_keyboard_mode_t'"]
                pub fn lv_keyboard_set_mode(kb: *mut lv_obj_t,
                                            mode: lv_keyboard_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_keyboard_set_mode(kb as *mut lv_obj_t,
                                     mode as lv_keyboard_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Automatically hide or show the cursor of the current Text Area"]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc =
          " - __`en`__: true: show cursor on the current text area, false: hide cursor"]
        pub fn set_cursor_manage(kb: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Automatically hide or show the cursor of the current Text Area"]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc =
                  " - __`en`__: true: show cursor on the current text area, false: hide cursor"]
                pub fn lv_keyboard_set_cursor_manage(kb: *mut lv_obj_t,
                                                     en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_keyboard_set_cursor_manage(kb as *mut lv_obj_t,
                                              en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new map for the keyboard"]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc = " - __`mode`__: keyboard map to alter 'lv_keyboard_mode_t'"]
        #[doc =
          " - __`map`__: pointer to a string array to describe the map."]
        #[doc = "            See 'lv_btnmatrix_set_map()' for more info."]
        pub fn set_map(kb: *mut lv_obj_t, mode: lv_keyboard_mode_t,
                       map: *mut *const ::cty::c_char) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new map for the keyboard"]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc =
                  " - __`mode`__: keyboard map to alter 'lv_keyboard_mode_t'"]
                #[doc =
                  " - __`map`__: pointer to a string array to describe the map."]
                #[doc =
                  "            See 'lv_btnmatrix_set_map()' for more info."]
                pub fn lv_keyboard_set_map(kb: *mut lv_obj_t,
                                           mode: lv_keyboard_mode_t,
                                           map: *mut *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_keyboard_set_map(kb as *mut lv_obj_t,
                                    mode as lv_keyboard_mode_t,
                                    map as *mut *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the button control map (hidden, disabled etc.) for the keyboard. The"]
        #[doc =
          " control map array will be copied and so may be deallocated after this"]
        #[doc = " function returns."]
        #[doc = " - __`kb`__: pointer to a keyboard object"]
        #[doc =
          " - __`mode`__: keyboard ctrl map to alter 'lv_keyboard_mode_t'"]
        #[doc =
          " - __`ctrl_map`__: pointer to an array of `lv_btn_ctrl_t` control bytes."]
        #[doc =
          "                 See: `lv_btnmatrix_set_ctrl_map` for more details."]
        pub fn set_ctrl_map(kb: *mut lv_obj_t, mode: lv_keyboard_mode_t,
                            ctrl_map: *const lv_btnmatrix_ctrl_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the button control map (hidden, disabled etc.) for the keyboard. The"]
                #[doc =
                  " control map array will be copied and so may be deallocated after this"]
                #[doc = " function returns."]
                #[doc = " - __`kb`__: pointer to a keyboard object"]
                #[doc =
                  " - __`mode`__: keyboard ctrl map to alter 'lv_keyboard_mode_t'"]
                #[doc =
                  " - __`ctrl_map`__: pointer to an array of `lv_btn_ctrl_t` control bytes."]
                #[doc =
                  "                 See: `lv_btnmatrix_set_ctrl_map` for more details."]
                pub fn lv_keyboard_set_ctrl_map(kb: *mut lv_obj_t,
                                                mode: lv_keyboard_mode_t,
                                                ctrl_map:
                                                    *const lv_btnmatrix_ctrl_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_keyboard_set_ctrl_map(kb as *mut lv_obj_t,
                                         mode as lv_keyboard_mode_t,
                                         ctrl_map as
                                             *const lv_btnmatrix_ctrl_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Assign a Text Area to the Keyboard. The pressed characters will be put there."]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc = " Return: pointer to the assigned Text Area object"]
        pub fn get_textarea(kb: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Assign a Text Area to the Keyboard. The pressed characters will be put there."]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc = " Return: pointer to the assigned Text Area object"]
                pub fn lv_keyboard_get_textarea(kb: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_keyboard_get_textarea(kb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a new a mode (text or number map)"]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc = " Return: the current mode from 'lv_keyboard_mode_t'"]
        pub fn get_mode(kb: *const lv_obj_t)
         -> MynewtResult<lv_keyboard_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new a mode (text or number map)"]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc = " Return: the current mode from 'lv_keyboard_mode_t'"]
                pub fn lv_keyboard_get_mode(kb: *const lv_obj_t)
                -> lv_keyboard_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_keyboard_get_mode(kb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current cursor manage mode."]
        #[doc = " - __`kb`__: pointer to a Keyboard object"]
        #[doc =
          " Return: true: show cursor on the current text area, false: hide cursor"]
        pub fn get_cursor_manage(kb: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current cursor manage mode."]
                #[doc = " - __`kb`__: pointer to a Keyboard object"]
                #[doc =
                  " Return: true: show cursor on the current text area, false: hide cursor"]
                pub fn lv_keyboard_get_cursor_manage(kb: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_keyboard_get_cursor_manage(kb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current map of a keyboard"]
        #[doc = " - __`kb`__: pointer to a keyboard object"]
        #[doc = " Return: the current map"]
        pub fn get_map_array(kb: *const lv_obj_t)
         -> MynewtResult<*mut *const ::cty::c_char> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current map of a keyboard"]
                #[doc = " - __`kb`__: pointer to a keyboard object"]
                #[doc = " Return: the current map"]
                pub fn lv_keyboard_get_map_array(kb: *const lv_obj_t)
                -> *mut *const ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_keyboard_get_map_array(kb as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Default keyboard event to add characters to the Text area and change the map."]
        #[doc =
          " If a custom `event_cb` is added to the keyboard this function be called from it to handle the"]
        #[doc = " button clicks"]
        #[doc = " - __`kb`__: pointer to a  keyboard"]
        #[doc = " - __`event`__: the triggering event"]
        pub fn def_event_cb(kb: *mut lv_obj_t, event: lv_event_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Default keyboard event to add characters to the Text area and change the map."]
                #[doc =
                  " If a custom `event_cb` is added to the keyboard this function be called from it to handle the"]
                #[doc = " button clicks"]
                #[doc = " - __`kb`__: pointer to a  keyboard"]
                #[doc = " - __`event`__: the triggering event"]
                pub fn lv_keyboard_def_event_cb(kb: *mut lv_obj_t,
                                                event: lv_event_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_keyboard_def_event_cb(kb as *mut lv_obj_t,
                                         event as lv_event_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Label Widget API `lv_label`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod label {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_LABEL_DEF_SCROLL_SPEED: u32 = 25;
        pub const LV_LABEL_WAIT_CHAR_COUNT: u32 = 3;
        pub const LV_LABEL_TEXT_SEL: u32 = 0;
        pub const LV_LABEL_LONG_TXT_HINT: u32 = 0;
        pub const LV_LABEL_DOT_NUM: u32 = 3;
        pub const LV_LABEL_POS_LAST: u32 = 65535;
        pub const LV_LABEL_TEXT_SEL_OFF: u32 = 65535;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "< Expand the object size to the text size"]
        pub const LV_LABEL_LONG_EXPAND: lv_label_long_mode_t = 0;
        #[doc =
          "< Keep the object width, break the too long lines and expand the object"]
        #[doc = "height"]
        pub const LV_LABEL_LONG_BREAK: lv_label_long_mode_t = 1;
        #[doc =
          "< Keep the size and write dots at the end if the text is too long"]
        pub const LV_LABEL_LONG_DOT: lv_label_long_mode_t = 2;
        #[doc = "< Keep the size and roll the text back and forth"]
        pub const LV_LABEL_LONG_SROLL: lv_label_long_mode_t = 3;
        #[doc = "< Keep the size and roll the text circularly"]
        pub const LV_LABEL_LONG_SROLL_CIRC: lv_label_long_mode_t = 4;
        #[doc = "< Keep the size and crop the text out of it"]
        pub const LV_LABEL_LONG_CROP: lv_label_long_mode_t = 5;
        #[doc = " Long mode behaviors. Used in 'lv_label_ext_t'"]
        pub type _bindgen_ty_32 = u32;
        pub type lv_label_long_mode_t = u8;
        #[doc = "< Align text to left"]
        pub const LV_LABEL_ALIGN_LEFT: lv_label_align_t = 0;
        #[doc = "< Align text to center"]
        pub const LV_LABEL_ALIGN_CENTER: lv_label_align_t = 1;
        #[doc = "< Align text to right"]
        pub const LV_LABEL_ALIGN_RIGHT: lv_label_align_t = 2;
        #[doc =
          "< Use LEFT or RIGHT depending on the direction of the text (LTR/RTL)"]
        pub const LV_LABEL_ALIGN_AUTO: lv_label_align_t = 3;
        #[doc = " Label align policy"]
        pub type _bindgen_ty_33 = u32;
        pub type lv_label_align_t = u8;
        #[doc = " Data of label"]
        #[repr(C)]
        pub struct lv_label_ext_t {
            pub text: *mut ::cty::c_char,
            pub dot: lv_label_ext_t__bindgen_ty_1,
            pub dot_end: u32,
            pub anim_speed: u16,
            pub offset: lv_point_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        #[repr(C)]
        pub struct lv_label_ext_t__bindgen_ty_1 {
            pub tmp_ptr: __BindgenUnionField<*mut ::cty::c_char>,
            pub tmp: __BindgenUnionField<[::cty::c_char; 4usize]>,
            pub bindgen_union_field: u64,
        }
        impl Default for lv_label_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl Default for lv_label_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_label_ext_t {
            #[inline]
            pub fn long_mode(&self) -> lv_label_long_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_long_mode(&mut self, val: lv_label_long_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn static_txt(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_static_txt(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn recolor(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_recolor(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn expand(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_expand(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dot_tmp_alloc(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_dot_tmp_alloc(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(long_mode: lv_label_long_mode_t,
                                  static_txt: u8, align: u8, recolor: u8,
                                  expand: u8, dot_tmp_alloc: u8)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let long_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(long_mode)
                                                    };
                                                long_mode as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let static_txt: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(static_txt)
                                                    };
                                                static_txt as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(align)
                                                    };
                                                align as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let recolor: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(recolor)
                                                    };
                                                recolor as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let expand: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(expand)
                                                    };
                                                expand as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let dot_tmp_alloc: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(dot_tmp_alloc)
                                                    };
                                                dot_tmp_alloc as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_LABEL_PART_MAIN: _bindgen_ty_34 = 0;
        #[doc = " Label styles"]
        pub type _bindgen_ty_34 = u32;
        pub type lv_label_part_t = u8;
        #[doc = " Create a label objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new label"]
        #[doc =
          " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created button"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a label objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new label"]
                #[doc =
                  " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created button"]
                pub fn lv_label_create(par: *mut lv_obj_t,
                                       copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_create(par as *mut lv_obj_t,
                                    copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set a new text for a label. Memory will be allocated to store the text by the label."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`text`__: '\\0' terminated character string. NULL to refresh with the current text."]
        pub fn set_text(label: *mut lv_obj_t, text: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new text for a label. Memory will be allocated to store the text by the label."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`text`__: '\\0' terminated character string. NULL to refresh with the current text."]
                pub fn lv_label_set_text(label: *mut lv_obj_t,
                                         text: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            text.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text(label as *mut lv_obj_t,
                                  text.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a new formatted text for a label. Memory will be allocated to store the text by the label."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`fmt`__: `printf`-like format"]
        pub fn set_text_fmt(label: *mut lv_obj_t, fmt: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a new formatted text for a label. Memory will be allocated to store the text by the label."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " - __`fmt`__: `printf`-like format"]
                pub fn lv_label_set_text_fmt(label: *mut lv_obj_t,
                                             fmt: *const ::cty::c_char, ...);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            fmt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_fmt(label as *mut lv_obj_t,
                                      fmt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a static text. It will not be saved by the label so the 'text' variable"]
        #[doc = " has to be 'alive' while the label exist."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`text`__: pointer to a text. NULL to refresh with the current text."]
        pub fn set_text_static(label: *mut lv_obj_t, text: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a static text. It will not be saved by the label so the 'text' variable"]
                #[doc = " has to be 'alive' while the label exist."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`text`__: pointer to a text. NULL to refresh with the current text."]
                pub fn lv_label_set_text_static(label: *mut lv_obj_t,
                                                text: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            text.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_static(label as *mut lv_obj_t,
                                         text.as_ptr() as
                                             *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the behavior of the label with longer text then the object size"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`long_mode`__: the new mode from 'lv_label_long_mode' enum."]
        #[doc =
          "                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this"]
        #[doc = " function"]
        pub fn set_long_mode(label: *mut lv_obj_t,
                             long_mode: lv_label_long_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the behavior of the label with longer text then the object size"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`long_mode`__: the new mode from 'lv_label_long_mode' enum."]
                #[doc =
                  "                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this"]
                #[doc = " function"]
                pub fn lv_label_set_long_mode(label: *mut lv_obj_t,
                                              long_mode:
                                                  lv_label_long_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_long_mode(label as *mut lv_obj_t,
                                       long_mode as lv_label_long_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the align of the label (left or center)"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`align`__: 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'"]
        pub fn set_align(label: *mut lv_obj_t, align: lv_label_align_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the align of the label (left or center)"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`align`__: 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'"]
                pub fn lv_label_set_align(label: *mut lv_obj_t,
                                          align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_align(label as *mut lv_obj_t,
                                   align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable the recoloring by in-line commands"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`en`__: true: enable recoloring, false: disable"]
        pub fn set_recolor(label: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable the recoloring by in-line commands"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`en`__: true: enable recoloring, false: disable"]
                pub fn lv_label_set_recolor(label: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_recolor(label as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the label's animation speed in LV_LABEL_LONG_SROLL/SCROLL_CIRC modes"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " - __`anim_speed`__: speed of animation in px/sec unit"]
        pub fn set_anim_speed(label: *mut lv_obj_t, anim_speed: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the label's animation speed in LV_LABEL_LONG_SROLL/SCROLL_CIRC modes"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`anim_speed`__: speed of animation in px/sec unit"]
                pub fn lv_label_set_anim_speed(label: *mut lv_obj_t,
                                               anim_speed: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_anim_speed(label as *mut lv_obj_t,
                                        anim_speed as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " @brief Set the selection start index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
        pub fn set_text_sel_start(label: *mut lv_obj_t, index: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Set the selection start index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
                pub fn lv_label_set_text_sel_start(label: *mut lv_obj_t,
                                                   index: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_sel_start(label as *mut lv_obj_t,
                                            index as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " @brief Set the selection end index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
        pub fn set_text_sel_end(label: *mut lv_obj_t, index: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Set the selection end index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
                pub fn lv_label_set_text_sel_end(label: *mut lv_obj_t,
                                                 index: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_set_text_sel_end(label as *mut lv_obj_t,
                                          index as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the text of a label"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: the text of the label"]
        pub fn get_text(label: *const lv_obj_t)
         -> MynewtResult<*mut ::cty::c_char> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the text of a label"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: the text of the label"]
                pub fn lv_label_get_text(label: *const lv_obj_t)
                -> *mut ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_text(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the long mode of a label"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: the long mode"]
        pub fn get_long_mode(label: *const lv_obj_t)
         -> MynewtResult<lv_label_long_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the long mode of a label"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: the long mode"]
                pub fn lv_label_get_long_mode(label: *const lv_obj_t)
                -> lv_label_long_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_long_mode(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the align attribute"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER"]
        pub fn get_align(label: *const lv_obj_t)
         -> MynewtResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the align attribute"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " Return: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER"]
                pub fn lv_label_get_align(label: *const lv_obj_t)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_align(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the recoloring attribute"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: true: recoloring is enabled, false: disable"]
        pub fn get_recolor(label: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the recoloring attribute"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " Return: true: recoloring is enabled, false: disable"]
                pub fn lv_label_get_recolor(label: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_recolor(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the label's animation speed in LV_LABEL_LONG_ROLL and SCROLL modes"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc = " Return: speed of animation in px/sec unit"]
        pub fn get_anim_speed(label: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the label's animation speed in LV_LABEL_LONG_ROLL and SCROLL modes"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc = " Return: speed of animation in px/sec unit"]
                pub fn lv_label_get_anim_speed(label: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_anim_speed(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the relative x and y coordinates of a letter"]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`index`__: index of the letter [0 ... text length]. Expressed in character index, not byte"]
        #[doc = " index (different in UTF-8)"]
        #[doc =
          " - __`pos`__: store the result here (E.g. index = 0 gives 0;0 coordinates)"]
        pub fn get_letter_pos(label: *const lv_obj_t, index: u32,
                              pos: *mut lv_point_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the relative x and y coordinates of a letter"]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`index`__: index of the letter [0 ... text length]. Expressed in character index, not byte"]
                #[doc = " index (different in UTF-8)"]
                #[doc =
                  " - __`pos`__: store the result here (E.g. index = 0 gives 0;0 coordinates)"]
                pub fn lv_label_get_letter_pos(label: *const lv_obj_t,
                                               index: u32,
                                               pos: *mut lv_point_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_get_letter_pos(label as *const lv_obj_t,
                                        index as u32, pos as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the index of letter on a relative point of a label"]
        #[doc = " - __`label`__: pointer to label object"]
        #[doc =
          " - __`pos`__: pointer to point with coordinates on a the label"]
        #[doc =
          " Return: the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)"]
        #[doc =
          " Expressed in character index and not byte index (different in UTF-8)"]
        pub fn get_letter_on(label: *const lv_obj_t, pos: *mut lv_point_t)
         -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the index of letter on a relative point of a label"]
                #[doc = " - __`label`__: pointer to label object"]
                #[doc =
                  " - __`pos`__: pointer to point with coordinates on a the label"]
                #[doc =
                  " Return: the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)"]
                #[doc =
                  " Expressed in character index and not byte index (different in UTF-8)"]
                pub fn lv_label_get_letter_on(label: *const lv_obj_t,
                                              pos: *mut lv_point_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_letter_on(label as *const lv_obj_t,
                                           pos as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Check if a character is drawn under a point."]
        #[doc = " - __`label`__: Label object"]
        #[doc = " - __`pos`__: Point to check for character under"]
        #[doc = " Return: whether a character is drawn under the point"]
        pub fn is_char_under_pos(label: *const lv_obj_t, pos: *mut lv_point_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Check if a character is drawn under a point."]
                #[doc = " - __`label`__: Label object"]
                #[doc = " - __`pos`__: Point to check for character under"]
                #[doc =
                  " Return: whether a character is drawn under the point"]
                pub fn lv_label_is_char_under_pos(label: *const lv_obj_t,
                                                  pos: *mut lv_point_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_is_char_under_pos(label as *const lv_obj_t,
                                               pos as *mut lv_point_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " @brief Get the selection start index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " Return: selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
        pub fn get_text_sel_start(label: *const lv_obj_t)
         -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Get the selection start index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " Return: selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
                pub fn lv_label_get_text_sel_start(label: *const lv_obj_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_text_sel_start(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " @brief Get the selection end index."]
        #[doc = " - __`label`__: pointer to a label object."]
        #[doc =
          " Return: selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
        pub fn get_text_sel_end(label: *const lv_obj_t) -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " @brief Get the selection end index."]
                #[doc = " - __`label`__: pointer to a label object."]
                #[doc =
                  " Return: selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
                pub fn lv_label_get_text_sel_end(label: *const lv_obj_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_text_sel_end(label as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn get_style(label: *mut lv_obj_t, type_: u8)
         -> MynewtResult<*mut lv_style_list_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_label_get_style(label: *mut lv_obj_t, type_: u8)
                -> *mut lv_style_list_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_label_get_style(label as *mut lv_obj_t, type_ as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Insert a text to the label. The label text can not be static."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
        #[doc =
          " in UTF-8) 0: before first char. LV_LABEL_POS_LAST: after last char."]
        #[doc = " - __`txt`__: pointer to the text to insert"]
        pub fn ins_text(label: *mut lv_obj_t, pos: u32, txt: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Insert a text to the label. The label text can not be static."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
                #[doc =
                  " in UTF-8) 0: before first char. LV_LABEL_POS_LAST: after last char."]
                #[doc = " - __`txt`__: pointer to the text to insert"]
                pub fn lv_label_ins_text(label: *mut lv_obj_t, pos: u32,
                                         txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_ins_text(label as *mut lv_obj_t, pos as u32,
                                  txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Delete characters from a label. The label text can not be static."]
        #[doc = " - __`label`__: pointer to a label object"]
        #[doc =
          " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
        #[doc = " in UTF-8) 0: before first char."]
        #[doc = " - __`cnt`__: number of characters to cut"]
        pub fn cut_text(label: *mut lv_obj_t, pos: u32, cnt: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete characters from a label. The label text can not be static."]
                #[doc = " - __`label`__: pointer to a label object"]
                #[doc =
                  " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
                #[doc = " in UTF-8) 0: before first char."]
                #[doc = " - __`cnt`__: number of characters to cut"]
                pub fn lv_label_cut_text(label: *mut lv_obj_t, pos: u32,
                                         cnt: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_label_cut_text(label as *mut lv_obj_t, pos as u32,
                                  cnt as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL LED Widget API `lv_led`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod led {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_LED_BRIGHT_MIN: u32 = 120;
        pub const LV_LED_BRIGHT_MAX: u32 = 255;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_led_ext_t {
            pub bright: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_led_ext_t {
            #[inline]
            fn default() -> lv_led_ext_t {
                lv_led_ext_t{bright: ::core::default::Default::default(),}
            }
        }
        pub const LV_LED_PART_MAIN: _bindgen_ty_32 = 0;
        pub type _bindgen_ty_32 = u32;
        pub type lv_led_part_t = u8;
        #[doc = " Create a led objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new led"]
        #[doc =
          " - __`copy`__: pointer to a led object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created led"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a led objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new led"]
                #[doc =
                  " - __`copy`__: pointer to a led object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created led"]
                pub fn lv_led_create(par: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_led_create(par as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the brightness of a LED object"]
        #[doc = " - __`led`__: pointer to a LED object"]
        #[doc =
          " - __`bright`__: LV_LED_BRIGHT_MIN (max. dark) ... LV_LED_BRIGHT_MAX (max. light)"]
        pub fn set_bright(led: *mut lv_obj_t, bright: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the brightness of a LED object"]
                #[doc = " - __`led`__: pointer to a LED object"]
                #[doc =
                  " - __`bright`__: LV_LED_BRIGHT_MIN (max. dark) ... LV_LED_BRIGHT_MAX (max. light)"]
                pub fn lv_led_set_bright(led: *mut lv_obj_t, bright: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_led_set_bright(led as *mut lv_obj_t, bright as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Light on a LED"]
        #[doc = " - __`led`__: pointer to a LED object"]
        pub fn on(led: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Light on a LED"]
                #[doc = " - __`led`__: pointer to a LED object"]
                pub fn lv_led_on(led: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_led_on(led as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Light off a LED"]
        #[doc = " - __`led`__: pointer to a LED object"]
        pub fn off(led: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Light off a LED"]
                #[doc = " - __`led`__: pointer to a LED object"]
                pub fn lv_led_off(led: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_led_off(led as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Toggle the state of a LED"]
        #[doc = " - __`led`__: pointer to a LED object"]
        pub fn toggle(led: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Toggle the state of a LED"]
                #[doc = " - __`led`__: pointer to a LED object"]
                pub fn lv_led_toggle(led: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_led_toggle(led as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the brightness of a LEd object"]
        #[doc = " - __`led`__: pointer to LED object"]
        #[doc = " Return: bright 0 (max. dark) ... 255 (max. light)"]
        pub fn get_bright(led: *const lv_obj_t) -> MynewtResult<u8> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the brightness of a LEd object"]
                #[doc = " - __`led`__: pointer to LED object"]
                #[doc = " Return: bright 0 (max. dark) ... 255 (max. light)"]
                pub fn lv_led_get_bright(led: *const lv_obj_t)
                -> u8;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_led_get_bright(led as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Line Widget API `lv_line`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod line {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_LINEMETER_PRECISE: u32 = 0;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_line_ext_t {
            pub point_array: *const lv_point_t,
            pub point_num: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 5usize],
        }
        impl Default for lv_line_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_line_ext_t {
            #[inline]
            pub fn auto_size(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_size(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn y_inv(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_y_inv(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_size: u8, y_inv: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_size: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_size)
                                                    };
                                                auto_size as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let y_inv: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(y_inv)
                                                    };
                                                y_inv as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_LINE_PART_MAIN: _bindgen_ty_32 = 0;
        pub type _bindgen_ty_32 = u32;
        pub type lv_line_style_t = u8;
        #[doc = " Create a line objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new line"]
        #[doc = " Return: pointer to the created line"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a line objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new line"]
                #[doc = " Return: pointer to the created line"]
                pub fn lv_line_create(par: *mut lv_obj_t,
                                      copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_line_create(par as *mut lv_obj_t,
                                   copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Set an array of points. The line object will connect these points."]
        #[doc = " - __`line`__: pointer to a line object"]
        #[doc =
          " - __`point_a`__: an array of points. Only the address is saved,"]
        #[doc =
          " so the array can NOT be a local variable which will be destroyed"]
        #[doc = " - __`point_num`__: number of points in 'point_a'"]
        pub fn set_points(line: *mut lv_obj_t, point_a: *const lv_point_t,
                          point_num: u16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set an array of points. The line object will connect these points."]
                #[doc = " - __`line`__: pointer to a line object"]
                #[doc =
                  " - __`point_a`__: an array of points. Only the address is saved,"]
                #[doc =
                  " so the array can NOT be a local variable which will be destroyed"]
                #[doc = " - __`point_num`__: number of points in 'point_a'"]
                pub fn lv_line_set_points(line: *mut lv_obj_t,
                                          point_a: *const lv_point_t,
                                          point_num: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_line_set_points(line as *mut lv_obj_t,
                                   point_a as *const lv_point_t,
                                   point_num as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable (or disable) the auto-size option. The size of the object will fit to its points."]
        #[doc = " (set width to x max and height to y max)"]
        #[doc = " - __`line`__: pointer to a line object"]
        #[doc =
          " - __`en`__: true: auto size is enabled, false: auto size is disabled"]
        pub fn set_auto_size(line: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable (or disable) the auto-size option. The size of the object will fit to its points."]
                #[doc = " (set width to x max and height to y max)"]
                #[doc = " - __`line`__: pointer to a line object"]
                #[doc =
                  " - __`en`__: true: auto size is enabled, false: auto size is disabled"]
                pub fn lv_line_set_auto_size(line: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_line_set_auto_size(line as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable (or disable) the y coordinate inversion."]
        #[doc =
          " If enabled then y will be subtracted from the height of the object,"]
        #[doc = " therefore the y=0 coordinate will be on the bottom."]
        #[doc = " - __`line`__: pointer to a line object"]
        #[doc =
          " - __`en`__: true: enable the y inversion, false:disable the y inversion"]
        pub fn set_y_invert(line: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable (or disable) the y coordinate inversion."]
                #[doc =
                  " If enabled then y will be subtracted from the height of the object,"]
                #[doc =
                  " therefore the y=0 coordinate will be on the bottom."]
                #[doc = " - __`line`__: pointer to a line object"]
                #[doc =
                  " - __`en`__: true: enable the y inversion, false:disable the y inversion"]
                pub fn lv_line_set_y_invert(line: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_line_set_y_invert(line as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the auto size attribute"]
        #[doc = " - __`line`__: pointer to a line object"]
        #[doc = " Return: true: auto size is enabled, false: disabled"]
        pub fn get_auto_size(line: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the auto size attribute"]
                #[doc = " - __`line`__: pointer to a line object"]
                #[doc =
                  " Return: true: auto size is enabled, false: disabled"]
                pub fn lv_line_get_auto_size(line: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_line_get_auto_size(line as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the y inversion attribute"]
        #[doc = " - __`line`__: pointer to a line object"]
        #[doc = " Return: true: y inversion is enabled, false: disabled"]
        pub fn get_y_invert(line: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the y inversion attribute"]
                #[doc = " - __`line`__: pointer to a line object"]
                #[doc =
                  " Return: true: y inversion is enabled, false: disabled"]
                pub fn lv_line_get_y_invert(line: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_line_get_y_invert(line as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Line Meter Widget API `lv_linemeter`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod linemeter {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_LINEMETER_PRECISE: u32 = 0;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_linemeter_ext_t {
            pub scale_angle: u16,
            pub angle_ofs: u16,
            pub line_cnt: u16,
            pub cur_value: i32,
            pub min_value: i32,
            pub max_value: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_linemeter_ext_t {
            #[inline]
            fn default() -> lv_linemeter_ext_t {
                lv_linemeter_ext_t{scale_angle:
                                       ::core::default::Default::default(),
                                   angle_ofs:
                                       ::core::default::Default::default(),
                                   line_cnt:
                                       ::core::default::Default::default(),
                                   cur_value:
                                       ::core::default::Default::default(),
                                   min_value:
                                       ::core::default::Default::default(),
                                   max_value:
                                       ::core::default::Default::default(),
                                   _bitfield_1:
                                       ::core::default::Default::default(),
                                   __bindgen_padding_0:
                                       ::core::default::Default::default(),}
            }
        }
        impl lv_linemeter_ext_t {
            #[inline]
            pub fn mirrored(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mirrored(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(mirrored: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let mirrored: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mirrored)
                                                    };
                                                mirrored as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_LINEMETER_PART_MAIN: _bindgen_ty_32 = 0;
        pub const _LV_LINEMETER_PART_VIRTUAL_LAST: _bindgen_ty_32 = 1;
        pub const _LV_LINEMETER_PART_REAL_LAST: _bindgen_ty_32 = 64;
        pub type _bindgen_ty_32 = u32;
        pub type lv_linemeter_part_t = u8;
        #[doc = " Create a line meter objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new line meter"]
        #[doc =
          " - __`copy`__: pointer to a line meter object, if not NULL then the new object will be copied from"]
        #[doc = " it"]
        #[doc = " Return: pointer to the created line meter"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a line meter objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new line meter"]
                #[doc =
                  " - __`copy`__: pointer to a line meter object, if not NULL then the new object will be copied from"]
                #[doc = " it"]
                #[doc = " Return: pointer to the created line meter"]
                pub fn lv_linemeter_create(par: *mut lv_obj_t,
                                           copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_create(par as *mut lv_obj_t,
                                        copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a new value on the line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " - __`value`__: new value"]
        pub fn set_value(lmeter: *mut lv_obj_t, value: i32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new value on the line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " - __`value`__: new value"]
                pub fn lv_linemeter_set_value(lmeter: *mut lv_obj_t,
                                              value: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_linemeter_set_value(lmeter as *mut lv_obj_t, value as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set minimum and the maximum values of a line meter"]
        #[doc = " - __`lmeter`__: pointer to he line meter object"]
        #[doc = " - __`min`__: minimum value"]
        #[doc = " - __`max`__: maximum value"]
        pub fn set_range(lmeter: *mut lv_obj_t, min: i32, max: i32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set minimum and the maximum values of a line meter"]
                #[doc = " - __`lmeter`__: pointer to he line meter object"]
                #[doc = " - __`min`__: minimum value"]
                #[doc = " - __`max`__: maximum value"]
                pub fn lv_linemeter_set_range(lmeter: *mut lv_obj_t, min: i32,
                                              max: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_linemeter_set_range(lmeter as *mut lv_obj_t, min as i32,
                                       max as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the scale settings of a line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " - __`angle`__: angle of the scale (0..360)"]
        #[doc = " - __`line_cnt`__: number of lines"]
        pub fn set_scale(lmeter: *mut lv_obj_t, angle: u16, line_cnt: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scale settings of a line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " - __`angle`__: angle of the scale (0..360)"]
                #[doc = " - __`line_cnt`__: number of lines"]
                pub fn lv_linemeter_set_scale(lmeter: *mut lv_obj_t,
                                              angle: u16, line_cnt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_linemeter_set_scale(lmeter as *mut lv_obj_t, angle as u16,
                                       line_cnt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the set an offset for the line meter's angles to rotate it."]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " - __`angle`__: angle offset (0..360), rotates clockwise"]
        pub fn set_angle_offset(lmeter: *mut lv_obj_t, angle: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the set an offset for the line meter's angles to rotate it."]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc =
                  " - __`angle`__: angle offset (0..360), rotates clockwise"]
                pub fn lv_linemeter_set_angle_offset(lmeter: *mut lv_obj_t,
                                                     angle: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_linemeter_set_angle_offset(lmeter as *mut lv_obj_t,
                                              angle as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the orientation of the meter growth, clockwise or counterclockwise (mirrored)"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " - __`mirror`__: mirror setting"]
        pub fn set_mirror(lmeter: *mut lv_obj_t, mirror: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the orientation of the meter growth, clockwise or counterclockwise (mirrored)"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " - __`mirror`__: mirror setting"]
                pub fn lv_linemeter_set_mirror(lmeter: *mut lv_obj_t,
                                               mirror: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_linemeter_set_mirror(lmeter as *mut lv_obj_t,
                                        mirror as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the value of a line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: the value of the line meter"]
        pub fn get_value(lmeter: *const lv_obj_t) -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the value of a line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: the value of the line meter"]
                pub fn lv_linemeter_get_value(lmeter: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_value(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the minimum value of a line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: the minimum value of the line meter"]
        pub fn get_min_value(lmeter: *const lv_obj_t) -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the minimum value of a line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: the minimum value of the line meter"]
                pub fn lv_linemeter_get_min_value(lmeter: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_min_value(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the maximum value of a line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: the maximum value of the line meter"]
        pub fn get_max_value(lmeter: *const lv_obj_t) -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the maximum value of a line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: the maximum value of the line meter"]
                pub fn lv_linemeter_get_max_value(lmeter: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_max_value(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scale number of a line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: number of the scale units"]
        pub fn get_line_count(lmeter: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scale number of a line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: number of the scale units"]
                pub fn lv_linemeter_get_line_count(lmeter: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_line_count(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scale angle of a line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: angle of the scale"]
        pub fn get_scale_angle(lmeter: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scale angle of a line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: angle of the scale"]
                pub fn lv_linemeter_get_scale_angle(lmeter: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_scale_angle(lmeter as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the offset for the line meter."]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: angle offset (0..360)"]
        pub fn get_angle_offset(lmeter: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the offset for the line meter."]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: angle offset (0..360)"]
                pub fn lv_linemeter_get_angle_offset(lmeter: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_angle_offset(lmeter as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn draw_scale(lmeter: *mut lv_obj_t, clip_area: *const lv_area_t,
                          part: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn lv_linemeter_draw_scale(lmeter: *mut lv_obj_t,
                                               clip_area: *const lv_area_t,
                                               part: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_linemeter_draw_scale(lmeter as *mut lv_obj_t,
                                        clip_area as *const lv_area_t,
                                        part as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " get the mirror setting for the line meter"]
        #[doc = " - __`lmeter`__: pointer to a line meter object"]
        #[doc = " Return: mirror (true or false)"]
        pub fn get_mirror(lmeter: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " get the mirror setting for the line meter"]
                #[doc = " - __`lmeter`__: pointer to a line meter object"]
                #[doc = " Return: mirror (true or false)"]
                pub fn lv_linemeter_get_mirror(lmeter: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_linemeter_get_mirror(lmeter as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL List Widget API `lv_list`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod list {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_LIST_DEF_ANIM_TIME: u32 = 100;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_scrollbar_mode_t = u8;
        #[repr(C)]
        pub struct lv_page_ext_t {
            pub bg: lv_cont_ext_t,
            pub scrl: *mut lv_obj_t,
            pub scrlbar: lv_page_ext_t__bindgen_ty_1,
            pub edge_flash: lv_page_ext_t__bindgen_ty_2,
            pub anim_time: u16,
            pub scroll_prop_obj: *mut lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub hor_area: lv_area_t,
            pub ver_area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn hor_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hor_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ver_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ver_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mode(&self) -> lv_scrollbar_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(hor_draw: u8, ver_draw: u8,
                                  mode: lv_scrollbar_mode_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let hor_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hor_draw)
                                                    };
                                                hor_draw as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let ver_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ver_draw)
                                                    };
                                                ver_draw as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_2 {
            pub state: lv_anim_value_t,
            pub style: lv_style_list_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_2 {
            #[inline]
            pub fn enabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_enabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bottom_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_bottom_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn right_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn left_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_left_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(enabled: u8, top_ip: u8, bottom_ip: u8,
                                  right_ip: u8, left_ip: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let enabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(enabled)
                                                    };
                                                enabled as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let top_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top_ip)
                                                    };
                                                top_ip as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let bottom_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(bottom_ip)
                                                    };
                                                bottom_ip as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let right_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_ip)
                                                    };
                                                right_ip as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let left_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(left_ip)
                                                    };
                                                left_ip as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_page_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t {
            #[inline]
            pub fn scroll_prop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_scroll_prop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(scroll_prop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let scroll_prop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(scroll_prop)
                                                    };
                                                scroll_prop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_list_ext_t {
            pub page: lv_page_ext_t,
            pub act_sel_btn: *mut lv_obj_t,
        }
        impl Default for lv_list_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "< List background style"]
        pub const LV_LIST_PART_BG: _bindgen_ty_45 = 0;
        #[doc = "< List scrollbar style."]
        pub const LV_LIST_PART_SCROLLBAR: _bindgen_ty_45 = 1;
        #[doc = "< List edge flash style."]
        pub const LV_LIST_PART_EDGE_FLASH: _bindgen_ty_45 = 2;
        pub const _LV_LIST_PART_VIRTUAL_LAST: _bindgen_ty_45 = 3;
        #[doc = "< List scrollable area style."]
        pub const LV_LIST_PART_SCROLLABLE: _bindgen_ty_45 = 64;
        pub const _LV_LIST_PART_REAL_LAST: _bindgen_ty_45 = 65;
        #[doc = " List styles."]
        pub type _bindgen_ty_45 = u32;
        pub type lv_list_style_t = u8;
        #[doc = " Create a list objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new list"]
        #[doc =
          " - __`copy`__: pointer to a list object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created list"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a list objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new list"]
                #[doc =
                  " - __`copy`__: pointer to a list object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created list"]
                pub fn lv_list_create(par: *mut lv_obj_t,
                                      copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_create(par as *mut lv_obj_t,
                                   copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Delete all children of the scrl object, without deleting scrl child."]
        #[doc = " - __`list`__: pointer to an object"]
        pub fn clean(list: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete all children of the scrl object, without deleting scrl child."]
                #[doc = " - __`list`__: pointer to an object"]
                pub fn lv_list_clean(list: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_clean(list as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Add a list element to the list"]
        #[doc = " - __`list`__: pointer to list object"]
        #[doc =
          " - __`img_fn`__: file name of an image before the text (NULL if unused)"]
        #[doc = " - __`txt`__: text of the list element (NULL if unused)"]
        #[doc =
          " Return: pointer to the new list element which can be customized (a button)"]
        pub fn add_btn(list: *mut lv_obj_t, img_src: *const ::cty::c_void,
                       txt: &Strn) -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add a list element to the list"]
                #[doc = " - __`list`__: pointer to list object"]
                #[doc =
                  " - __`img_fn`__: file name of an image before the text (NULL if unused)"]
                #[doc =
                  " - __`txt`__: text of the list element (NULL if unused)"]
                #[doc =
                  " Return: pointer to the new list element which can be customized (a button)"]
                pub fn lv_list_add_btn(list: *mut lv_obj_t,
                                       img_src: *const ::cty::c_void,
                                       txt: *const ::cty::c_char)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_add_btn(list as *mut lv_obj_t,
                                    img_src as *const ::cty::c_void,
                                    txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Remove the index of the button in the list"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc =
          " - __`index`__: pointer to a the button's index in the list, index must be 0 <= index <"]
        #[doc = " lv_list_ext_t.size"]
        #[doc = " Return: true: successfully deleted"]
        pub fn remove(list: *const lv_obj_t, index: u16)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove the index of the button in the list"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc =
                  " - __`index`__: pointer to a the button's index in the list, index must be 0 <= index <"]
                #[doc = " lv_list_ext_t.size"]
                #[doc = " Return: true: successfully deleted"]
                pub fn lv_list_remove(list: *const lv_obj_t, index: u16)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_remove(list as *const lv_obj_t, index as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Make a button selected"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " - __`btn`__: pointer to a button to select"]
        #[doc = "            NULL to not select any buttons"]
        pub fn focus_btn(list: *mut lv_obj_t, btn: *mut lv_obj_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Make a button selected"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc = " - __`btn`__: pointer to a button to select"]
                #[doc = "            NULL to not select any buttons"]
                pub fn lv_list_focus_btn(list: *mut lv_obj_t,
                                         btn: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_focus_btn(list as *mut lv_obj_t,
                                  btn as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the scroll bar mode of a list"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc =
          " - __`sb_mode`__: the new mode from 'lv_page_sb_mode_t' enum"]
        pub fn set_scrollbar_mode(list: *mut lv_obj_t,
                                  mode: lv_scrollbar_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scroll bar mode of a list"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc =
                  " - __`sb_mode`__: the new mode from 'lv_page_sb_mode_t' enum"]
                pub fn lv_list_set_scrollbar_mode(list: *mut lv_obj_t,
                                                  mode: lv_scrollbar_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_set_scrollbar_mode(list as *mut lv_obj_t,
                                           mode as lv_scrollbar_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the scroll propagation feature. If enabled then the List will move its parent if there is"]
        #[doc = " no more space to scroll."]
        #[doc = " - __`list`__: pointer to a List"]
        #[doc =
          " - __`en`__: true or false to enable/disable scroll propagation"]
        pub fn set_scroll_propagation(list: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the scroll propagation feature. If enabled then the List will move its parent if there is"]
                #[doc = " no more space to scroll."]
                #[doc = " - __`list`__: pointer to a List"]
                #[doc =
                  " - __`en`__: true or false to enable/disable scroll propagation"]
                pub fn lv_list_set_scroll_propagation(list: *mut lv_obj_t,
                                                      en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_set_scroll_propagation(list as *mut lv_obj_t,
                                               en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
        #[doc = " - __`list`__: pointer to a List"]
        #[doc = " - __`en`__: true or false to enable/disable end flash"]
        pub fn set_edge_flash(list: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
                #[doc = " - __`list`__: pointer to a List"]
                #[doc =
                  " - __`en`__: true or false to enable/disable end flash"]
                pub fn lv_list_set_edge_flash(list: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_set_edge_flash(list as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set scroll animation duration on 'list_up()' 'list_down()' 'list_focus()'"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " - __`anim_time`__: duration of animation [ms]"]
        pub fn set_anim_time(list: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set scroll animation duration on 'list_up()' 'list_down()' 'list_focus()'"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc = " - __`anim_time`__: duration of animation [ms]"]
                pub fn lv_list_set_anim_time(list: *mut lv_obj_t,
                                             anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_set_anim_time(list as *mut lv_obj_t,
                                      anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set layout of a list"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " - __`layout`__: which layout should be used"]
        pub fn set_layout(list: *mut lv_obj_t, layout: lv_layout_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set layout of a list"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc = " - __`layout`__: which layout should be used"]
                pub fn lv_list_set_layout(list: *mut lv_obj_t,
                                          layout: lv_layout_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_set_layout(list as *mut lv_obj_t,
                                   layout as lv_layout_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the label object from a list element"]
        #[doc = " - __`btn`__: pointer to a list element (button)"]
        #[doc =
          " Return: pointer to the label from the list element or NULL if not found"]
        pub fn get_btn_label(btn: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the label object from a list element"]
                #[doc = " - __`btn`__: pointer to a list element (button)"]
                #[doc =
                  " Return: pointer to the label from the list element or NULL if not found"]
                pub fn lv_list_get_btn_label(btn: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_btn_label(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the image object from a list element"]
        #[doc = " - __`btn`__: pointer to a list element (button)"]
        #[doc =
          " Return: pointer to the image from the list element or NULL if not found"]
        pub fn get_btn_img(btn: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the image object from a list element"]
                #[doc = " - __`btn`__: pointer to a list element (button)"]
                #[doc =
                  " Return: pointer to the image from the list element or NULL if not found"]
                pub fn lv_list_get_btn_img(btn: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_btn_img(btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the next button from list. (Starts from the bottom button)"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc =
          " - __`prev_btn`__: pointer to button. Search the next after it."]
        #[doc =
          " Return: pointer to the next button or NULL when no more buttons"]
        pub fn get_prev_btn(list: *const lv_obj_t, prev_btn: *mut lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the next button from list. (Starts from the bottom button)"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc =
                  " - __`prev_btn`__: pointer to button. Search the next after it."]
                #[doc =
                  " Return: pointer to the next button or NULL when no more buttons"]
                pub fn lv_list_get_prev_btn(list: *const lv_obj_t,
                                            prev_btn: *mut lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_prev_btn(list as *const lv_obj_t,
                                         prev_btn as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the previous button from list. (Starts from the top button)"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc =
          " - __`prev_btn`__: pointer to button. Search the previous before it."]
        #[doc =
          " Return: pointer to the previous button or NULL when no more buttons"]
        pub fn get_next_btn(list: *const lv_obj_t, prev_btn: *mut lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the previous button from list. (Starts from the top button)"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc =
                  " - __`prev_btn`__: pointer to button. Search the previous before it."]
                #[doc =
                  " Return: pointer to the previous button or NULL when no more buttons"]
                pub fn lv_list_get_next_btn(list: *const lv_obj_t,
                                            prev_btn: *mut lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_next_btn(list as *const lv_obj_t,
                                         prev_btn as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the index of the button in the list"]
        #[doc =
          " - __`list`__: pointer to a list object. If NULL, assumes btn is part of a list."]
        #[doc = " - __`btn`__: pointer to a list element (button)"]
        #[doc =
          " Return: the index of the button in the list, or -1 of the button not in this list"]
        pub fn get_btn_index(list: *const lv_obj_t, btn: *const lv_obj_t)
         -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the index of the button in the list"]
                #[doc =
                  " - __`list`__: pointer to a list object. If NULL, assumes btn is part of a list."]
                #[doc = " - __`btn`__: pointer to a list element (button)"]
                #[doc =
                  " Return: the index of the button in the list, or -1 of the button not in this list"]
                pub fn lv_list_get_btn_index(list: *const lv_obj_t,
                                             btn: *const lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_btn_index(list as *const lv_obj_t,
                                          btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of buttons in the list"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " Return: the number of buttons in the list"]
        pub fn get_size(list: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of buttons in the list"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc = " Return: the number of buttons in the list"]
                pub fn lv_list_get_size(list: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_list_get_size(list as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get layout of a list"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " Return: layout of the list object"]
        pub fn get_layout(list: *mut lv_obj_t) -> MynewtResult<lv_layout_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get layout of a list"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc = " Return: layout of the list object"]
                pub fn lv_list_get_layout(list: *mut lv_obj_t)
                -> lv_layout_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_list_get_layout(list as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll bar mode of a list"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " Return: scrollbar mode from 'lv_scrollbar_mode_t' enum"]
        pub fn get_scrollbar_mode(list: *const lv_obj_t)
         -> MynewtResult<lv_scrollbar_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll bar mode of a list"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc =
                  " Return: scrollbar mode from 'lv_scrollbar_mode_t' enum"]
                pub fn lv_list_get_scrollbar_mode(list: *const lv_obj_t)
                -> lv_scrollbar_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_scrollbar_mode(list as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll propagation property"]
        #[doc = " - __`list`__: pointer to a List"]
        #[doc = " Return: true or false"]
        pub fn get_scroll_propagation(list: *mut lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll propagation property"]
                #[doc = " - __`list`__: pointer to a List"]
                #[doc = " Return: true or false"]
                pub fn lv_list_get_scroll_propagation(list: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_scroll_propagation(list as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll propagation property"]
        #[doc = " - __`list`__: pointer to a List"]
        #[doc = " Return: true or false"]
        pub fn get_edge_flash(list: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll propagation property"]
                #[doc = " - __`list`__: pointer to a List"]
                #[doc = " Return: true or false"]
                pub fn lv_list_get_edge_flash(list: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_edge_flash(list as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get scroll animation duration"]
        #[doc = " - __`list`__: pointer to a list object"]
        #[doc = " Return: duration of animation [ms]"]
        pub fn get_anim_time(list: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get scroll animation duration"]
                #[doc = " - __`list`__: pointer to a list object"]
                #[doc = " Return: duration of animation [ms]"]
                pub fn lv_list_get_anim_time(list: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_list_get_anim_time(list as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Move the list elements up by one"]
        #[doc = " - __`list`__: pointer a to list object"]
        pub fn up(list: *const lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move the list elements up by one"]
                #[doc = " - __`list`__: pointer a to list object"]
                pub fn lv_list_up(list: *const lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_up(list as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move the list elements down by one"]
        #[doc = " - __`list`__: pointer to a list object"]
        pub fn down(list: *const lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move the list elements down by one"]
                #[doc = " - __`list`__: pointer to a list object"]
                pub fn lv_list_down(list: *const lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_down(list as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Focus on a list button. It ensures that the button will be visible on the list."]
        #[doc = " - __`btn`__: pointer to a list button to focus"]
        #[doc =
          " - __`anim`__: LV_ANOM_ON: scroll with animation, LV_ANIM_OFF: without animation"]
        pub fn focus(btn: *const lv_obj_t, anim: lv_anim_enable_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Focus on a list button. It ensures that the button will be visible on the list."]
                #[doc = " - __`btn`__: pointer to a list button to focus"]
                #[doc =
                  " - __`anim`__: LV_ANOM_ON: scroll with animation, LV_ANIM_OFF: without animation"]
                pub fn lv_list_focus(btn: *const lv_obj_t,
                                     anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_list_focus(btn as *const lv_obj_t,
                              anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Message Box Widget API `lv_msgbox`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod msgbox {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_msgbox_ext_t {
            pub bg: lv_cont_ext_t,
            pub text: *mut lv_obj_t,
            pub btnm: *mut lv_obj_t,
            pub anim_time: u16,
        }
        impl Default for lv_msgbox_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub const LV_MSGBOX_PART_BG: _bindgen_ty_43 = 0;
        pub const LV_MSGBOX_PART_BTN_BG: _bindgen_ty_43 = 64;
        pub const LV_MSGBOX_PART_BTN: _bindgen_ty_43 = 65;
        #[doc = " Message box styles."]
        pub type _bindgen_ty_43 = u32;
        pub type lv_msgbox_style_t = u8;
        #[doc = " Create a message box objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new message box"]
        #[doc =
          " - __`copy`__: pointer to a message box object, if not NULL then the new object will be copied from"]
        #[doc = " it"]
        #[doc = " Return: pointer to the created message box"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a message box objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new message box"]
                #[doc =
                  " - __`copy`__: pointer to a message box object, if not NULL then the new object will be copied from"]
                #[doc = " it"]
                #[doc = " Return: pointer to the created message box"]
                pub fn lv_msgbox_create(par: *mut lv_obj_t,
                                        copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_msgbox_create(par as *mut lv_obj_t,
                                     copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Add button to the message box"]
        #[doc = " - __`mbox`__: pointer to message box object"]
        #[doc = " - __`btn_map`__: button descriptor (button matrix map)."]
        #[doc =
          "                E.g.  a const char *txt[] = {\"ok\", \"close\", \"\"} (Can not be local variable)"]
        pub fn add_btns(mbox: *mut lv_obj_t,
                        btn_mapaction: *mut *const ::cty::c_char)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add button to the message box"]
                #[doc = " - __`mbox`__: pointer to message box object"]
                #[doc =
                  " - __`btn_map`__: button descriptor (button matrix map)."]
                #[doc =
                  "                E.g.  a const char *txt[] = {\"ok\", \"close\", \"\"} (Can not be local variable)"]
                pub fn lv_msgbox_add_btns(mbox: *mut lv_obj_t,
                                          btn_mapaction:
                                              *mut *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_msgbox_add_btns(mbox as *mut lv_obj_t,
                                   btn_mapaction as
                                       *mut *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the text of the message box"]
        #[doc = " - __`mbox`__: pointer to a message box"]
        #[doc =
          " - __`txt`__: a '\\0' terminated character string which will be the message box text"]
        pub fn set_text(mbox: *mut lv_obj_t, txt: &Strn) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the text of the message box"]
                #[doc = " - __`mbox`__: pointer to a message box"]
                #[doc =
                  " - __`txt`__: a '\\0' terminated character string which will be the message box text"]
                pub fn lv_msgbox_set_text(mbox: *mut lv_obj_t,
                                          txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_msgbox_set_text(mbox as *mut lv_obj_t,
                                   txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set animation duration"]
        #[doc = " - __`mbox`__: pointer to a message box object"]
        #[doc =
          " - __`anim_time`__: animation length in  milliseconds (0: no animation)"]
        pub fn set_anim_time(mbox: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set animation duration"]
                #[doc = " - __`mbox`__: pointer to a message box object"]
                #[doc =
                  " - __`anim_time`__: animation length in  milliseconds (0: no animation)"]
                pub fn lv_msgbox_set_anim_time(mbox: *mut lv_obj_t,
                                               anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_msgbox_set_anim_time(mbox as *mut lv_obj_t,
                                        anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Automatically delete the message box after a given time"]
        #[doc = " - __`mbox`__: pointer to a message box object"]
        #[doc =
          " - __`delay`__: a time (in milliseconds) to wait before delete the message box"]
        pub fn start_auto_close(mbox: *mut lv_obj_t, delay: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Automatically delete the message box after a given time"]
                #[doc = " - __`mbox`__: pointer to a message box object"]
                #[doc =
                  " - __`delay`__: a time (in milliseconds) to wait before delete the message box"]
                pub fn lv_msgbox_start_auto_close(mbox: *mut lv_obj_t,
                                                  delay: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_msgbox_start_auto_close(mbox as *mut lv_obj_t,
                                           delay as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Stop the auto. closing of message box"]
        #[doc = " - __`mbox`__: pointer to a message box object"]
        pub fn stop_auto_close(mbox: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Stop the auto. closing of message box"]
                #[doc = " - __`mbox`__: pointer to a message box object"]
                pub fn lv_msgbox_stop_auto_close(mbox: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_msgbox_stop_auto_close(mbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set whether recoloring is enabled. Must be called after `lv_msgbox_add_btns`."]
        #[doc = " - __`mbox`__: pointer to message box object"]
        #[doc = " - __`en`__: whether recoloring is enabled"]
        pub fn set_recolor(mbox: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set whether recoloring is enabled. Must be called after `lv_msgbox_add_btns`."]
                #[doc = " - __`mbox`__: pointer to message box object"]
                #[doc = " - __`en`__: whether recoloring is enabled"]
                pub fn lv_msgbox_set_recolor(mbox: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_msgbox_set_recolor(mbox as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get the index of the lastly \"activated\" button by the user (pressed, released etc)"]
        #[doc = " Useful in the the `event_cb`."]
        #[doc = " - __`mbox`__: pointer to message box object"]
        #[doc =
          " Return:  index of the last released button (LV_BTNMATRIX_BTN_NONE: if unset)"]
        pub fn get_active_btn(mbox: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the index of the lastly \"activated\" button by the user (pressed, released etc)"]
                #[doc = " Useful in the the `event_cb`."]
                #[doc = " - __`mbox`__: pointer to message box object"]
                #[doc =
                  " Return:  index of the last released button (LV_BTNMATRIX_BTN_NONE: if unset)"]
                pub fn lv_msgbox_get_active_btn(mbox: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_msgbox_get_active_btn(mbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation duration (close animation time)"]
        #[doc = " - __`mbox`__: pointer to a message box object"]
        #[doc =
          " Return: animation length in  milliseconds (0: no animation)"]
        pub fn get_anim_time(mbox: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation duration (close animation time)"]
                #[doc = " - __`mbox`__: pointer to a message box object"]
                #[doc =
                  " Return: animation length in  milliseconds (0: no animation)"]
                pub fn lv_msgbox_get_anim_time(mbox: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_msgbox_get_anim_time(mbox as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether recoloring is enabled"]
        #[doc = " - __`mbox`__: pointer to a message box object"]
        #[doc = " Return: whether recoloring is enabled"]
        pub fn get_recolor(mbox: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether recoloring is enabled"]
                #[doc = " - __`mbox`__: pointer to a message box object"]
                #[doc = " Return: whether recoloring is enabled"]
                pub fn lv_msgbox_get_recolor(mbox: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_msgbox_get_recolor(mbox as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get message box button matrix"]
        #[doc = " - __`mbox`__: pointer to a message box object"]
        #[doc = " Return: pointer to button matrix object"]
        #[doc =
          " @remarks return value will be NULL unless `lv_msgbox_add_btns` has been already called"]
        pub fn get_btnmatrix(mbox: *mut lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get message box button matrix"]
                #[doc = " - __`mbox`__: pointer to a message box object"]
                #[doc = " Return: pointer to button matrix object"]
                #[doc =
                  " @remarks return value will be NULL unless `lv_msgbox_add_btns` has been already called"]
                pub fn lv_msgbox_get_btnmatrix(mbox: *mut lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_msgbox_get_btnmatrix(mbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Object Mask Widget API `lv_objmask`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod objmask {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_objmask_mask_t {
            pub param: *mut ::cty::c_void,
        }
        impl Default for lv_objmask_mask_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_objmask_ext_t {
            pub cont: lv_cont_ext_t,
            pub mask_ll: lv_ll_t,
        }
        impl Default for lv_objmask_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub const LV_OBJMASK_PART_MAIN: _bindgen_ty_35 = 0;
        pub type _bindgen_ty_35 = u32;
        pub type lv_objmask_part_t = u8;
        #[doc = " Create a object mask objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new object mask"]
        #[doc =
          " - __`copy`__: pointer to a object mask object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created object mask"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a object mask objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new object mask"]
                #[doc =
                  " - __`copy`__: pointer to a object mask object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created object mask"]
                pub fn lv_objmask_create(par: *mut lv_obj_t,
                                         copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_objmask_create(par as *mut lv_obj_t,
                                      copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Add a mask"]
        #[doc = " - __`objmask`__: pointer to an Object mask object"]
        #[doc = " - __`param`__: an initialized mask parameter"]
        #[doc = " Return: pointer to the added mask"]
        pub fn add_mask(objmask: *mut lv_obj_t, param: Ptr)
         -> MynewtResult<*mut lv_objmask_mask_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add a mask"]
                #[doc = " - __`objmask`__: pointer to an Object mask object"]
                #[doc = " - __`param`__: an initialized mask parameter"]
                #[doc = " Return: pointer to the added mask"]
                pub fn lv_objmask_add_mask(objmask: *mut lv_obj_t,
                                           param: *mut ::cty::c_void)
                -> *mut lv_objmask_mask_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_objmask_add_mask(objmask as *mut lv_obj_t,
                                        param as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Update an already created mask"]
        #[doc = " - __`objmask`__: pointer to an Object mask object"]
        #[doc =
          " - __`mask`__: pointer to created mask (returned by `lv_objmask_add_mask`)"]
        #[doc =
          " - __`param`__: an initialized mask parameter (initialized by `lv_draw_mask_line/angle/.../_init`)"]
        pub fn update_mask(objmask: *mut lv_obj_t,
                           mask: *mut lv_objmask_mask_t, param: Ptr)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Update an already created mask"]
                #[doc = " - __`objmask`__: pointer to an Object mask object"]
                #[doc =
                  " - __`mask`__: pointer to created mask (returned by `lv_objmask_add_mask`)"]
                #[doc =
                  " - __`param`__: an initialized mask parameter (initialized by `lv_draw_mask_line/angle/.../_init`)"]
                pub fn lv_objmask_update_mask(objmask: *mut lv_obj_t,
                                              mask: *mut lv_objmask_mask_t,
                                              param: *mut ::cty::c_void);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_objmask_update_mask(objmask as *mut lv_obj_t,
                                       mask as *mut lv_objmask_mask_t,
                                       param as *mut ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Remove a mask"]
        #[doc = " - __`objmask`__: pointer to an Object mask object"]
        #[doc =
          " - __`mask`__: pointer to created mask (returned by `lv_objmask_add_mask`)"]
        #[doc = " If `NULL` passed all masks will be deleted."]
        pub fn remove_mask(objmask: *mut lv_obj_t,
                           mask: *mut lv_objmask_mask_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Remove a mask"]
                #[doc = " - __`objmask`__: pointer to an Object mask object"]
                #[doc =
                  " - __`mask`__: pointer to created mask (returned by `lv_objmask_add_mask`)"]
                #[doc = " If `NULL` passed all masks will be deleted."]
                pub fn lv_objmask_remove_mask(objmask: *mut lv_obj_t,
                                              mask: *mut lv_objmask_mask_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_objmask_remove_mask(objmask as *mut lv_obj_t,
                                       mask as *mut lv_objmask_mask_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Template Widget API `lv_objx_templ`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod objx_templ {
        use super::*;
    }
    /// Contains Rust bindings for LVGL Page Widget API `lv_page`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod page {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_PAGE_DEF_ANIM_TIME: u32 = 400;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_scrollbar_mode_t = u8;
        pub const LV_PAGE_EDGE_LEFT: _bindgen_ty_37 = 1;
        pub const LV_PAGE_EDGE_TOP: _bindgen_ty_37 = 2;
        pub const LV_PAGE_EDGE_RIGHT: _bindgen_ty_37 = 4;
        pub const LV_PAGE_EDGE_BOTTOM: _bindgen_ty_37 = 8;
        #[doc = " Edges: describes the four edges of the page"]
        pub type _bindgen_ty_37 = u32;
        pub type lv_page_edge_t = u8;
        #[repr(C)]
        pub struct lv_page_ext_t {
            pub bg: lv_cont_ext_t,
            pub scrl: *mut lv_obj_t,
            pub scrlbar: lv_page_ext_t__bindgen_ty_1,
            pub edge_flash: lv_page_ext_t__bindgen_ty_2,
            pub anim_time: u16,
            pub scroll_prop_obj: *mut lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub hor_area: lv_area_t,
            pub ver_area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn hor_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hor_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ver_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ver_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mode(&self) -> lv_scrollbar_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(hor_draw: u8, ver_draw: u8,
                                  mode: lv_scrollbar_mode_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let hor_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hor_draw)
                                                    };
                                                hor_draw as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let ver_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ver_draw)
                                                    };
                                                ver_draw as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_2 {
            pub state: lv_anim_value_t,
            pub style: lv_style_list_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_2 {
            #[inline]
            pub fn enabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_enabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bottom_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_bottom_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn right_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn left_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_left_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(enabled: u8, top_ip: u8, bottom_ip: u8,
                                  right_ip: u8, left_ip: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let enabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(enabled)
                                                    };
                                                enabled as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let top_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top_ip)
                                                    };
                                                top_ip as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let bottom_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(bottom_ip)
                                                    };
                                                bottom_ip as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let right_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_ip)
                                                    };
                                                right_ip as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let left_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(left_ip)
                                                    };
                                                left_ip as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_page_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t {
            #[inline]
            pub fn scroll_prop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_scroll_prop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(scroll_prop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let scroll_prop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(scroll_prop)
                                                    };
                                                scroll_prop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_PAGE_PART_BG: _bindgen_ty_38 = 0;
        pub const LV_PAGE_PART_SCROLLBAR: _bindgen_ty_38 = 1;
        pub const LV_PAGE_PART_EDGE_FLASH: _bindgen_ty_38 = 2;
        pub const _LV_PAGE_PART_VIRTUAL_LAST: _bindgen_ty_38 = 3;
        pub const LV_PAGE_PART_SCROLLABLE: _bindgen_ty_38 = 64;
        pub const _LV_PAGE_PART_REAL_LAST: _bindgen_ty_38 = 65;
        pub type _bindgen_ty_38 = u32;
        #[doc = " Create a page objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new page"]
        #[doc =
          " - __`copy`__: pointer to a page object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created page"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a page objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new page"]
                #[doc =
                  " - __`copy`__: pointer to a page object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created page"]
                pub fn lv_page_create(par: *mut lv_obj_t,
                                      copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_create(par as *mut lv_obj_t,
                                   copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Delete all children of the scrl object, without deleting scrl child."]
        #[doc = " - __`page`__: pointer to an object"]
        pub fn clean(page: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete all children of the scrl object, without deleting scrl child."]
                #[doc = " - __`page`__: pointer to an object"]
                pub fn lv_page_clean(page: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_clean(page as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the scrollable object of a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " Return: pointer to a container which is the scrollable part of the page"]
        pub fn get_scrollable(page: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scrollable object of a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " Return: pointer to a container which is the scrollable part of the page"]
                pub fn lv_page_get_scrollable(page: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrollable(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation time"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: the animation time in milliseconds"]
        pub fn get_anim_time(page: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation time"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: the animation time in milliseconds"]
                pub fn lv_page_get_anim_time(page: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_anim_time(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the scroll bar mode on a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " - __`sb_mode`__: the new mode from 'lv_page_sb.mode_t' enum"]
        pub fn set_scrollbar_mode(page: *mut lv_obj_t,
                                  sb_mode: lv_scrollbar_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scroll bar mode on a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " - __`sb_mode`__: the new mode from 'lv_page_sb.mode_t' enum"]
                pub fn lv_page_set_scrollbar_mode(page: *mut lv_obj_t,
                                                  sb_mode:
                                                      lv_scrollbar_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrollbar_mode(page as *mut lv_obj_t,
                                           sb_mode as lv_scrollbar_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the animation time for the page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " - __`anim_time`__: animation time in milliseconds"]
        pub fn set_anim_time(page: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation time for the page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " - __`anim_time`__: animation time in milliseconds"]
                pub fn lv_page_set_anim_time(page: *mut lv_obj_t,
                                             anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_anim_time(page as *mut lv_obj_t,
                                      anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the scroll propagation feature. If enabled then the page will move its parent if there is"]
        #[doc = " no more space to scroll."]
        #[doc =
          " The page needs to have a page-like parent (e.g. `lv_page`, `lv_tabview` tab, `lv_win` content area etc)"]
        #[doc =
          " If enabled drag direction will be changed `LV_DRAG_DIR_ONE` automatically to allow scrolling only in one direction at one time."]
        #[doc = " - __`page`__: pointer to a Page"]
        #[doc =
          " - __`en`__: true or false to enable/disable scroll propagation"]
        pub fn set_scroll_propagation(page: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the scroll propagation feature. If enabled then the page will move its parent if there is"]
                #[doc = " no more space to scroll."]
                #[doc =
                  " The page needs to have a page-like parent (e.g. `lv_page`, `lv_tabview` tab, `lv_win` content area etc)"]
                #[doc =
                  " If enabled drag direction will be changed `LV_DRAG_DIR_ONE` automatically to allow scrolling only in one direction at one time."]
                #[doc = " - __`page`__: pointer to a Page"]
                #[doc =
                  " - __`en`__: true or false to enable/disable scroll propagation"]
                pub fn lv_page_set_scroll_propagation(page: *mut lv_obj_t,
                                                      en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scroll_propagation(page as *mut lv_obj_t,
                                               en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
        #[doc = " - __`page`__: pointer to a Page"]
        #[doc = " - __`en`__: true or false to enable/disable end flash"]
        pub fn set_edge_flash(page: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
                #[doc = " - __`page`__: pointer to a Page"]
                #[doc =
                  " - __`en`__: true or false to enable/disable end flash"]
                pub fn lv_page_set_edge_flash(page: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_edge_flash(page as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy in all 4 directions separately."]
        #[doc = " It tell how to change the page size automatically."]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " - __`left`__: left fit policy from `lv_fit_t`"]
        #[doc = " - __`right`__: right fit policy from `lv_fit_t`"]
        #[doc = " - __`top`__: bottom fit policy from `lv_fit_t`"]
        #[doc = " - __`bottom`__: bottom fit policy from `lv_fit_t`"]
        pub fn set_scrollable_fit4(page: *mut lv_obj_t, left: lv_fit_t,
                                   right: lv_fit_t, top: lv_fit_t,
                                   bottom: lv_fit_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the fit policy in all 4 directions separately."]
                #[doc = " It tell how to change the page size automatically."]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " - __`left`__: left fit policy from `lv_fit_t`"]
                #[doc = " - __`right`__: right fit policy from `lv_fit_t`"]
                #[doc = " - __`top`__: bottom fit policy from `lv_fit_t`"]
                #[doc = " - __`bottom`__: bottom fit policy from `lv_fit_t`"]
                pub fn lv_page_set_scrollable_fit4(page: *mut lv_obj_t,
                                                   left: lv_fit_t,
                                                   right: lv_fit_t,
                                                   top: lv_fit_t,
                                                   bottom: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrollable_fit4(page as *mut lv_obj_t,
                                            left as lv_fit_t,
                                            right as lv_fit_t,
                                            top as lv_fit_t,
                                            bottom as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy horizontally and vertically separately."]
        #[doc = " It tell how to change the page size automatically."]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " - __`hot`__: horizontal fit policy from `lv_fit_t`"]
        #[doc = " - __`ver`__: vertical fit policy from `lv_fit_t`"]
        pub fn set_scrollable_fit2(page: *mut lv_obj_t, hor: lv_fit_t,
                                   ver: lv_fit_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the fit policy horizontally and vertically separately."]
                #[doc = " It tell how to change the page size automatically."]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " - __`hot`__: horizontal fit policy from `lv_fit_t`"]
                #[doc = " - __`ver`__: vertical fit policy from `lv_fit_t`"]
                pub fn lv_page_set_scrollable_fit2(page: *mut lv_obj_t,
                                                   hor: lv_fit_t,
                                                   ver: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrollable_fit2(page as *mut lv_obj_t,
                                            hor as lv_fit_t, ver as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the fit policy in all 4 direction at once."]
        #[doc = " It tell how to change the page size automatically."]
        #[doc = " - __`page`__: pointer to a button object"]
        #[doc = " - __`fit`__: fit policy from `lv_fit_t`"]
        pub fn set_scrollable_fit(page: *mut lv_obj_t, fit: lv_fit_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the fit policy in all 4 direction at once."]
                #[doc = " It tell how to change the page size automatically."]
                #[doc = " - __`page`__: pointer to a button object"]
                #[doc = " - __`fit`__: fit policy from `lv_fit_t`"]
                pub fn lv_page_set_scrollable_fit(page: *mut lv_obj_t,
                                                  fit: lv_fit_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrollable_fit(page as *mut lv_obj_t,
                                           fit as lv_fit_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set width of the scrollable part of a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " - __`w`__: the new width of the scrollable (it ha no effect is horizontal fit is enabled)"]
        pub fn set_scrl_width(page: *mut lv_obj_t, w: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set width of the scrollable part of a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " - __`w`__: the new width of the scrollable (it ha no effect is horizontal fit is enabled)"]
                pub fn lv_page_set_scrl_width(page: *mut lv_obj_t,
                                              w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrl_width(page as *mut lv_obj_t,
                                       w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set height of the scrollable part of a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " - __`h`__: the new height of the scrollable (it ha no effect is vertical fit is enabled)"]
        pub fn set_scrl_height(page: *mut lv_obj_t, h: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set height of the scrollable part of a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " - __`h`__: the new height of the scrollable (it ha no effect is vertical fit is enabled)"]
                pub fn lv_page_set_scrl_height(page: *mut lv_obj_t,
                                               h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrl_height(page as *mut lv_obj_t,
                                        h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the layout of the scrollable part of the page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " - __`layout`__: a layout from 'lv_cont_layout_t'"]
        pub fn set_scrl_layout(page: *mut lv_obj_t, layout: lv_layout_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the layout of the scrollable part of the page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " - __`layout`__: a layout from 'lv_cont_layout_t'"]
                pub fn lv_page_set_scrl_layout(page: *mut lv_obj_t,
                                               layout: lv_layout_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_set_scrl_layout(page as *mut lv_obj_t,
                                        layout as lv_layout_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the scroll bar mode on a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: the mode from 'lv_page_sb.mode_t' enum"]
        pub fn get_scrollbar_mode(page: *const lv_obj_t)
         -> MynewtResult<lv_scrollbar_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scroll bar mode on a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: the mode from 'lv_page_sb.mode_t' enum"]
                pub fn lv_page_get_scrollbar_mode(page: *const lv_obj_t)
                -> lv_scrollbar_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrollbar_mode(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll propagation property"]
        #[doc = " - __`page`__: pointer to a Page"]
        #[doc = " Return: true or false"]
        pub fn get_scroll_propagation(page: *mut lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll propagation property"]
                #[doc = " - __`page`__: pointer to a Page"]
                #[doc = " Return: true or false"]
                pub fn lv_page_get_scroll_propagation(page: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scroll_propagation(page as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the edge flash effect property."]
        #[doc = " - __`page`__: pointer to a Page"]
        #[doc = " return true or false"]
        pub fn get_edge_flash(page: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the edge flash effect property."]
                #[doc = " - __`page`__: pointer to a Page"]
                #[doc = " return true or false"]
                pub fn lv_page_get_edge_flash(page: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_edge_flash(page as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get that width which can be set to the children to still not cause overflow (show scrollbars)"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: the width which still fits into the page"]
        pub fn get_width_fit(page: *mut lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get that width which can be set to the children to still not cause overflow (show scrollbars)"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: the width which still fits into the page"]
                pub fn lv_page_get_width_fit(page: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_width_fit(page as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get that height which can be set to the children to still not cause overflow (show scrollbars)"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: the height which still fits into the page"]
        pub fn get_height_fit(page: *mut lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get that height which can be set to the children to still not cause overflow (show scrollbars)"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: the height which still fits into the page"]
                pub fn lv_page_get_height_fit(page: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_height_fit(page as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Divide the width of the object and get the width of a given number of columns."]
        #[doc =
          " Take into account the paddings of the background and scrollable too."]
        #[doc = " - __`page`__: pointer to an object"]
        #[doc = " - __`div`__: indicates how many columns are assumed."]
        #[doc = " If 1 the width will be set the the parent's width"]
        #[doc = " If 2 only half parent width - inner padding of the parent"]
        #[doc =
          " If 3 only third parent width - 2 * inner padding of the parent"]
        #[doc = " - __`span`__: how many columns are combined"]
        #[doc = " Return: the width according to the given parameters"]
        pub fn get_width_grid(page: *mut lv_obj_t, div: u8, span: u8)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Divide the width of the object and get the width of a given number of columns."]
                #[doc =
                  " Take into account the paddings of the background and scrollable too."]
                #[doc = " - __`page`__: pointer to an object"]
                #[doc =
                  " - __`div`__: indicates how many columns are assumed."]
                #[doc = " If 1 the width will be set the the parent's width"]
                #[doc =
                  " If 2 only half parent width - inner padding of the parent"]
                #[doc =
                  " If 3 only third parent width - 2 * inner padding of the parent"]
                #[doc = " - __`span`__: how many columns are combined"]
                #[doc =
                  " Return: the width according to the given parameters"]
                pub fn lv_page_get_width_grid(page: *mut lv_obj_t, div: u8,
                                              span: u8)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_width_grid(page as *mut lv_obj_t, div as u8,
                                           span as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Divide the height of the object and get the width of a given number of columns."]
        #[doc =
          " Take into account the paddings of the background and scrollable too."]
        #[doc = " - __`page`__: pointer to an object"]
        #[doc = " - __`div`__: indicates how many rows are assumed."]
        #[doc = " If 1 the height will be set the the parent's height"]
        #[doc = " If 2 only half parent height - inner padding of the parent"]
        #[doc =
          " If 3 only third parent height - 2 * inner padding of the parent"]
        #[doc = " - __`span`__: how many rows are combined"]
        #[doc = " Return: the height according to the given parameters"]
        pub fn get_height_grid(page: *mut lv_obj_t, div: u8, span: u8)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Divide the height of the object and get the width of a given number of columns."]
                #[doc =
                  " Take into account the paddings of the background and scrollable too."]
                #[doc = " - __`page`__: pointer to an object"]
                #[doc = " - __`div`__: indicates how many rows are assumed."]
                #[doc =
                  " If 1 the height will be set the the parent's height"]
                #[doc =
                  " If 2 only half parent height - inner padding of the parent"]
                #[doc =
                  " If 3 only third parent height - 2 * inner padding of the parent"]
                #[doc = " - __`span`__: how many rows are combined"]
                #[doc =
                  " Return: the height according to the given parameters"]
                pub fn lv_page_get_height_grid(page: *mut lv_obj_t, div: u8,
                                               span: u8)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_height_grid(page as *mut lv_obj_t, div as u8,
                                            span as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get width of the scrollable part of a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: the width of the scrollable"]
        pub fn get_scrl_width(page: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get width of the scrollable part of a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: the width of the scrollable"]
                pub fn lv_page_get_scrl_width(page: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_width(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get height of the scrollable part of a page"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: the height of the scrollable"]
        pub fn get_scrl_height(page: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get height of the scrollable part of a page"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: the height of the scrollable"]
                pub fn lv_page_get_scrl_height(page: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_height(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the layout of the scrollable part of a page"]
        #[doc = " - __`page`__: pointer to page object"]
        #[doc = " Return: the layout from 'lv_cont_layout_t'"]
        pub fn get_scrl_layout(page: *const lv_obj_t)
         -> MynewtResult<lv_layout_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the layout of the scrollable part of a page"]
                #[doc = " - __`page`__: pointer to page object"]
                #[doc = " Return: the layout from 'lv_cont_layout_t'"]
                pub fn lv_page_get_scrl_layout(page: *const lv_obj_t)
                -> lv_layout_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_layout(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the left fit mode"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_scrl_fit_left(page: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the left fit mode"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_page_get_scrl_fit_left(page: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_fit_left(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the right fit mode"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_scrl_fit_right(page: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the right fit mode"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_page_get_scrl_fit_right(page: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_fit_right(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the top fit mode"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_scrl_fit_top(page: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the top fit mode"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_page_get_scrl_fit_top(page: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_fit_top(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the bottom fit mode"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc = " Return: an element of `lv_fit_t`"]
        pub fn get_scrl_fit_bottom(page: *const lv_obj_t)
         -> MynewtResult<lv_fit_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the bottom fit mode"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc = " Return: an element of `lv_fit_t`"]
                pub fn lv_page_get_scrl_fit_bottom(page: *const lv_obj_t)
                -> lv_fit_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_get_scrl_fit_bottom(page as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Find whether the page has been scrolled to a certain edge."]
        #[doc = " - __`page`__: Page object"]
        #[doc = " - __`edge`__: Edge to check"]
        #[doc = " Return: true if the page is on the specified edge"]
        pub fn on_edge(page: *mut lv_obj_t, edge: lv_page_edge_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Find whether the page has been scrolled to a certain edge."]
                #[doc = " - __`page`__: Page object"]
                #[doc = " - __`edge`__: Edge to check"]
                #[doc = " Return: true if the page is on the specified edge"]
                pub fn lv_page_on_edge(page: *mut lv_obj_t,
                                       edge: lv_page_edge_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_page_on_edge(page as *mut lv_obj_t,
                                    edge as lv_page_edge_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Glue the object to the page. After it the page can be moved (dragged) with this object too."]
        #[doc = " - __`obj`__: pointer to an object on a page"]
        #[doc = " - __`glue`__: true: enable glue, false: disable glue"]
        pub fn glue_obj(obj: *mut lv_obj_t, glue: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Glue the object to the page. After it the page can be moved (dragged) with this object too."]
                #[doc = " - __`obj`__: pointer to an object on a page"]
                #[doc =
                  " - __`glue`__: true: enable glue, false: disable glue"]
                pub fn lv_page_glue_obj(obj: *mut lv_obj_t, glue: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_glue_obj(obj as *mut lv_obj_t, glue as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Focus on an object. It ensures that the object will be visible on the page."]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " - __`obj`__: pointer to an object to focus (must be on the page)"]
        #[doc =
          " - __`anim_en`__: LV_ANIM_ON to focus with animation; LV_ANIM_OFF to focus without animation"]
        pub fn focus(page: *mut lv_obj_t, obj: *const lv_obj_t,
                     anim_en: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Focus on an object. It ensures that the object will be visible on the page."]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " - __`obj`__: pointer to an object to focus (must be on the page)"]
                #[doc =
                  " - __`anim_en`__: LV_ANIM_ON to focus with animation; LV_ANIM_OFF to focus without animation"]
                pub fn lv_page_focus(page: *mut lv_obj_t,
                                     obj: *const lv_obj_t,
                                     anim_en: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_focus(page as *mut lv_obj_t, obj as *const lv_obj_t,
                              anim_en as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Scroll the page horizontally"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " - __`dist`__: the distance to scroll (< 0: scroll left; > 0 scroll right)"]
        pub fn scroll_hor(page: *mut lv_obj_t, dist: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Scroll the page horizontally"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " - __`dist`__: the distance to scroll (< 0: scroll left; > 0 scroll right)"]
                pub fn lv_page_scroll_hor(page: *mut lv_obj_t,
                                          dist: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_scroll_hor(page as *mut lv_obj_t, dist as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Scroll the page vertically"]
        #[doc = " - __`page`__: pointer to a page object"]
        #[doc =
          " - __`dist`__: the distance to scroll (< 0: scroll down; > 0 scroll up)"]
        pub fn scroll_ver(page: *mut lv_obj_t, dist: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Scroll the page vertically"]
                #[doc = " - __`page`__: pointer to a page object"]
                #[doc =
                  " - __`dist`__: the distance to scroll (< 0: scroll down; > 0 scroll up)"]
                pub fn lv_page_scroll_ver(page: *mut lv_obj_t,
                                          dist: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_scroll_ver(page as *mut lv_obj_t, dist as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Not intended to use directly by the user but by other object types internally."]
        #[doc = " Start an edge flash animation."]
        #[doc = " @param page"]
        #[doc =
          " - __`edge`__: the edge to flash. Can be `LV_PAGE_EDGE_LEFT/RIGHT/TOP/BOTTOM`"]
        pub fn start_edge_flash(page: *mut lv_obj_t, edge: lv_page_edge_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Not intended to use directly by the user but by other object types internally."]
                #[doc = " Start an edge flash animation."]
                #[doc = " @param page"]
                #[doc =
                  " - __`edge`__: the edge to flash. Can be `LV_PAGE_EDGE_LEFT/RIGHT/TOP/BOTTOM`"]
                pub fn lv_page_start_edge_flash(page: *mut lv_obj_t,
                                                edge: lv_page_edge_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_page_start_edge_flash(page as *mut lv_obj_t,
                                         edge as lv_page_edge_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Roller Widget API `lv_roller`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod roller {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_ROLLER_DEF_ANIM_TIME: u32 = 200;
        pub const LV_ROLLER_INF_PAGES: u32 = 7;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_scrollbar_mode_t = u8;
        #[repr(C)]
        pub struct lv_page_ext_t {
            pub bg: lv_cont_ext_t,
            pub scrl: *mut lv_obj_t,
            pub scrlbar: lv_page_ext_t__bindgen_ty_1,
            pub edge_flash: lv_page_ext_t__bindgen_ty_2,
            pub anim_time: u16,
            pub scroll_prop_obj: *mut lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub hor_area: lv_area_t,
            pub ver_area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn hor_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hor_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ver_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ver_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mode(&self) -> lv_scrollbar_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(hor_draw: u8, ver_draw: u8,
                                  mode: lv_scrollbar_mode_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let hor_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hor_draw)
                                                    };
                                                hor_draw as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let ver_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ver_draw)
                                                    };
                                                ver_draw as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_2 {
            pub state: lv_anim_value_t,
            pub style: lv_style_list_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_2 {
            #[inline]
            pub fn enabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_enabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bottom_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_bottom_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn right_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn left_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_left_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(enabled: u8, top_ip: u8, bottom_ip: u8,
                                  right_ip: u8, left_ip: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let enabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(enabled)
                                                    };
                                                enabled as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let top_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top_ip)
                                                    };
                                                top_ip as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let bottom_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(bottom_ip)
                                                    };
                                                bottom_ip as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let right_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_ip)
                                                    };
                                                right_ip as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let left_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(left_ip)
                                                    };
                                                left_ip as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_page_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t {
            #[inline]
            pub fn scroll_prop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_scroll_prop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(scroll_prop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let scroll_prop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(scroll_prop)
                                                    };
                                                scroll_prop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_label_align_t = u8;
        #[doc = "< Normal mode (roller ends at the end of the options)."]
        pub const LV_ROLLER_MODE_NORMAL: _bindgen_ty_42 = 0;
        #[doc = "< Infinite mode (roller can be scrolled forever)."]
        pub const LV_ROLLER_MODE_INIFINITE: _bindgen_ty_42 = 1;
        #[doc = " Roller mode."]
        pub type _bindgen_ty_42 = u32;
        pub type lv_roller_mode_t = u8;
        #[repr(C)]
        pub struct lv_roller_ext_t {
            pub page: lv_page_ext_t,
            pub style_sel: lv_style_list_t,
            pub option_cnt: u16,
            pub sel_opt_id: u16,
            pub sel_opt_id_ori: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u8,
        }
        impl Default for lv_roller_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_roller_ext_t {
            #[inline]
            pub fn mode(&self) -> lv_roller_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_roller_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn auto_fit(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_fit(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(mode: lv_roller_mode_t, auto_fit: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let auto_fit: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_fit)
                                                    };
                                                auto_fit as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_ROLLER_PART_BG: _bindgen_ty_43 = 0;
        pub const LV_ROLLER_PART_SELECTED: _bindgen_ty_43 = 3;
        pub const _LV_ROLLER_PART_VIRTUAL_LAST: _bindgen_ty_43 = 4;
        pub type _bindgen_ty_43 = u32;
        pub type lv_roller_part_t = u8;
        #[doc = " Create a roller object"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new roller"]
        #[doc =
          " - __`copy`__: pointer to a roller object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created roller"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a roller object"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new roller"]
                #[doc =
                  " - __`copy`__: pointer to a roller object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created roller"]
                pub fn lv_roller_create(par: *mut lv_obj_t,
                                        copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_roller_create(par as *mut lv_obj_t,
                                     copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the options on a roller"]
        #[doc = " - __`roller`__: pointer to roller object"]
        #[doc =
          " - __`options`__: a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
        #[doc =
          " - __`mode`__: `LV_ROLLER_MODE_NORMAL` or `LV_ROLLER_MODE_INFINITE`"]
        pub fn set_options(roller: *mut lv_obj_t, options: &Strn,
                           mode: lv_roller_mode_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the options on a roller"]
                #[doc = " - __`roller`__: pointer to roller object"]
                #[doc =
                  " - __`options`__: a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
                #[doc =
                  " - __`mode`__: `LV_ROLLER_MODE_NORMAL` or `LV_ROLLER_MODE_INFINITE`"]
                pub fn lv_roller_set_options(roller: *mut lv_obj_t,
                                             options: *const ::cty::c_char,
                                             mode: lv_roller_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            options.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_set_options(roller as *mut lv_obj_t,
                                      options.as_ptr() as
                                          *const ::cty::c_char,
                                      mode as lv_roller_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the align of the roller's options (left, right or center[default])"]
        #[doc = " - __`roller`__: - pointer to a roller object"]
        #[doc =
          " - __`align`__: - one of lv_label_align_t values (left, right, center)"]
        pub fn set_align(roller: *mut lv_obj_t, align: lv_label_align_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the align of the roller's options (left, right or center[default])"]
                #[doc = " - __`roller`__: - pointer to a roller object"]
                #[doc =
                  " - __`align`__: - one of lv_label_align_t values (left, right, center)"]
                pub fn lv_roller_set_align(roller: *mut lv_obj_t,
                                           align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_set_align(roller as *mut lv_obj_t,
                                    align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the selected option"]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc =
          " - __`sel_opt`__: id of the selected option (0 ... number of option - 1);"]
        #[doc =
          " - __`anim`__: LV_ANOM_ON: set with animation; LV_ANIM_OFF set immediately"]
        pub fn set_selected(roller: *mut lv_obj_t, sel_opt: u16,
                            anim: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the selected option"]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc =
                  " - __`sel_opt`__: id of the selected option (0 ... number of option - 1);"]
                #[doc =
                  " - __`anim`__: LV_ANOM_ON: set with animation; LV_ANIM_OFF set immediately"]
                pub fn lv_roller_set_selected(roller: *mut lv_obj_t,
                                              sel_opt: u16,
                                              anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_set_selected(roller as *mut lv_obj_t,
                                       sel_opt as u16,
                                       anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the height to show the given number of rows (options)"]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc = " - __`row_cnt`__: number of desired visible rows"]
        pub fn set_visible_row_count(roller: *mut lv_obj_t, row_cnt: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the height to show the given number of rows (options)"]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc = " - __`row_cnt`__: number of desired visible rows"]
                pub fn lv_roller_set_visible_row_count(roller: *mut lv_obj_t,
                                                       row_cnt: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_set_visible_row_count(roller as *mut lv_obj_t,
                                                row_cnt as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Allow automatically setting the width of roller according to it's content."]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc = " - __`auto_fit`__: true: enable auto fit"]
        pub fn set_auto_fit(roller: *mut lv_obj_t, auto_fit: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Allow automatically setting the width of roller according to it's content."]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc = " - __`auto_fit`__: true: enable auto fit"]
                pub fn lv_roller_set_auto_fit(roller: *mut lv_obj_t,
                                              auto_fit: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_set_auto_fit(roller as *mut lv_obj_t,
                                       auto_fit as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the open/close animation time."]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc = " - __`anim_time:`__: open/close animation time [ms]"]
        pub fn set_anim_time(roller: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the open/close animation time."]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc = " - __`anim_time:`__: open/close animation time [ms]"]
                pub fn lv_roller_set_anim_time(roller: *mut lv_obj_t,
                                               anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_set_anim_time(roller as *mut lv_obj_t,
                                        anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the id of the selected option"]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc =
          " Return: id of the selected option (0 ... number of option - 1);"]
        pub fn get_selected(roller: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the id of the selected option"]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc =
                  " Return: id of the selected option (0 ... number of option - 1);"]
                pub fn lv_roller_get_selected(roller: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_roller_get_selected(roller as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the total number of options"]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc = " Return: the total number of options in the list"]
        pub fn get_option_cnt(roller: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the total number of options"]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc = " Return: the total number of options in the list"]
                pub fn lv_roller_get_option_cnt(roller: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_roller_get_option_cnt(roller as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current selected option as a string"]
        #[doc = " - __`roller`__: pointer to roller object"]
        #[doc = " - __`buf`__: pointer to an array to store the string"]
        #[doc = " - __`buf_size`__: size of `buf` in bytes. 0: to ignore it."]
        pub fn get_selected_str(roller: *const lv_obj_t,
                                buf: *mut ::cty::c_char, buf_size: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current selected option as a string"]
                #[doc = " - __`roller`__: pointer to roller object"]
                #[doc =
                  " - __`buf`__: pointer to an array to store the string"]
                #[doc =
                  " - __`buf_size`__: size of `buf` in bytes. 0: to ignore it."]
                pub fn lv_roller_get_selected_str(roller: *const lv_obj_t,
                                                  buf: *mut ::cty::c_char,
                                                  buf_size: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_roller_get_selected_str(roller as *const lv_obj_t,
                                           buf as *mut ::cty::c_char,
                                           buf_size as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get the align attribute. Default alignment after _create is LV_LABEL_ALIGN_CENTER"]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc =
          " Return: LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
        pub fn get_align(roller: *const lv_obj_t)
         -> MynewtResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the align attribute. Default alignment after _create is LV_LABEL_ALIGN_CENTER"]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc =
                  " Return: LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
                pub fn lv_roller_get_align(roller: *const lv_obj_t)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_roller_get_align(roller as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether the auto fit option is enabled or not."]
        #[doc = " - __`roller`__: pointer to a roller object"]
        #[doc = " Return: true: auto fit is enabled"]
        pub fn get_auto_fit(roller: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether the auto fit option is enabled or not."]
                #[doc = " - __`roller`__: pointer to a roller object"]
                #[doc = " Return: true: auto fit is enabled"]
                pub fn lv_roller_get_auto_fit(roller: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_roller_get_auto_fit(roller as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the open/close animation time."]
        #[doc = " - __`roller`__: pointer to a roller"]
        #[doc = " Return: open/close animation time [ms]"]
        pub fn get_anim_time(roller: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the open/close animation time."]
                #[doc = " - __`roller`__: pointer to a roller"]
                #[doc = " Return: open/close animation time [ms]"]
                pub fn lv_roller_get_anim_time(roller: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_roller_get_anim_time(roller as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Slider Widget API `lv_slider`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod slider {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[repr(C)]
        pub struct lv_bar_anim_t {
            pub bar: *mut lv_obj_t,
            pub anim_start: lv_anim_value_t,
            pub anim_end: lv_anim_value_t,
            pub anim_state: lv_anim_value_t,
        }
        impl Default for lv_bar_anim_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Data of bar"]
        #[repr(C)]
        pub struct lv_bar_ext_t {
            pub cur_value: i16,
            pub min_value: i16,
            pub max_value: i16,
            pub start_value: i16,
            pub indic_area: lv_area_t,
            pub anim_time: lv_anim_value_t,
            pub cur_value_anim: lv_bar_anim_t,
            pub start_value_anim: lv_bar_anim_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub style_indic: lv_style_list_t,
        }
        impl Default for lv_bar_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_bar_ext_t {
            #[inline]
            pub fn type_(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(type_: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let type_: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_SLIDER_TYPE_NORMAL: _bindgen_ty_43 = 0;
        pub const LV_SLIDER_TYPE_SYMMETRICAL: _bindgen_ty_43 = 1;
        pub const LV_SLIDER_TYPE_RANGE: _bindgen_ty_43 = 2;
        #[doc = "      TYPEDEFS"]
        pub type _bindgen_ty_43 = u32;
        pub type lv_slider_type_t = u8;
        #[repr(C)]
        pub struct lv_slider_ext_t {
            pub bar: lv_bar_ext_t,
            pub style_knob: lv_style_list_t,
            pub left_knob_area: lv_area_t,
            pub right_knob_area: lv_area_t,
            pub value_to_set: *mut i16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_slider_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_slider_ext_t {
            #[inline]
            pub fn dragging(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_dragging(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(dragging: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let dragging: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(dragging)
                                                    };
                                                dragging as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_SLIDER_PART_BG: _bindgen_ty_44 = 0;
        #[doc = " Slider background style."]
        pub const LV_SLIDER_PART_INDIC: _bindgen_ty_44 = 1;
        #[doc = " Slider indicator (filled area) style."]
        pub const LV_SLIDER_PART_KNOB: _bindgen_ty_44 = 2;
        #[doc = " Built-in styles of slider"]
        pub type _bindgen_ty_44 = u32;
        #[doc = " Create a slider objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new slider"]
        #[doc =
          " - __`copy`__: pointer to a slider object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created slider"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a slider objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new slider"]
                #[doc =
                  " - __`copy`__: pointer to a slider object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created slider"]
                pub fn lv_slider_create(par: *mut lv_obj_t,
                                        copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_create(par as *mut lv_obj_t,
                                     copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set a new value on the slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " - __`value`__: new value"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn set_value(slider: *mut lv_obj_t, value: i16,
                         anim: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new value on the slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " - __`value`__: new value"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_slider_set_value(slider: *mut lv_obj_t, value: i16,
                                           anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_slider_set_value(slider as *mut lv_obj_t, value as i16,
                                    anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new value for the left knob of a slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " - __`left_value`__: new value"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn set_left_value(slider: *mut lv_obj_t, left_value: i16,
                              anim: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new value for the left knob of a slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " - __`left_value`__: new value"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_slider_set_left_value(slider: *mut lv_obj_t,
                                                left_value: i16,
                                                anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_slider_set_left_value(slider as *mut lv_obj_t,
                                         left_value as i16,
                                         anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set minimum and the maximum values of a bar"]
        #[doc = " - __`slider`__: pointer to the slider object"]
        #[doc = " - __`min`__: minimum value"]
        #[doc = " - __`max`__: maximum value"]
        pub fn set_range(slider: *mut lv_obj_t, min: i16, max: i16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set minimum and the maximum values of a bar"]
                #[doc = " - __`slider`__: pointer to the slider object"]
                #[doc = " - __`min`__: minimum value"]
                #[doc = " - __`max`__: maximum value"]
                pub fn lv_slider_set_range(slider: *mut lv_obj_t, min: i16,
                                           max: i16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_slider_set_range(slider as *mut lv_obj_t, min as i16,
                                    max as i16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the animation time of the slider"]
        #[doc = " - __`slider`__: pointer to a bar object"]
        #[doc = " - __`anim_time`__: the animation time in milliseconds."]
        pub fn set_anim_time(slider: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation time of the slider"]
                #[doc = " - __`slider`__: pointer to a bar object"]
                #[doc =
                  " - __`anim_time`__: the animation time in milliseconds."]
                pub fn lv_slider_set_anim_time(slider: *mut lv_obj_t,
                                               anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_slider_set_anim_time(slider as *mut lv_obj_t,
                                        anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Make the slider symmetric to zero. The indicator will grow from zero instead of the minimum"]
        #[doc = " position."]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc =
          " - __`en`__: true: enable disable symmetric behavior; false: disable"]
        pub fn set_type(slider: *mut lv_obj_t, type_: lv_slider_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Make the slider symmetric to zero. The indicator will grow from zero instead of the minimum"]
                #[doc = " position."]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc =
                  " - __`en`__: true: enable disable symmetric behavior; false: disable"]
                pub fn lv_slider_set_type(slider: *mut lv_obj_t,
                                          type_: lv_slider_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_slider_set_type(slider as *mut lv_obj_t,
                                   type_ as lv_slider_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the value of the main knob of a slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " Return: the value of the main knob of the slider"]
        pub fn get_value(slider: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the value of the main knob of a slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " Return: the value of the main knob of the slider"]
                pub fn lv_slider_get_value(slider: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_get_value(slider as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the value of the left knob of a slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " Return: the value of the left knob of the slider"]
        pub fn get_left_value(slider: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the value of the left knob of a slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " Return: the value of the left knob of the slider"]
                pub fn lv_slider_get_left_value(slider: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_get_left_value(slider as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the minimum value of a slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " Return: the minimum value of the slider"]
        pub fn get_min_value(slider: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the minimum value of a slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " Return: the minimum value of the slider"]
                pub fn lv_slider_get_min_value(slider: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_get_min_value(slider as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the maximum value of a slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " Return: the maximum value of the slider"]
        pub fn get_max_value(slider: *const lv_obj_t) -> MynewtResult<i16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the maximum value of a slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " Return: the maximum value of the slider"]
                pub fn lv_slider_get_max_value(slider: *const lv_obj_t)
                -> i16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_get_max_value(slider as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Give the slider is being dragged or not"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " Return: true: drag in progress false: not dragged"]
        pub fn is_dragged(slider: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Give the slider is being dragged or not"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " Return: true: drag in progress false: not dragged"]
                pub fn lv_slider_is_dragged(slider: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_is_dragged(slider as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation time of the slider"]
        #[doc = " - __`slider`__: pointer to a slider object"]
        #[doc = " Return: the animation time in milliseconds."]
        pub fn get_anim_time(slider: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation time of the slider"]
                #[doc = " - __`slider`__: pointer to a slider object"]
                #[doc = " Return: the animation time in milliseconds."]
                pub fn lv_slider_get_anim_time(slider: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_get_anim_time(slider as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether the slider is symmetric or not."]
        #[doc = " - __`slider`__: pointer to a bar object"]
        #[doc = " Return: true: symmetric is enabled; false: disable"]
        pub fn get_type(slider: *mut lv_obj_t)
         -> MynewtResult<lv_slider_type_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether the slider is symmetric or not."]
                #[doc = " - __`slider`__: pointer to a bar object"]
                #[doc = " Return: true: symmetric is enabled; false: disable"]
                pub fn lv_slider_get_type(slider: *mut lv_obj_t)
                -> lv_slider_type_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_slider_get_type(slider as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Spinbox Widget API `lv_spinbox`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod spinbox {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_SPINBOX_MAX_DIGIT_COUNT: u32 = 10;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_scrollbar_mode_t = u8;
        #[repr(C)]
        pub struct lv_page_ext_t {
            pub bg: lv_cont_ext_t,
            pub scrl: *mut lv_obj_t,
            pub scrlbar: lv_page_ext_t__bindgen_ty_1,
            pub edge_flash: lv_page_ext_t__bindgen_ty_2,
            pub anim_time: u16,
            pub scroll_prop_obj: *mut lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub hor_area: lv_area_t,
            pub ver_area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn hor_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hor_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ver_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ver_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mode(&self) -> lv_scrollbar_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(hor_draw: u8, ver_draw: u8,
                                  mode: lv_scrollbar_mode_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let hor_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hor_draw)
                                                    };
                                                hor_draw as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let ver_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ver_draw)
                                                    };
                                                ver_draw as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_2 {
            pub state: lv_anim_value_t,
            pub style: lv_style_list_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_2 {
            #[inline]
            pub fn enabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_enabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bottom_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_bottom_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn right_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn left_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_left_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(enabled: u8, top_ip: u8, bottom_ip: u8,
                                  right_ip: u8, left_ip: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let enabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(enabled)
                                                    };
                                                enabled as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let top_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top_ip)
                                                    };
                                                top_ip as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let bottom_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(bottom_ip)
                                                    };
                                                bottom_ip as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let right_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_ip)
                                                    };
                                                right_ip as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let left_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(left_ip)
                                                    };
                                                left_ip as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_page_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t {
            #[inline]
            pub fn scroll_prop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_scroll_prop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(scroll_prop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let scroll_prop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(scroll_prop)
                                                    };
                                                scroll_prop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_textarea_ext_t {
            pub page: lv_page_ext_t,
            pub label: *mut lv_obj_t,
            pub placeholder_txt: *mut ::cty::c_char,
            pub style_placeholder: lv_style_list_t,
            pub pwd_tmp: *mut ::cty::c_char,
            pub accapted_chars: *const ::cty::c_char,
            pub max_length: u32,
            pub pwd_show_time: u16,
            pub cursor: lv_textarea_ext_t__bindgen_ty_1,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_textarea_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub valid_x: lv_coord_t,
            pub pos: u32,
            pub blink_time: u16,
            pub area: lv_area_t,
            pub txt_byte_pos: u32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_textarea_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_textarea_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn state(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_state(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn click_pos(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click_pos(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(state: u8, hidden: u8, click_pos: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let state: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(state)
                                                    };
                                                state as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let click_pos: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click_pos)
                                                    };
                                                click_pos as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_textarea_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_textarea_ext_t {
            #[inline]
            pub fn pwd_mode(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_pwd_mode(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn one_line(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_one_line(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(pwd_mode: u8, one_line: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let pwd_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(pwd_mode)
                                                    };
                                                pwd_mode as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let one_line: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(one_line)
                                                    };
                                                one_line as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_spinbox_ext_t {
            pub ta: lv_textarea_ext_t,
            pub value: i32,
            pub range_max: i32,
            pub range_min: i32,
            pub step: i32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        impl Default for lv_spinbox_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_spinbox_ext_t {
            #[inline]
            pub fn rollover(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_rollover(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn digit_count(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_digit_count(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn dec_point_pos(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_dec_point_pos(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn digit_padding_left(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_digit_padding_left(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(rollover: u8, digit_count: u16,
                                  dec_point_pos: u16, digit_padding_left: u16)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let rollover: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(rollover)
                                                    };
                                                rollover as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 4u8,
                                            {
                                                let digit_count: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(digit_count)
                                                    };
                                                digit_count as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 4u8,
                                            {
                                                let dec_point_pos: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(dec_point_pos)
                                                    };
                                                dec_point_pos as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 4u8,
                                            {
                                                let digit_padding_left: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(digit_padding_left)
                                                    };
                                                digit_padding_left as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_SPINBOX_PART_BG: _bindgen_ty_43 = 0;
        pub const LV_SPINBOX_PART_CURSOR: _bindgen_ty_43 = 3;
        pub const _LV_SPINBOX_PART_VIRTUAL_LAST: _bindgen_ty_43 = 5;
        pub const _LV_SPINBOX_PART_REAL_LAST: _bindgen_ty_43 = 65;
        pub type _bindgen_ty_43 = u32;
        pub type lv_spinbox_part_t = u8;
        #[doc = " Create a spinbox objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new spinbox"]
        #[doc =
          " - __`copy`__: pointer to a spinbox object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created spinbox"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a spinbox objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new spinbox"]
                #[doc =
                  " - __`copy`__: pointer to a spinbox object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created spinbox"]
                pub fn lv_spinbox_create(par: *mut lv_obj_t,
                                         copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinbox_create(par as *mut lv_obj_t,
                                      copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set spinbox rollover function"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc = " - __`b`__: true or false to enable or disable (default)"]
        pub fn set_rollover(spinbox: *mut lv_obj_t, b: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set spinbox rollover function"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc =
                  " - __`b`__: true or false to enable or disable (default)"]
                pub fn lv_spinbox_set_rollover(spinbox: *mut lv_obj_t,
                                               b: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_set_rollover(spinbox as *mut lv_obj_t, b as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set spinbox value"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc = " - __`i`__: value to be set"]
        pub fn set_value(spinbox: *mut lv_obj_t, i: i32) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set spinbox value"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc = " - __`i`__: value to be set"]
                pub fn lv_spinbox_set_value(spinbox: *mut lv_obj_t, i: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_set_value(spinbox as *mut lv_obj_t, i as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set spinbox digit format (digit count and decimal format)"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc =
          " - __`digit_count`__: number of digit excluding the decimal separator and the sign"]
        #[doc =
          " - __`separator_position`__: number of digit before the decimal point. If 0, decimal point is not"]
        #[doc = " shown"]
        pub fn set_digit_format(spinbox: *mut lv_obj_t, digit_count: u8,
                                separator_position: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set spinbox digit format (digit count and decimal format)"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc =
                  " - __`digit_count`__: number of digit excluding the decimal separator and the sign"]
                #[doc =
                  " - __`separator_position`__: number of digit before the decimal point. If 0, decimal point is not"]
                #[doc = " shown"]
                pub fn lv_spinbox_set_digit_format(spinbox: *mut lv_obj_t,
                                                   digit_count: u8,
                                                   separator_position: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_set_digit_format(spinbox as *mut lv_obj_t,
                                            digit_count as u8,
                                            separator_position as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set spinbox step"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc = " - __`step`__: steps on increment/decrement"]
        pub fn set_step(spinbox: *mut lv_obj_t, step: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set spinbox step"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc = " - __`step`__: steps on increment/decrement"]
                pub fn lv_spinbox_set_step(spinbox: *mut lv_obj_t, step: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_set_step(spinbox as *mut lv_obj_t, step as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set spinbox value range"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc = " - __`range_min`__: maximum value, inclusive"]
        #[doc = " - __`range_max`__: minimum value, inclusive"]
        pub fn set_range(spinbox: *mut lv_obj_t, range_min: i32,
                         range_max: i32) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set spinbox value range"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc = " - __`range_min`__: maximum value, inclusive"]
                #[doc = " - __`range_max`__: minimum value, inclusive"]
                pub fn lv_spinbox_set_range(spinbox: *mut lv_obj_t,
                                            range_min: i32, range_max: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_set_range(spinbox as *mut lv_obj_t,
                                     range_min as i32, range_max as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set spinbox left padding in digits count (added between sign and first digit)"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc = " - __`cb`__: Callback function called on value change event"]
        pub fn set_padding_left(spinbox: *mut lv_obj_t, padding: u8)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set spinbox left padding in digits count (added between sign and first digit)"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc =
                  " - __`cb`__: Callback function called on value change event"]
                pub fn lv_spinbox_set_padding_left(spinbox: *mut lv_obj_t,
                                                   padding: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_set_padding_left(spinbox as *mut lv_obj_t,
                                            padding as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get spinbox rollover function status"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        pub fn get_rollover(spinbox: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get spinbox rollover function status"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                pub fn lv_spinbox_get_rollover(spinbox: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinbox_get_rollover(spinbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the spinbox numeral value (user has to convert to float according to its digit format)"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        #[doc = " Return: value integer value of the spinbox"]
        pub fn get_value(spinbox: *mut lv_obj_t) -> MynewtResult<i32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the spinbox numeral value (user has to convert to float according to its digit format)"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                #[doc = " Return: value integer value of the spinbox"]
                pub fn lv_spinbox_get_value(spinbox: *mut lv_obj_t)
                -> i32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinbox_get_value(spinbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Select next lower digit for edition by dividing the step by 10"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        pub fn step_next(spinbox: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Select next lower digit for edition by dividing the step by 10"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                pub fn lv_spinbox_step_next(spinbox: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_step_next(spinbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Select next higher digit for edition by multiplying the step by 10"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        pub fn step_prev(spinbox: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Select next higher digit for edition by multiplying the step by 10"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                pub fn lv_spinbox_step_prev(spinbox: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_step_prev(spinbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Increment spinbox value by one step"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        pub fn increment(spinbox: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Increment spinbox value by one step"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                pub fn lv_spinbox_increment(spinbox: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_increment(spinbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Decrement spinbox value by one step"]
        #[doc = " - __`spinbox`__: pointer to spinbox"]
        pub fn decrement(spinbox: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Decrement spinbox value by one step"]
                #[doc = " - __`spinbox`__: pointer to spinbox"]
                pub fn lv_spinbox_decrement(spinbox: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinbox_decrement(spinbox as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Spinner Widget API `lv_spinner`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod spinner {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_SPINNER_DEF_ARC_LENGTH: u32 = 60;
        pub const LV_SPINNER_DEF_SPIN_TIME: u32 = 1000;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[repr(C)]
        pub struct lv_arc_ext_t {
            pub rotation_angle: u16,
            pub arc_angle_start: u16,
            pub arc_angle_end: u16,
            pub bg_angle_start: u16,
            pub bg_angle_end: u16,
            pub style_arc: lv_style_list_t,
            pub style_knob: lv_style_list_t,
            pub cur_value: i16,
            pub min_value: i16,
            pub max_value: i16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub chg_rate: u16,
            pub last_tick: u32,
            pub last_angle: i16,
        }
        impl Default for lv_arc_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_arc_ext_t {
            #[inline]
            pub fn dragging(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_dragging(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn type_(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn adjustable(&self) -> u16 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u16)
                }
            }
            #[inline]
            pub fn set_adjustable(&mut self, val: u16) {
                unsafe {
                    let val: u16 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(dragging: u16, type_: u16, adjustable: u16)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let dragging: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(dragging)
                                                    };
                                                dragging as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 2u8,
                                            {
                                                let type_: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let adjustable: u16 =
                                                    unsafe {
                                                        ::core::mem::transmute(adjustable)
                                                    };
                                                adjustable as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_SPINNER_TYPE_SPINNING_ARC: _bindgen_ty_34 = 0;
        pub const LV_SPINNER_TYPE_FILLSPIN_ARC: _bindgen_ty_34 = 1;
        pub const LV_SPINNER_TYPE_CONSTANT_ARC: _bindgen_ty_34 = 2;
        #[doc = " Type of spinner."]
        pub type _bindgen_ty_34 = u32;
        pub type lv_spinner_type_t = u8;
        pub const LV_SPINNER_DIR_FORWARD: _bindgen_ty_35 = 0;
        pub const LV_SPINNER_DIR_BACKWARD: _bindgen_ty_35 = 1;
        #[doc = " Direction the spinner should spin."]
        pub type _bindgen_ty_35 = u32;
        pub type lv_spinner_dir_t = u8;
        #[repr(C)]
        pub struct lv_spinner_ext_t {
            pub arc: lv_arc_ext_t,
            pub arc_length: lv_anim_value_t,
            pub time: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        impl Default for lv_spinner_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_spinner_ext_t {
            #[inline]
            pub fn anim_type(&self) -> lv_spinner_type_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_anim_type(&mut self, val: lv_spinner_type_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn anim_dir(&self) -> lv_spinner_dir_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_anim_dir(&mut self, val: lv_spinner_dir_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(anim_type: lv_spinner_type_t,
                                  anim_dir: lv_spinner_dir_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let anim_type: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(anim_type)
                                                    };
                                                anim_type as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let anim_dir: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(anim_dir)
                                                    };
                                                anim_dir as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_SPINNER_PART_BG: _bindgen_ty_36 = 0;
        pub const LV_SPINNER_PART_INDIC: _bindgen_ty_36 = 1;
        pub const _LV_SPINNER_PART_VIRTUAL_LAST: _bindgen_ty_36 = 2;
        pub const _LV_SPINNER_PART_REAL_LAST: _bindgen_ty_36 = 64;
        pub type _bindgen_ty_36 = u32;
        pub type lv_spinner_style_t = u8;
        #[doc = " Create a spinner object"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new spinner"]
        #[doc =
          " - __`copy`__: pointer to a spinner object, if not NULL then the new object will be copied from"]
        #[doc = " it"]
        #[doc = " Return: pointer to the created spinner"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a spinner object"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new spinner"]
                #[doc =
                  " - __`copy`__: pointer to a spinner object, if not NULL then the new object will be copied from"]
                #[doc = " it"]
                #[doc = " Return: pointer to the created spinner"]
                pub fn lv_spinner_create(par: *mut lv_obj_t,
                                         copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinner_create(par as *mut lv_obj_t,
                                      copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the length of the spinning  arc in degrees"]
        #[doc = " - __`spinner`__: pointer to a spinner object"]
        #[doc = " - __`deg`__: length of the arc"]
        pub fn set_arc_length(spinner: *mut lv_obj_t, deg: lv_anim_value_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the length of the spinning  arc in degrees"]
                #[doc = " - __`spinner`__: pointer to a spinner object"]
                #[doc = " - __`deg`__: length of the arc"]
                pub fn lv_spinner_set_arc_length(spinner: *mut lv_obj_t,
                                                 deg: lv_anim_value_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinner_set_arc_length(spinner as *mut lv_obj_t,
                                          deg as lv_anim_value_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the spin time of the arc"]
        #[doc = " - __`spinner`__: pointer to a spinner object"]
        #[doc = " - __`time`__: time of one round in milliseconds"]
        pub fn set_spin_time(spinner: *mut lv_obj_t, time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the spin time of the arc"]
                #[doc = " - __`spinner`__: pointer to a spinner object"]
                #[doc = " - __`time`__: time of one round in milliseconds"]
                pub fn lv_spinner_set_spin_time(spinner: *mut lv_obj_t,
                                                time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinner_set_spin_time(spinner as *mut lv_obj_t,
                                         time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the animation type of a spinner."]
        #[doc = " - __`spinner`__: pointer to spinner object"]
        #[doc = " - __`type`__: animation type of the spinner"]
        pub fn set_type(spinner: *mut lv_obj_t, type_: lv_spinner_type_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation type of a spinner."]
                #[doc = " - __`spinner`__: pointer to spinner object"]
                #[doc = " - __`type`__: animation type of the spinner"]
                pub fn lv_spinner_set_type(spinner: *mut lv_obj_t,
                                           type_: lv_spinner_type_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinner_set_type(spinner as *mut lv_obj_t,
                                    type_ as lv_spinner_type_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the animation direction of a spinner"]
        #[doc = " - __`spinner`__: pointer to spinner object"]
        #[doc = " - __`direction`__: animation direction of the spinner"]
        pub fn set_dir(spinner: *mut lv_obj_t, dir: lv_spinner_dir_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation direction of a spinner"]
                #[doc = " - __`spinner`__: pointer to spinner object"]
                #[doc =
                  " - __`direction`__: animation direction of the spinner"]
                pub fn lv_spinner_set_dir(spinner: *mut lv_obj_t,
                                          dir: lv_spinner_dir_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinner_set_dir(spinner as *mut lv_obj_t,
                                   dir as lv_spinner_dir_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the arc length [degree] of the a spinner"]
        #[doc = " - __`spinner`__: pointer to a spinner object"]
        pub fn get_arc_length(spinner: *const lv_obj_t)
         -> MynewtResult<lv_anim_value_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the arc length [degree] of the a spinner"]
                #[doc = " - __`spinner`__: pointer to a spinner object"]
                pub fn lv_spinner_get_arc_length(spinner: *const lv_obj_t)
                -> lv_anim_value_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinner_get_arc_length(spinner as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the spin time of the arc"]
        #[doc =
          " - __`spinner`__: pointer to a spinner object [milliseconds]"]
        pub fn get_spin_time(spinner: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the spin time of the arc"]
                #[doc =
                  " - __`spinner`__: pointer to a spinner object [milliseconds]"]
                pub fn lv_spinner_get_spin_time(spinner: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinner_get_spin_time(spinner as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation type of a spinner."]
        #[doc = " - __`spinner`__: pointer to spinner object"]
        #[doc = " Return: animation type"]
        pub fn get_type(spinner: *mut lv_obj_t)
         -> MynewtResult<lv_spinner_type_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation type of a spinner."]
                #[doc = " - __`spinner`__: pointer to spinner object"]
                #[doc = " Return: animation type"]
                pub fn lv_spinner_get_type(spinner: *mut lv_obj_t)
                -> lv_spinner_type_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinner_get_type(spinner as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation direction of a spinner"]
        #[doc = " - __`spinner`__: pointer to spinner object"]
        #[doc = " Return: animation direction"]
        pub fn get_dir(spinner: *mut lv_obj_t)
         -> MynewtResult<lv_spinner_dir_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation direction of a spinner"]
                #[doc = " - __`spinner`__: pointer to spinner object"]
                #[doc = " Return: animation direction"]
                pub fn lv_spinner_get_dir(spinner: *mut lv_obj_t)
                -> lv_spinner_dir_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_spinner_get_dir(spinner as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Animator function  (exec_cb) to rotate the arc of spinner."]
        #[doc = " - __`ptr`__: pointer to spinner"]
        #[doc = " - __`val`__: the current desired value [0..360]"]
        pub fn anim_cb(ptr: Ptr, val: lv_anim_value_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Animator function  (exec_cb) to rotate the arc of spinner."]
                #[doc = " - __`ptr`__: pointer to spinner"]
                #[doc = " - __`val`__: the current desired value [0..360]"]
                pub fn lv_spinner_anim_cb(ptr: *mut ::cty::c_void,
                                          val: lv_anim_value_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_spinner_anim_cb(ptr as *mut ::cty::c_void,
                                   val as lv_anim_value_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Switch Widget API `lv_switch`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod switch {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        #[repr(C)]
        pub struct lv_bar_anim_t {
            pub bar: *mut lv_obj_t,
            pub anim_start: lv_anim_value_t,
            pub anim_end: lv_anim_value_t,
            pub anim_state: lv_anim_value_t,
        }
        impl Default for lv_bar_anim_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = " Data of bar"]
        #[repr(C)]
        pub struct lv_bar_ext_t {
            pub cur_value: i16,
            pub min_value: i16,
            pub max_value: i16,
            pub start_value: i16,
            pub indic_area: lv_area_t,
            pub anim_time: lv_anim_value_t,
            pub cur_value_anim: lv_bar_anim_t,
            pub start_value_anim: lv_bar_anim_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub style_indic: lv_style_list_t,
        }
        impl Default for lv_bar_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_bar_ext_t {
            #[inline]
            pub fn type_(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(type_: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let type_: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_switch_ext_t {
            pub bar: lv_bar_ext_t,
            pub style_knob: lv_style_list_t,
        }
        impl Default for lv_switch_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "< Switch background."]
        pub const LV_SWITCH_PART_BG: _bindgen_ty_43 = 0;
        #[doc = "< Switch fill area."]
        pub const LV_SWITCH_PART_INDIC: _bindgen_ty_43 = 1;
        #[doc = "< Switch knob."]
        pub const LV_SWITCH_PART_KNOB: _bindgen_ty_43 = 2;
        pub const _LV_SWITCH_PART_VIRTUAL_LAST: _bindgen_ty_43 = 3;
        #[doc = " Switch parts."]
        pub type _bindgen_ty_43 = u32;
        pub type lv_switch_part_t = u8;
        #[doc = " Create a switch objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new switch"]
        #[doc =
          " - __`copy`__: pointer to a switch object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created switch"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a switch objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new switch"]
                #[doc =
                  " - __`copy`__: pointer to a switch object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created switch"]
                pub fn lv_switch_create(par: *mut lv_obj_t,
                                        copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_switch_create(par as *mut lv_obj_t,
                                     copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Turn ON the switch"]
        #[doc = " - __`sw`__: pointer to a switch object"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn on(sw: *mut lv_obj_t, anim: lv_anim_enable_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Turn ON the switch"]
                #[doc = " - __`sw`__: pointer to a switch object"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_switch_on(sw: *mut lv_obj_t,
                                    anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_switch_on(sw as *mut lv_obj_t, anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Turn OFF the switch"]
        #[doc = " - __`sw`__: pointer to a switch object"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn off(sw: *mut lv_obj_t, anim: lv_anim_enable_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Turn OFF the switch"]
                #[doc = " - __`sw`__: pointer to a switch object"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_switch_off(sw: *mut lv_obj_t,
                                     anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_switch_off(sw as *mut lv_obj_t, anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Toggle the position of the switch"]
        #[doc = " - __`sw`__: pointer to a switch object"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        #[doc = " Return: resulting state of the switch."]
        pub fn toggle(sw: *mut lv_obj_t, anim: lv_anim_enable_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Toggle the position of the switch"]
                #[doc = " - __`sw`__: pointer to a switch object"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                #[doc = " Return: resulting state of the switch."]
                pub fn lv_switch_toggle(sw: *mut lv_obj_t,
                                        anim: lv_anim_enable_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_switch_toggle(sw as *mut lv_obj_t,
                                     anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the animation time of the switch"]
        #[doc = " - __`sw`__: pointer to a  switch object"]
        #[doc = " - __`anim_time`__: animation time"]
        #[doc = " Return: style pointer to a style"]
        pub fn set_anim_time(sw: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation time of the switch"]
                #[doc = " - __`sw`__: pointer to a  switch object"]
                #[doc = " - __`anim_time`__: animation time"]
                #[doc = " Return: style pointer to a style"]
                pub fn lv_switch_set_anim_time(sw: *mut lv_obj_t,
                                               anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_switch_set_anim_time(sw as *mut lv_obj_t,
                                        anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the state of a switch"]
        #[doc = " - __`sw`__: pointer to a switch object"]
        #[doc = " Return: false: OFF; true: ON"]
        pub fn get_state(sw: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the state of a switch"]
                #[doc = " - __`sw`__: pointer to a switch object"]
                #[doc = " Return: false: OFF; true: ON"]
                pub fn lv_switch_get_state(sw: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_switch_get_state(sw as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation time of the switch"]
        #[doc = " - __`sw`__: pointer to a  switch object"]
        #[doc = " Return: style pointer to a style"]
        pub fn get_anim_time(sw: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation time of the switch"]
                #[doc = " - __`sw`__: pointer to a  switch object"]
                #[doc = " Return: style pointer to a style"]
                pub fn lv_switch_get_anim_time(sw: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_switch_get_anim_time(sw as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Table Widget API `lv_table`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod table {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        #[repr(C)]
        pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
        impl <T> __BindgenUnionField<T> {
            #[inline]
            pub fn new() -> Self {
                __BindgenUnionField(::core::marker::PhantomData)
            }
            #[inline]
            pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
            #[inline]
            pub unsafe fn as_mut(&mut self) -> &mut T {
                ::core::mem::transmute(self)
            }
        }
        impl <T> ::core::default::Default for __BindgenUnionField<T> {
            #[inline]
            fn default() -> Self { Self::new() }
        }
        impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
            #[inline]
            fn clone(&self) -> Self { Self::new() }
        }
        impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
        impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>)
             -> ::core::fmt::Result {
                fmt.write_str("__BindgenUnionField")
            }
        }
        impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
            fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
        }
        impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
            fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
        }
        impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
        pub const LV_TABLE_COL_MAX: u32 = 12;
        pub const LV_TABLE_CELL_STYLE_CNT: u32 = 4;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_label_align_t = u8;
        #[doc = " Internal table cell format structure."]
        #[doc = ""]
        #[doc = " Use the `lv_table` APIs instead."]
        #[repr(C)]
        pub struct lv_table_cell_format_t {
            pub s: __BindgenUnionField<lv_table_cell_format_t__bindgen_ty_1>,
            pub format_byte: __BindgenUnionField<u8>,
            pub bindgen_union_field: u8,
        }
        #[repr(C, packed)]
        pub struct lv_table_cell_format_t__bindgen_ty_1 {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_table_cell_format_t__bindgen_ty_1
         {
            #[inline]
            fn default() -> lv_table_cell_format_t__bindgen_ty_1 {
                lv_table_cell_format_t__bindgen_ty_1{_bitfield_1:
                                                         ::core::default::Default::default(),}
            }
        }
        impl lv_table_cell_format_t__bindgen_ty_1 {
            #[inline]
            pub fn align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn right_merge(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_merge(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn type_(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_type(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn crop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_crop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(align: u8, right_merge: u8, type_: u8,
                                  crop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 2u8,
                                            {
                                                let align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(align)
                                                    };
                                                align as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let right_merge: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_merge)
                                                    };
                                                right_merge as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 2u8,
                                            {
                                                let type_: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(type_)
                                                    };
                                                type_ as u64
                                            });
                __bindgen_bitfield_unit.set(5usize, 1u8,
                                            {
                                                let crop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(crop)
                                                    };
                                                crop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_table_cell_format_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[repr(C)]
        pub struct lv_table_ext_t {
            pub col_cnt: u16,
            pub row_cnt: u16,
            pub cell_data: *mut *mut ::cty::c_char,
            pub row_h: *mut lv_coord_t,
            pub cell_style: [lv_style_list_t; 4usize],
            pub col_w: [lv_coord_t; 12usize],
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_table_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_table_ext_t {
            #[inline]
            pub fn cell_types(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_cell_types(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(cell_types: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let cell_types: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(cell_types)
                                                    };
                                                cell_types as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_TABLE_PART_BG: _bindgen_ty_35 = 0;
        pub const LV_TABLE_PART_CELL1: _bindgen_ty_35 = 1;
        pub const LV_TABLE_PART_CELL2: _bindgen_ty_35 = 2;
        pub const LV_TABLE_PART_CELL3: _bindgen_ty_35 = 3;
        pub const LV_TABLE_PART_CELL4: _bindgen_ty_35 = 4;
        pub type _bindgen_ty_35 = u32;
        #[doc = " Create a table object"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new table"]
        #[doc =
          " - __`copy`__: pointer to a table object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created table"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a table object"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new table"]
                #[doc =
                  " - __`copy`__: pointer to a table object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created table"]
                pub fn lv_table_create(par: *mut lv_obj_t,
                                       copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_create(par as *mut lv_obj_t,
                                    copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the value of a cell."]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc =
          " - __`txt`__: text to display in the cell. It will be copied and saved so this variable is not"]
        #[doc = " required after this function call."]
        pub fn set_cell_value(table: *mut lv_obj_t, row: u16, col: u16,
                              txt: &Strn) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the value of a cell."]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " - __`txt`__: text to display in the cell. It will be copied and saved so this variable is not"]
                #[doc = " required after this function call."]
                pub fn lv_table_set_cell_value(table: *mut lv_obj_t, row: u16,
                                               col: u16,
                                               txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_cell_value(table as *mut lv_obj_t, row as u16,
                                        col as u16,
                                        txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the number of rows"]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc = " - __`row_cnt`__: number of rows"]
        pub fn set_row_cnt(table: *mut lv_obj_t, row_cnt: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the number of rows"]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc = " - __`row_cnt`__: number of rows"]
                pub fn lv_table_set_row_cnt(table: *mut lv_obj_t,
                                            row_cnt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_row_cnt(table as *mut lv_obj_t, row_cnt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the number of columns"]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc =
          " - __`col_cnt`__: number of columns. Must be < LV_TABLE_COL_MAX"]
        pub fn set_col_cnt(table: *mut lv_obj_t, col_cnt: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the number of columns"]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc =
                  " - __`col_cnt`__: number of columns. Must be < LV_TABLE_COL_MAX"]
                pub fn lv_table_set_col_cnt(table: *mut lv_obj_t,
                                            col_cnt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_col_cnt(table as *mut lv_obj_t, col_cnt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the width of a column"]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc =
          " - __`col_id`__: id of the column [0 .. LV_TABLE_COL_MAX -1]"]
        #[doc = " - __`w`__: width of the column"]
        pub fn set_col_width(table: *mut lv_obj_t, col_id: u16, w: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the width of a column"]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc =
                  " - __`col_id`__: id of the column [0 .. LV_TABLE_COL_MAX -1]"]
                #[doc = " - __`w`__: width of the column"]
                pub fn lv_table_set_col_width(table: *mut lv_obj_t,
                                              col_id: u16, w: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_col_width(table as *mut lv_obj_t, col_id as u16,
                                       w as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the text align in a cell"]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc =
          " - __`align`__: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER or LV_LABEL_ALIGN_RIGHT"]
        pub fn set_cell_align(table: *mut lv_obj_t, row: u16, col: u16,
                              align: lv_label_align_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the text align in a cell"]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " - __`align`__: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER or LV_LABEL_ALIGN_RIGHT"]
                pub fn lv_table_set_cell_align(table: *mut lv_obj_t, row: u16,
                                               col: u16,
                                               align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_cell_align(table as *mut lv_obj_t, row as u16,
                                        col as u16,
                                        align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the type of a cell."]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc =
          " - __`type`__: 1,2,3 or 4. The cell style will be chosen accordingly."]
        pub fn set_cell_type(table: *mut lv_obj_t, row: u16, col: u16,
                             type_: u8) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the type of a cell."]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " - __`type`__: 1,2,3 or 4. The cell style will be chosen accordingly."]
                pub fn lv_table_set_cell_type(table: *mut lv_obj_t, row: u16,
                                              col: u16, type_: u8);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_cell_type(table as *mut lv_obj_t, row as u16,
                                       col as u16, type_ as u8);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the cell crop. (Don't adjust the height of the cell according to its content)"]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc =
          " - __`crop`__: true: crop the cell content; false: set the cell height to the content."]
        pub fn set_cell_crop(table: *mut lv_obj_t, row: u16, col: u16,
                             crop: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the cell crop. (Don't adjust the height of the cell according to its content)"]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " - __`crop`__: true: crop the cell content; false: set the cell height to the content."]
                pub fn lv_table_set_cell_crop(table: *mut lv_obj_t, row: u16,
                                              col: u16, crop: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_cell_crop(table as *mut lv_obj_t, row as u16,
                                       col as u16, crop as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Merge a cell with the right neighbor. The value of the cell to the right won't be displayed."]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc = " - __`en`__: true: merge right; false: don't merge right"]
        pub fn set_cell_merge_right(table: *mut lv_obj_t, row: u16, col: u16,
                                    en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Merge a cell with the right neighbor. The value of the cell to the right won't be displayed."]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " - __`en`__: true: merge right; false: don't merge right"]
                pub fn lv_table_set_cell_merge_right(table: *mut lv_obj_t,
                                                     row: u16, col: u16,
                                                     en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_table_set_cell_merge_right(table as *mut lv_obj_t,
                                              row as u16, col as u16,
                                              en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the number of rows."]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc = " Return: number of rows."]
        pub fn get_row_cnt(table: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of rows."]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc = " Return: number of rows."]
                pub fn lv_table_get_row_cnt(table: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_row_cnt(table as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of columns."]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc = " Return: number of columns."]
        pub fn get_col_cnt(table: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of columns."]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc = " Return: number of columns."]
                pub fn lv_table_get_col_cnt(table: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_col_cnt(table as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the width of a column"]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc =
          " - __`col_id`__: id of the column [0 .. LV_TABLE_COL_MAX -1]"]
        #[doc = " Return: width of the column"]
        pub fn get_col_width(table: *mut lv_obj_t, col_id: u16)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of a column"]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc =
                  " - __`col_id`__: id of the column [0 .. LV_TABLE_COL_MAX -1]"]
                #[doc = " Return: width of the column"]
                pub fn lv_table_get_col_width(table: *mut lv_obj_t,
                                              col_id: u16)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_col_width(table as *mut lv_obj_t,
                                           col_id as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the text align of a cell"]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc =
          " Return: LV_LABEL_ALIGN_LEFT (default in case of error) or LV_LABEL_ALIGN_CENTER or"]
        #[doc = " LV_LABEL_ALIGN_RIGHT"]
        pub fn get_cell_align(table: *mut lv_obj_t, row: u16, col: u16)
         -> MynewtResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the text align of a cell"]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " Return: LV_LABEL_ALIGN_LEFT (default in case of error) or LV_LABEL_ALIGN_CENTER or"]
                #[doc = " LV_LABEL_ALIGN_RIGHT"]
                pub fn lv_table_get_cell_align(table: *mut lv_obj_t, row: u16,
                                               col: u16)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_cell_align(table as *mut lv_obj_t,
                                            row as u16, col as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the type of a cell"]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc = " Return: 1,2,3 or 4"]
        pub fn get_cell_type(table: *mut lv_obj_t, row: u16, col: u16)
         -> MynewtResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the type of a cell"]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc = " Return: 1,2,3 or 4"]
                pub fn lv_table_get_cell_type(table: *mut lv_obj_t, row: u16,
                                              col: u16)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_cell_type(table as *mut lv_obj_t, row as u16,
                                           col as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the crop property of a cell"]
        #[doc = " - __`table`__: pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc = " Return: true: text crop enabled; false: disabled"]
        pub fn get_cell_crop(table: *mut lv_obj_t, row: u16, col: u16)
         -> MynewtResult<lv_label_align_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the crop property of a cell"]
                #[doc = " - __`table`__: pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc = " Return: true: text crop enabled; false: disabled"]
                pub fn lv_table_get_cell_crop(table: *mut lv_obj_t, row: u16,
                                              col: u16)
                -> lv_label_align_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_cell_crop(table as *mut lv_obj_t, row as u16,
                                           col as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the cell merge attribute."]
        #[doc = " - __`table`__: table pointer to a Table object"]
        #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
        #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
        #[doc = " Return: true: merge right; false: don't merge right"]
        pub fn get_cell_merge_right(table: *mut lv_obj_t, row: u16, col: u16)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the cell merge attribute."]
                #[doc = " - __`table`__: table pointer to a Table object"]
                #[doc = " - __`row`__: id of the row [0 .. row_cnt -1]"]
                #[doc = " - __`col`__: id of the column [0 .. col_cnt -1]"]
                #[doc =
                  " Return: true: merge right; false: don't merge right"]
                pub fn lv_table_get_cell_merge_right(table: *mut lv_obj_t,
                                                     row: u16, col: u16)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_cell_merge_right(table as *mut lv_obj_t,
                                                  row as u16, col as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the last pressed or being pressed cell"]
        #[doc = " - __`table`__: pointer to a table object"]
        #[doc = " - __`row`__: pointer to variable to store the pressed row"]
        #[doc =
          " - __`col`__: pointer to variable to store the pressed column"]
        #[doc =
          " Return: LV_RES_OK: a valid pressed cell was found, LV_RES_INV: no valid cell is pressed"]
        pub fn get_pressed_cell(table: *mut lv_obj_t, row: *mut u16,
                                col: *mut u16) -> MynewtResult<lv_res_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the last pressed or being pressed cell"]
                #[doc = " - __`table`__: pointer to a table object"]
                #[doc =
                  " - __`row`__: pointer to variable to store the pressed row"]
                #[doc =
                  " - __`col`__: pointer to variable to store the pressed column"]
                #[doc =
                  " Return: LV_RES_OK: a valid pressed cell was found, LV_RES_INV: no valid cell is pressed"]
                pub fn lv_table_get_pressed_cell(table: *mut lv_obj_t,
                                                 row: *mut u16, col: *mut u16)
                -> lv_res_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_table_get_pressed_cell(table as *mut lv_obj_t,
                                              row as *mut u16,
                                              col as *mut u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Tab View Widget API `lv_tabview`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod tabview {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_TABVIEW_DEF_ANIM_TIME: u32 = 300;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub const LV_TABVIEW_TAB_POS_NONE: _bindgen_ty_46 = 0;
        pub const LV_TABVIEW_TAB_POS_TOP: _bindgen_ty_46 = 1;
        pub const LV_TABVIEW_TAB_POS_BOTTOM: _bindgen_ty_46 = 2;
        pub const LV_TABVIEW_TAB_POS_LEFT: _bindgen_ty_46 = 3;
        pub const LV_TABVIEW_TAB_POS_RIGHT: _bindgen_ty_46 = 4;
        #[doc = " Position of tabview buttons."]
        pub type _bindgen_ty_46 = u32;
        pub type lv_tabview_btns_pos_t = u8;
        #[repr(C)]
        pub struct lv_tabview_ext_t {
            pub btns: *mut lv_obj_t,
            pub indic: *mut lv_obj_t,
            pub content: *mut lv_obj_t,
            pub tab_name_ptr: *mut *const ::cty::c_char,
            pub point_last: lv_point_t,
            pub tab_cur: u16,
            pub tab_cnt: u16,
            pub anim_time: u16,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 5usize],
        }
        impl Default for lv_tabview_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_tabview_ext_t {
            #[inline]
            pub fn btns_pos(&self) -> lv_tabview_btns_pos_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_btns_pos(&mut self, val: lv_tabview_btns_pos_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(btns_pos: lv_tabview_btns_pos_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 3u8,
                                            {
                                                let btns_pos: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(btns_pos)
                                                    };
                                                btns_pos as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_TABVIEW_PART_BG: _bindgen_ty_47 = 0;
        pub const _LV_TABVIEW_PART_VIRTUAL_LAST: _bindgen_ty_47 = 1;
        pub const LV_TABVIEW_PART_BG_SCRLLABLE: _bindgen_ty_47 = 64;
        pub const LV_TABVIEW_PART_TAB_BG: _bindgen_ty_47 = 65;
        pub const LV_TABVIEW_PART_TAB_BTN: _bindgen_ty_47 = 66;
        pub const LV_TABVIEW_PART_INDIC: _bindgen_ty_47 = 67;
        pub const _LV_TABVIEW_PART_REAL_LAST: _bindgen_ty_47 = 68;
        pub type _bindgen_ty_47 = u32;
        pub type lv_tabview_part_t = u8;
        #[doc = " Create a Tab view object"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new tab"]
        #[doc =
          " - __`copy`__: pointer to a tab object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created tab"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a Tab view object"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new tab"]
                #[doc =
                  " - __`copy`__: pointer to a tab object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created tab"]
                pub fn lv_tabview_create(par: *mut lv_obj_t,
                                         copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_create(par as *mut lv_obj_t,
                                      copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Add a new tab with the given name"]
        #[doc =
          " - __`tabview`__: pointer to Tab view object where to ass the new tab"]
        #[doc = " - __`name`__: the text on the tab button"]
        #[doc =
          " Return: pointer to the created page object (lv_page). You can create your content here"]
        pub fn add_tab(tabview: *mut lv_obj_t, name: &Strn)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Add a new tab with the given name"]
                #[doc =
                  " - __`tabview`__: pointer to Tab view object where to ass the new tab"]
                #[doc = " - __`name`__: the text on the tab button"]
                #[doc =
                  " Return: pointer to the created page object (lv_page). You can create your content here"]
                pub fn lv_tabview_add_tab(tabview: *mut lv_obj_t,
                                          name: *const ::cty::c_char)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            name.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_add_tab(tabview as *mut lv_obj_t,
                                       name.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Delete all children of a tab created by `lv_tabview_add_tab`."]
        #[doc = " - __`tab`__: pointer to a tab"]
        pub fn clean_tab(tab: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete all children of a tab created by `lv_tabview_add_tab`."]
                #[doc = " - __`tab`__: pointer to a tab"]
                pub fn lv_tabview_clean_tab(tab: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tabview_clean_tab(tab as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set a new tab"]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " - __`id`__: index of a tab to load"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn set_tab_act(tabview: *mut lv_obj_t, id: u16,
                           anim: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set a new tab"]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc = " - __`id`__: index of a tab to load"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_tabview_set_tab_act(tabview: *mut lv_obj_t, id: u16,
                                              anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tabview_set_tab_act(tabview as *mut lv_obj_t, id as u16,
                                       anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the name of a tab."]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " - __`id`__: index of the tab the name should be set"]
        #[doc = " - __`name`__: new tab name"]
        pub fn set_tab_name(tabview: *mut lv_obj_t, id: u16,
                            name: *mut ::cty::c_char) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the name of a tab."]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc =
                  " - __`id`__: index of the tab the name should be set"]
                #[doc = " - __`name`__: new tab name"]
                pub fn lv_tabview_set_tab_name(tabview: *mut lv_obj_t,
                                               id: u16,
                                               name: *mut ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tabview_set_tab_name(tabview as *mut lv_obj_t, id as u16,
                                        name as *mut ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the animation time of tab view when a new tab is loaded"]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " - __`anim_time`__: time of animation in milliseconds"]
        pub fn set_anim_time(tabview: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the animation time of tab view when a new tab is loaded"]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc =
                  " - __`anim_time`__: time of animation in milliseconds"]
                pub fn lv_tabview_set_anim_time(tabview: *mut lv_obj_t,
                                                anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tabview_set_anim_time(tabview as *mut lv_obj_t,
                                         anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the position of tab select buttons"]
        #[doc = " - __`tabview`__: pointer to a tab view object"]
        #[doc = " - __`btns_pos`__: which button position"]
        pub fn set_btns_pos(tabview: *mut lv_obj_t,
                            btns_pos: lv_tabview_btns_pos_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the position of tab select buttons"]
                #[doc = " - __`tabview`__: pointer to a tab view object"]
                #[doc = " - __`btns_pos`__: which button position"]
                pub fn lv_tabview_set_btns_pos(tabview: *mut lv_obj_t,
                                               btns_pos:
                                                   lv_tabview_btns_pos_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tabview_set_btns_pos(tabview as *mut lv_obj_t,
                                        btns_pos as lv_tabview_btns_pos_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the index of the currently active tab"]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " Return: the active tab index"]
        pub fn get_tab_act(tabview: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the index of the currently active tab"]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc = " Return: the active tab index"]
                pub fn lv_tabview_get_tab_act(tabview: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_get_tab_act(tabview as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the number of tabs"]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " Return: tab count"]
        pub fn get_tab_count(tabview: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the number of tabs"]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc = " Return: tab count"]
                pub fn lv_tabview_get_tab_count(tabview: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_get_tab_count(tabview as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the page (content area) of a tab"]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " - __`id`__: index of the tab (>= 0)"]
        #[doc = " Return: pointer to page (lv_page) object"]
        pub fn get_tab(tabview: *const lv_obj_t, id: u16)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the page (content area) of a tab"]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc = " - __`id`__: index of the tab (>= 0)"]
                #[doc = " Return: pointer to page (lv_page) object"]
                pub fn lv_tabview_get_tab(tabview: *const lv_obj_t, id: u16)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_get_tab(tabview as *const lv_obj_t, id as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the animation time of tab view when a new tab is loaded"]
        #[doc = " - __`tabview`__: pointer to Tab view object"]
        #[doc = " Return: time of animation in milliseconds"]
        pub fn get_anim_time(tabview: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the animation time of tab view when a new tab is loaded"]
                #[doc = " - __`tabview`__: pointer to Tab view object"]
                #[doc = " Return: time of animation in milliseconds"]
                pub fn lv_tabview_get_anim_time(tabview: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_get_anim_time(tabview as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get position of tab select buttons"]
        #[doc = " - __`tabview`__: pointer to a ab view object"]
        pub fn get_btns_pos(tabview: *const lv_obj_t)
         -> MynewtResult<lv_tabview_btns_pos_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get position of tab select buttons"]
                #[doc = " - __`tabview`__: pointer to a ab view object"]
                pub fn lv_tabview_get_btns_pos(tabview: *const lv_obj_t)
                -> lv_tabview_btns_pos_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tabview_get_btns_pos(tabview as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Text Area Widget API `lv_textarea`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod textarea {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_TEXTAREA_DEF_CURSOR_BLINK_TIME: u32 = 400;
        pub const LV_TEXTAREA_DEF_PWD_SHOW_TIME: u32 = 1500;
        pub const LV_TEXTAREA_CURSOR_LAST: u32 = 32767;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_scrollbar_mode_t = u8;
        #[repr(C)]
        pub struct lv_page_ext_t {
            pub bg: lv_cont_ext_t,
            pub scrl: *mut lv_obj_t,
            pub scrlbar: lv_page_ext_t__bindgen_ty_1,
            pub edge_flash: lv_page_ext_t__bindgen_ty_2,
            pub anim_time: u16,
            pub scroll_prop_obj: *mut lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub hor_area: lv_area_t,
            pub ver_area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn hor_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hor_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ver_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ver_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mode(&self) -> lv_scrollbar_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(hor_draw: u8, ver_draw: u8,
                                  mode: lv_scrollbar_mode_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let hor_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hor_draw)
                                                    };
                                                hor_draw as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let ver_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ver_draw)
                                                    };
                                                ver_draw as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_2 {
            pub state: lv_anim_value_t,
            pub style: lv_style_list_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_2 {
            #[inline]
            pub fn enabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_enabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bottom_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_bottom_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn right_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn left_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_left_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(enabled: u8, top_ip: u8, bottom_ip: u8,
                                  right_ip: u8, left_ip: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let enabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(enabled)
                                                    };
                                                enabled as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let top_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top_ip)
                                                    };
                                                top_ip as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let bottom_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(bottom_ip)
                                                    };
                                                bottom_ip as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let right_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_ip)
                                                    };
                                                right_ip as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let left_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(left_ip)
                                                    };
                                                left_ip as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_page_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t {
            #[inline]
            pub fn scroll_prop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_scroll_prop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(scroll_prop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let scroll_prop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(scroll_prop)
                                                    };
                                                scroll_prop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_label_align_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_textarea_ext_t {
            pub page: lv_page_ext_t,
            pub label: *mut lv_obj_t,
            pub placeholder_txt: *mut ::cty::c_char,
            pub style_placeholder: lv_style_list_t,
            pub pwd_tmp: *mut ::cty::c_char,
            pub accapted_chars: *const ::cty::c_char,
            pub max_length: u32,
            pub pwd_show_time: u16,
            pub cursor: lv_textarea_ext_t__bindgen_ty_1,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_textarea_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub valid_x: lv_coord_t,
            pub pos: u32,
            pub blink_time: u16,
            pub area: lv_area_t,
            pub txt_byte_pos: u32,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_textarea_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_textarea_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn state(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_state(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hidden(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hidden(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn click_pos(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_click_pos(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(state: u8, hidden: u8, click_pos: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let state: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(state)
                                                    };
                                                state as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let hidden: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hidden)
                                                    };
                                                hidden as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let click_pos: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(click_pos)
                                                    };
                                                click_pos as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_textarea_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_textarea_ext_t {
            #[inline]
            pub fn pwd_mode(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_pwd_mode(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn one_line(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_one_line(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(pwd_mode: u8, one_line: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let pwd_mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(pwd_mode)
                                                    };
                                                pwd_mode as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let one_line: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(one_line)
                                                    };
                                                one_line as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "< Text area background style"]
        pub const LV_TEXTAREA_PART_BG: _bindgen_ty_42 = 0;
        #[doc = "< Scrollbar style"]
        pub const LV_TEXTAREA_PART_SCROLLBAR: _bindgen_ty_42 = 1;
        #[doc = "< Edge flash style"]
        pub const LV_TEXTAREA_PART_EDGE_FLASH: _bindgen_ty_42 = 2;
        #[doc = "< Cursor style"]
        pub const LV_TEXTAREA_PART_CURSOR: _bindgen_ty_42 = 3;
        #[doc = "< Placeholder style"]
        pub const LV_TEXTAREA_PART_PLACEHOLDER: _bindgen_ty_42 = 4;
        pub const _LV_TEXTAREA_PART_VIRTUAL_LAST: _bindgen_ty_42 = 5;
        pub const _LV_TEXTAREA_PART_REAL_LAST: _bindgen_ty_42 = 65;
        #[doc = " Possible text areas styles."]
        pub type _bindgen_ty_42 = u32;
        pub type lv_textarea_style_t = u8;
        #[doc = " Create a text area objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new text area"]
        #[doc =
          " - __`copy`__: pointer to a text area object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created text area"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a text area objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new text area"]
                #[doc =
                  " - __`copy`__: pointer to a text area object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created text area"]
                pub fn lv_textarea_create(par: *mut lv_obj_t,
                                          copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_create(par as *mut lv_obj_t,
                                       copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Insert a character to the current cursor position."]
        #[doc =
          " To add a wide char, e.g. '\u{c1}' use `_lv_txt_encoded_conv_wc('\u{c1}')`"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " - __`c`__: a character (e.g. 'a')"]
        pub fn add_char(ta: *mut lv_obj_t, c: u32) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Insert a character to the current cursor position."]
                #[doc =
                  " To add a wide char, e.g. '\u{c1}' use `_lv_txt_encoded_conv_wc('\u{c1}')`"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " - __`c`__: a character (e.g. 'a')"]
                pub fn lv_textarea_add_char(ta: *mut lv_obj_t, c: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_add_char(ta as *mut lv_obj_t, c as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Insert a text to the current cursor position"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " - __`txt`__: a '\\0' terminated string to insert"]
        pub fn add_text(ta: *mut lv_obj_t, txt: &Strn) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Insert a text to the current cursor position"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " - __`txt`__: a '\\0' terminated string to insert"]
                pub fn lv_textarea_add_text(ta: *mut lv_obj_t,
                                            txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_add_text(ta as *mut lv_obj_t,
                                     txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Delete a the left character from the current cursor position"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        pub fn del_char(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete a the left character from the current cursor position"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                pub fn lv_textarea_del_char(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_del_char(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Delete the right character from the current cursor position"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        pub fn del_char_forward(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete the right character from the current cursor position"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                pub fn lv_textarea_del_char_forward(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_del_char_forward(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the text of a text area"]
        #[doc = " - __`ta`__: pointer to a text area"]
        #[doc = " - __`txt`__: pointer to the text"]
        pub fn set_text(ta: *mut lv_obj_t, txt: &Strn) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the text of a text area"]
                #[doc = " - __`ta`__: pointer to a text area"]
                #[doc = " - __`txt`__: pointer to the text"]
                pub fn lv_textarea_set_text(ta: *mut lv_obj_t,
                                            txt: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_text(ta as *mut lv_obj_t,
                                     txt.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the placeholder text of a text area"]
        #[doc = " - __`ta`__: pointer to a text area"]
        #[doc = " - __`txt`__: pointer to the text"]
        pub fn set_placeholder_text(ta: *mut lv_obj_t, txt: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the placeholder text of a text area"]
                #[doc = " - __`ta`__: pointer to a text area"]
                #[doc = " - __`txt`__: pointer to the text"]
                pub fn lv_textarea_set_placeholder_text(ta: *mut lv_obj_t,
                                                        txt:
                                                            *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_placeholder_text(ta as *mut lv_obj_t,
                                                 txt.as_ptr() as
                                                     *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the cursor position"]
        #[doc = " - __`obj`__: pointer to a text area object"]
        #[doc = " - __`pos`__: the new cursor position in character index"]
        #[doc = "             < 0 : index from the end of the text"]
        #[doc =
          "             LV_TEXTAREA_CURSOR_LAST: go after the last character"]
        pub fn set_cursor_pos(ta: *mut lv_obj_t, pos: i32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the cursor position"]
                #[doc = " - __`obj`__: pointer to a text area object"]
                #[doc =
                  " - __`pos`__: the new cursor position in character index"]
                #[doc = "             < 0 : index from the end of the text"]
                #[doc =
                  "             LV_TEXTAREA_CURSOR_LAST: go after the last character"]
                pub fn lv_textarea_set_cursor_pos(ta: *mut lv_obj_t,
                                                  pos: i32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_cursor_pos(ta as *mut lv_obj_t, pos as i32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Hide/Unhide the cursor."]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " - __`hide:`__: true: hide the cursor"]
        pub fn set_cursor_hidden(ta: *mut lv_obj_t, hide: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Hide/Unhide the cursor."]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " - __`hide:`__: true: hide the cursor"]
                pub fn lv_textarea_set_cursor_hidden(ta: *mut lv_obj_t,
                                                     hide: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_cursor_hidden(ta as *mut lv_obj_t,
                                              hide as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable/Disable the positioning of the the cursor by clicking the text on the text area."]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " - __`en`__: true: enable click positions; false: disable"]
        pub fn set_cursor_click_pos(ta: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable/Disable the positioning of the the cursor by clicking the text on the text area."]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " - __`en`__: true: enable click positions; false: disable"]
                pub fn lv_textarea_set_cursor_click_pos(ta: *mut lv_obj_t,
                                                        en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_cursor_click_pos(ta as *mut lv_obj_t,
                                                 en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable/Disable password mode"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " - __`en`__: true: enable, false: disable"]
        pub fn set_pwd_mode(ta: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable/Disable password mode"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " - __`en`__: true: enable, false: disable"]
                pub fn lv_textarea_set_pwd_mode(ta: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_pwd_mode(ta as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Configure the text area to one line or back to normal"]
        #[doc = " - __`ta`__: pointer to a Text area object"]
        #[doc = " - __`en`__: true: one line, false: normal"]
        pub fn set_one_line(ta: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Configure the text area to one line or back to normal"]
                #[doc = " - __`ta`__: pointer to a Text area object"]
                #[doc = " - __`en`__: true: one line, false: normal"]
                pub fn lv_textarea_set_one_line(ta: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_one_line(ta as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the alignment of the text area."]
        #[doc =
          " In one line mode the text can be scrolled only with `LV_LABEL_ALIGN_LEFT`."]
        #[doc =
          " This function should be called if the size of text area changes."]
        #[doc = " - __`ta`__: pointer to a text are object"]
        #[doc =
          " - __`align`__: the desired alignment from `lv_label_align_t`. (LV_LABEL_ALIGN_LEFT/CENTER/RIGHT)"]
        pub fn set_text_align(ta: *mut lv_obj_t, align: lv_label_align_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the alignment of the text area."]
                #[doc =
                  " In one line mode the text can be scrolled only with `LV_LABEL_ALIGN_LEFT`."]
                #[doc =
                  " This function should be called if the size of text area changes."]
                #[doc = " - __`ta`__: pointer to a text are object"]
                #[doc =
                  " - __`align`__: the desired alignment from `lv_label_align_t`. (LV_LABEL_ALIGN_LEFT/CENTER/RIGHT)"]
                pub fn lv_textarea_set_text_align(ta: *mut lv_obj_t,
                                                  align: lv_label_align_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_text_align(ta as *mut lv_obj_t,
                                           align as lv_label_align_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set a list of characters. Only these characters will be accepted by the text area"]
        #[doc = " - __`ta`__: pointer to  Text Area"]
        #[doc =
          " - __`list`__: list of characters. Only the pointer is saved. E.g. \"+-.,0123456789\""]
        pub fn set_accepted_chars(ta: *mut lv_obj_t, list: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set a list of characters. Only these characters will be accepted by the text area"]
                #[doc = " - __`ta`__: pointer to  Text Area"]
                #[doc =
                  " - __`list`__: list of characters. Only the pointer is saved. E.g. \"+-.,0123456789\""]
                pub fn lv_textarea_set_accepted_chars(ta: *mut lv_obj_t,
                                                      list:
                                                          *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            list.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_accepted_chars(ta as *mut lv_obj_t,
                                               list.as_ptr() as
                                                   *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set max length of a Text Area."]
        #[doc = " - __`ta`__: pointer to  Text Area"]
        #[doc =
          " - __`num`__: the maximal number of characters can be added (`lv_textarea_set_text` ignores it)"]
        pub fn set_max_length(ta: *mut lv_obj_t, num: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set max length of a Text Area."]
                #[doc = " - __`ta`__: pointer to  Text Area"]
                #[doc =
                  " - __`num`__: the maximal number of characters can be added (`lv_textarea_set_text` ignores it)"]
                pub fn lv_textarea_set_max_length(ta: *mut lv_obj_t,
                                                  num: u32);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_max_length(ta as *mut lv_obj_t, num as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " In `LV_EVENT_INSERT` the text which planned to be inserted can be replaced by an other text."]
        #[doc =
          " It can be used to add automatic formatting to the text area."]
        #[doc = " - __`ta`__: pointer to a text area."]
        #[doc =
          " - __`txt`__: pointer to a new string to insert. If `\"\"` no text will be added."]
        #[doc =
          "            The variable must be live after the `event_cb` exists. (Should be `global` or"]
        #[doc = " `static`)"]
        pub fn set_insert_replace(ta: *mut lv_obj_t, txt: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " In `LV_EVENT_INSERT` the text which planned to be inserted can be replaced by an other text."]
                #[doc =
                  " It can be used to add automatic formatting to the text area."]
                #[doc = " - __`ta`__: pointer to a text area."]
                #[doc =
                  " - __`txt`__: pointer to a new string to insert. If `\"\"` no text will be added."]
                #[doc =
                  "            The variable must be live after the `event_cb` exists. (Should be `global` or"]
                #[doc = " `static`)"]
                pub fn lv_textarea_set_insert_replace(ta: *mut lv_obj_t,
                                                      txt:
                                                          *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            txt.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_insert_replace(ta as *mut lv_obj_t,
                                               txt.as_ptr() as
                                                   *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the scroll bar mode of a text area"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc =
          " - __`sb_mode`__: the new mode from 'lv_scrollbar_mode_t' enum"]
        pub fn set_scrollbar_mode(ta: *mut lv_obj_t,
                                  mode: lv_scrollbar_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scroll bar mode of a text area"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " - __`sb_mode`__: the new mode from 'lv_scrollbar_mode_t' enum"]
                pub fn lv_textarea_set_scrollbar_mode(ta: *mut lv_obj_t,
                                                      mode:
                                                          lv_scrollbar_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_scrollbar_mode(ta as *mut lv_obj_t,
                                               mode as lv_scrollbar_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the scroll propagation feature. If enabled then the Text area will move its parent if"]
        #[doc = " there is no more space to scroll."]
        #[doc = " - __`ta`__: pointer to a Text area"]
        #[doc =
          " - __`en`__: true or false to enable/disable scroll propagation"]
        pub fn set_scroll_propagation(ta: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the scroll propagation feature. If enabled then the Text area will move its parent if"]
                #[doc = " there is no more space to scroll."]
                #[doc = " - __`ta`__: pointer to a Text area"]
                #[doc =
                  " - __`en`__: true or false to enable/disable scroll propagation"]
                pub fn lv_textarea_set_scroll_propagation(ta: *mut lv_obj_t,
                                                          en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_scroll_propagation(ta as *mut lv_obj_t,
                                                   en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
        #[doc = " - __`page`__: pointer to a Text Area"]
        #[doc = " - __`en`__: true or false to enable/disable end flash"]
        pub fn set_edge_flash(ta: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
                #[doc = " - __`page`__: pointer to a Text Area"]
                #[doc =
                  " - __`en`__: true or false to enable/disable end flash"]
                pub fn lv_textarea_set_edge_flash(ta: *mut lv_obj_t,
                                                  en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_edge_flash(ta as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Enable/disable selection mode."]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " - __`en`__: true or false to enable/disable selection mode"]
        pub fn set_text_sel(ta: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Enable/disable selection mode."]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " - __`en`__: true or false to enable/disable selection mode"]
                pub fn lv_textarea_set_text_sel(ta: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_text_sel(ta as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set how long show the password before changing it to '*'"]
        #[doc = " - __`ta`__: pointer to Text area"]
        #[doc =
          " - __`time`__: show time in milliseconds. 0: hide immediately."]
        pub fn set_pwd_show_time(ta: *mut lv_obj_t, time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set how long show the password before changing it to '*'"]
                #[doc = " - __`ta`__: pointer to Text area"]
                #[doc =
                  " - __`time`__: show time in milliseconds. 0: hide immediately."]
                pub fn lv_textarea_set_pwd_show_time(ta: *mut lv_obj_t,
                                                     time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_pwd_show_time(ta as *mut lv_obj_t,
                                              time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set cursor blink animation time"]
        #[doc = " - __`ta`__: pointer to Text area"]
        #[doc = " - __`time`__: blink period. 0: disable blinking"]
        pub fn set_cursor_blink_time(ta: *mut lv_obj_t, time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set cursor blink animation time"]
                #[doc = " - __`ta`__: pointer to Text area"]
                #[doc = " - __`time`__: blink period. 0: disable blinking"]
                pub fn lv_textarea_set_cursor_blink_time(ta: *mut lv_obj_t,
                                                         time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_set_cursor_blink_time(ta as *mut lv_obj_t,
                                                  time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the label of a text area"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: pointer to the label object"]
        pub fn get_label(ta: *const lv_obj_t) -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the label of a text area"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " Return: pointer to the label object"]
                pub fn lv_textarea_get_label(ta: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_label(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the current cursor position in character index"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: the cursor position"]
        pub fn get_cursor_pos(ta: *const lv_obj_t) -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the current cursor position in character index"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " Return: the cursor position"]
                pub fn lv_textarea_get_cursor_pos(ta: *const lv_obj_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_cursor_pos(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get whether the cursor is hidden or not"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: true: the cursor is hidden"]
        pub fn get_cursor_hidden(ta: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get whether the cursor is hidden or not"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc = " Return: true: the cursor is hidden"]
                pub fn lv_textarea_get_cursor_hidden(ta: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_cursor_hidden(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get whether the cursor click positioning is enabled or not."]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: true: enable click positions; false: disable"]
        pub fn get_cursor_click_pos(ta: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get whether the cursor click positioning is enabled or not."]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " Return: true: enable click positions; false: disable"]
                pub fn lv_textarea_get_cursor_click_pos(ta: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_cursor_click_pos(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the password mode attribute"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: true: password mode is enabled, false: disabled"]
        pub fn get_pwd_mode(ta: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the password mode attribute"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " Return: true: password mode is enabled, false: disabled"]
                pub fn lv_textarea_get_pwd_mode(ta: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_pwd_mode(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the one line configuration attribute"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc =
          " Return: true: one line configuration is enabled, false: disabled"]
        pub fn get_one_line(ta: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the one line configuration attribute"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " Return: true: one line configuration is enabled, false: disabled"]
                pub fn lv_textarea_get_one_line(ta: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_one_line(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get max length of a Text Area."]
        #[doc = " - __`ta`__: pointer to  Text Area"]
        #[doc = " Return: the maximal number of characters to be add"]
        pub fn get_max_length(ta: *mut lv_obj_t) -> MynewtResult<u32> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get max length of a Text Area."]
                #[doc = " - __`ta`__: pointer to  Text Area"]
                #[doc = " Return: the maximal number of characters to be add"]
                pub fn lv_textarea_get_max_length(ta: *mut lv_obj_t)
                -> u32;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_max_length(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll bar mode of a text area"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: scrollbar mode from 'lv_scrollbar_mode_t' enum"]
        pub fn get_scrollbar_mode(ta: *const lv_obj_t)
         -> MynewtResult<lv_scrollbar_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll bar mode of a text area"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " Return: scrollbar mode from 'lv_scrollbar_mode_t' enum"]
                pub fn lv_textarea_get_scrollbar_mode(ta: *const lv_obj_t)
                -> lv_scrollbar_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_scrollbar_mode(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll propagation property"]
        #[doc = " - __`ta`__: pointer to a Text area"]
        #[doc = " Return: true or false"]
        pub fn get_scroll_propagation(ta: *mut lv_obj_t)
         -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll propagation property"]
                #[doc = " - __`ta`__: pointer to a Text area"]
                #[doc = " Return: true or false"]
                pub fn lv_textarea_get_scroll_propagation(ta: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_scroll_propagation(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll propagation property"]
        #[doc = " - __`ta`__: pointer to a Text area"]
        #[doc = " Return: true or false"]
        pub fn get_edge_flash(ta: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll propagation property"]
                #[doc = " - __`ta`__: pointer to a Text area"]
                #[doc = " Return: true or false"]
                pub fn lv_textarea_get_edge_flash(ta: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_edge_flash(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Find whether text is selected or not."]
        #[doc = " - __`ta`__: Text area object"]
        #[doc = " Return: whether text is selected or not"]
        pub fn text_is_selected(ta: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Find whether text is selected or not."]
                #[doc = " - __`ta`__: Text area object"]
                #[doc = " Return: whether text is selected or not"]
                pub fn lv_textarea_text_is_selected(ta: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_text_is_selected(ta as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Find whether selection mode is enabled."]
        #[doc = " - __`ta`__: pointer to a text area object"]
        #[doc = " Return: true: selection mode is enabled, false: disabled"]
        pub fn get_text_sel_en(ta: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Find whether selection mode is enabled."]
                #[doc = " - __`ta`__: pointer to a text area object"]
                #[doc =
                  " Return: true: selection mode is enabled, false: disabled"]
                pub fn lv_textarea_get_text_sel_en(ta: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_text_sel_en(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set how long show the password before changing it to '*'"]
        #[doc = " - __`ta`__: pointer to Text area"]
        #[doc = " Return: show time in milliseconds. 0: hide immediately."]
        pub fn get_pwd_show_time(ta: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set how long show the password before changing it to '*'"]
                #[doc = " - __`ta`__: pointer to Text area"]
                #[doc =
                  " Return: show time in milliseconds. 0: hide immediately."]
                pub fn lv_textarea_get_pwd_show_time(ta: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_pwd_show_time(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set cursor blink animation time"]
        #[doc = " - __`ta`__: pointer to Text area"]
        #[doc = " Return: time blink period. 0: disable blinking"]
        pub fn get_cursor_blink_time(ta: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set cursor blink animation time"]
                #[doc = " - __`ta`__: pointer to Text area"]
                #[doc = " Return: time blink period. 0: disable blinking"]
                pub fn lv_textarea_get_cursor_blink_time(ta: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_textarea_get_cursor_blink_time(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Clear the selection on the text area."]
        #[doc = " - __`ta`__: Text area object"]
        pub fn clear_selection(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Clear the selection on the text area."]
                #[doc = " - __`ta`__: Text area object"]
                pub fn lv_textarea_clear_selection(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_clear_selection(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move the cursor one character right"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        pub fn cursor_right(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move the cursor one character right"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                pub fn lv_textarea_cursor_right(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_cursor_right(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move the cursor one character left"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        pub fn cursor_left(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move the cursor one character left"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                pub fn lv_textarea_cursor_left(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_cursor_left(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move the cursor one line down"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        pub fn cursor_down(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move the cursor one line down"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                pub fn lv_textarea_cursor_down(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_cursor_down(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Move the cursor one line up"]
        #[doc = " - __`ta`__: pointer to a text area object"]
        pub fn cursor_up(ta: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Move the cursor one line up"]
                #[doc = " - __`ta`__: pointer to a text area object"]
                pub fn lv_textarea_cursor_up(ta: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_textarea_cursor_up(ta as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
    /// Contains Rust bindings for LVGL Tile View Widget API `lv_tileview`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod tileview {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub const LV_TILEVIEW_DEF_ANIM_TIME: u32 = 300;
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents a point on the screen."]
        #[repr(C)]
        pub struct lv_point_t {
            pub x: lv_coord_t,
            pub y: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_point_t {
            #[inline]
            fn default() -> lv_point_t {
                lv_point_t{x: ::core::default::Default::default(),
                           y: ::core::default::Default::default(),}
            }
        }
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[doc = " Type of the animated value"]
        pub type lv_anim_value_t = lv_coord_t;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_fit_t = u8;
        #[repr(C, packed)]
        pub struct lv_cont_ext_t {
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_cont_ext_t {
            #[inline]
            fn default() -> lv_cont_ext_t {
                lv_cont_ext_t{_bitfield_1:
                                  ::core::default::Default::default(),}
            }
        }
        impl lv_cont_ext_t {
            #[inline]
            pub fn layout(&self) -> lv_layout_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_layout(&mut self, val: lv_layout_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 4u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_left(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_left(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_right(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_right(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_top(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_top(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn fit_bottom(&self) -> lv_fit_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 2u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(layout: lv_layout_t, fit_left: lv_fit_t,
                                  fit_right: lv_fit_t, fit_top: lv_fit_t,
                                  fit_bottom: lv_fit_t)
             -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 2usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 4u8,
                                            {
                                                let layout: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(layout)
                                                    };
                                                layout as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 2u8,
                                            {
                                                let fit_left: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_left)
                                                    };
                                                fit_left as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 2u8,
                                            {
                                                let fit_right: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_right)
                                                    };
                                                fit_right as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 2u8,
                                            {
                                                let fit_top: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_top)
                                                    };
                                                fit_top as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 2u8,
                                            {
                                                let fit_bottom: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(fit_bottom)
                                                    };
                                                fit_bottom as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_scrollbar_mode_t = u8;
        #[repr(C)]
        pub struct lv_page_ext_t {
            pub bg: lv_cont_ext_t,
            pub scrl: *mut lv_obj_t,
            pub scrlbar: lv_page_ext_t__bindgen_ty_1,
            pub edge_flash: lv_page_ext_t__bindgen_ty_2,
            pub anim_time: u16,
            pub scroll_prop_obj: *mut lv_obj_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_1 {
            pub style: lv_style_list_t,
            pub hor_area: lv_area_t,
            pub ver_area: lv_area_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_1 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_1 {
            #[inline]
            pub fn hor_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_hor_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ver_draw(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_ver_draw(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mode(&self) -> lv_scrollbar_mode_t {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 3u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(hor_draw: u8, ver_draw: u8,
                                  mode: lv_scrollbar_mode_t)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let hor_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(hor_draw)
                                                    };
                                                hor_draw as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let ver_draw: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(ver_draw)
                                                    };
                                                ver_draw as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 3u8,
                                            {
                                                let mode: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mode)
                                                    };
                                                mode as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[repr(C)]
        pub struct lv_page_ext_t__bindgen_ty_2 {
            pub state: lv_anim_value_t,
            pub style: lv_style_list_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_page_ext_t__bindgen_ty_2 {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t__bindgen_ty_2 {
            #[inline]
            pub fn enabled(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_enabled(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn top_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_top_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bottom_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_bottom_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn right_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_right_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn left_ip(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_left_ip(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(enabled: u8, top_ip: u8, bottom_ip: u8,
                                  right_ip: u8, left_ip: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let enabled: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(enabled)
                                                    };
                                                enabled as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let top_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(top_ip)
                                                    };
                                                top_ip as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let bottom_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(bottom_ip)
                                                    };
                                                bottom_ip as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let right_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(right_ip)
                                                    };
                                                right_ip as u64
                                            });
                __bindgen_bitfield_unit.set(4usize, 1u8,
                                            {
                                                let left_ip: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(left_ip)
                                                    };
                                                left_ip as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        impl Default for lv_page_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_page_ext_t {
            #[inline]
            pub fn scroll_prop(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_scroll_prop(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(scroll_prop: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let scroll_prop: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(scroll_prop)
                                                    };
                                                scroll_prop as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_tileview_ext_t {
            pub page: lv_page_ext_t,
            pub valid_pos: *const lv_point_t,
            pub valid_pos_cnt: u16,
            pub anim_time: u16,
            pub act_id: lv_point_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 7usize],
        }
        impl Default for lv_tileview_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_tileview_ext_t {
            #[inline]
            pub fn drag_top_en(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_top_en(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_bottom_en(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_bottom_en(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_left_en(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_left_en(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn drag_right_en(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_drag_right_en(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(drag_top_en: u8, drag_bottom_en: u8,
                                  drag_left_en: u8, drag_right_en: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let drag_top_en: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_top_en)
                                                    };
                                                drag_top_en as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let drag_bottom_en: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_bottom_en)
                                                    };
                                                drag_bottom_en as u64
                                            });
                __bindgen_bitfield_unit.set(2usize, 1u8,
                                            {
                                                let drag_left_en: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_left_en)
                                                    };
                                                drag_left_en as u64
                                            });
                __bindgen_bitfield_unit.set(3usize, 1u8,
                                            {
                                                let drag_right_en: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(drag_right_en)
                                                    };
                                                drag_right_en as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub const LV_TILEVIEW_PART_BG: _bindgen_ty_39 = 0;
        pub const LV_TILEVIEW_PART_SCROLLBAR: _bindgen_ty_39 = 1;
        pub const LV_TILEVIEW_PART_EDGE_FLASH: _bindgen_ty_39 = 2;
        pub const _LV_TILEVIEW_PART_VIRTUAL_LAST: _bindgen_ty_39 = 3;
        pub const _LV_TILEVIEW_PART_REAL_LAST: _bindgen_ty_39 = 65;
        pub type _bindgen_ty_39 = u32;
        #[doc = " Create a tileview objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new tileview"]
        #[doc =
          " - __`copy`__: pointer to a tileview object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created tileview"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a tileview objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new tileview"]
                #[doc =
                  " - __`copy`__: pointer to a tileview object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created tileview"]
                pub fn lv_tileview_create(par: *mut lv_obj_t,
                                          copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tileview_create(par as *mut lv_obj_t,
                                       copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Register an object on the tileview. The register object will able to slide the tileview"]
        #[doc = " - __`tileview`__: pointer to a Tileview object"]
        #[doc = " - __`element`__: pointer to an object"]
        pub fn add_element(tileview: *mut lv_obj_t, element: *mut lv_obj_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Register an object on the tileview. The register object will able to slide the tileview"]
                #[doc = " - __`tileview`__: pointer to a Tileview object"]
                #[doc = " - __`element`__: pointer to an object"]
                pub fn lv_tileview_add_element(tileview: *mut lv_obj_t,
                                               element: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tileview_add_element(tileview as *mut lv_obj_t,
                                        element as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set the valid position's indices. The scrolling will be possible only to these positions."]
        #[doc = " - __`tileview`__: pointer to a Tileview object"]
        #[doc =
          " - __`valid_pos`__: array width the indices. E.g. `lv_point_t p[] = {{0,0}, {1,0}, {1,1}`."]
        #[doc = "  Only the pointer is saved so can't be a local variable."]
        #[doc =
          " - __`valid_pos_cnt`__: number of elements in `valid_pos` array"]
        pub fn set_valid_positions(tileview: *mut lv_obj_t,
                                   valid_pos: *const lv_point_t,
                                   valid_pos_cnt: u16) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set the valid position's indices. The scrolling will be possible only to these positions."]
                #[doc = " - __`tileview`__: pointer to a Tileview object"]
                #[doc =
                  " - __`valid_pos`__: array width the indices. E.g. `lv_point_t p[] = {{0,0}, {1,0}, {1,1}`."]
                #[doc =
                  "  Only the pointer is saved so can't be a local variable."]
                #[doc =
                  " - __`valid_pos_cnt`__: number of elements in `valid_pos` array"]
                pub fn lv_tileview_set_valid_positions(tileview:
                                                           *mut lv_obj_t,
                                                       valid_pos:
                                                           *const lv_point_t,
                                                       valid_pos_cnt: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tileview_set_valid_positions(tileview as *mut lv_obj_t,
                                                valid_pos as
                                                    *const lv_point_t,
                                                valid_pos_cnt as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the tile to be shown"]
        #[doc = " - __`tileview`__: pointer to a tileview object"]
        #[doc = " - __`x`__: column id (0, 1, 2...)"]
        #[doc = " - __`y`__: line id (0, 1, 2...)"]
        #[doc =
          " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
        pub fn set_tile_act(tileview: *mut lv_obj_t, x: lv_coord_t,
                            y: lv_coord_t, anim: lv_anim_enable_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the tile to be shown"]
                #[doc = " - __`tileview`__: pointer to a tileview object"]
                #[doc = " - __`x`__: column id (0, 1, 2...)"]
                #[doc = " - __`y`__: line id (0, 1, 2...)"]
                #[doc =
                  " - __`anim`__: LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
                pub fn lv_tileview_set_tile_act(tileview: *mut lv_obj_t,
                                                x: lv_coord_t, y: lv_coord_t,
                                                anim: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tileview_set_tile_act(tileview as *mut lv_obj_t,
                                         x as lv_coord_t, y as lv_coord_t,
                                         anim as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
        #[doc = " - __`tileview`__: pointer to a Tileview"]
        #[doc = " - __`en`__: true or false to enable/disable end flash"]
        pub fn set_edge_flash(tileview: *mut lv_obj_t, en: bool)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
                #[doc = " - __`tileview`__: pointer to a Tileview"]
                #[doc =
                  " - __`en`__: true or false to enable/disable end flash"]
                pub fn lv_tileview_set_edge_flash(tileview: *mut lv_obj_t,
                                                  en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tileview_set_edge_flash(tileview as *mut lv_obj_t,
                                           en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the animation time for the Tile view"]
        #[doc = " - __`tileview`__: pointer to a page object"]
        #[doc = " - __`anim_time`__: animation time in milliseconds"]
        pub fn set_anim_time(tileview: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the animation time for the Tile view"]
                #[doc = " - __`tileview`__: pointer to a page object"]
                #[doc = " - __`anim_time`__: animation time in milliseconds"]
                pub fn lv_tileview_set_anim_time(tileview: *mut lv_obj_t,
                                                 anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tileview_set_anim_time(tileview as *mut lv_obj_t,
                                          anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the tile to be shown"]
        #[doc = " - __`tileview`__: pointer to a tileview object"]
        #[doc = " - __`x`__: column id (0, 1, 2...)"]
        #[doc = " - __`y`__: line id (0, 1, 2...)"]
        pub fn get_tile_act(tileview: *mut lv_obj_t, x: *mut lv_coord_t,
                            y: *mut lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the tile to be shown"]
                #[doc = " - __`tileview`__: pointer to a tileview object"]
                #[doc = " - __`x`__: column id (0, 1, 2...)"]
                #[doc = " - __`y`__: line id (0, 1, 2...)"]
                pub fn lv_tileview_get_tile_act(tileview: *mut lv_obj_t,
                                                x: *mut lv_coord_t,
                                                y: *mut lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_tileview_get_tile_act(tileview as *mut lv_obj_t,
                                         x as *mut lv_coord_t,
                                         y as *mut lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Get the scroll propagation property"]
        #[doc = " - __`tileview`__: pointer to a Tileview"]
        #[doc = " Return: true or false"]
        pub fn get_edge_flash(tileview: *mut lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll propagation property"]
                #[doc = " - __`tileview`__: pointer to a Tileview"]
                #[doc = " Return: true or false"]
                pub fn lv_tileview_get_edge_flash(tileview: *mut lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tileview_get_edge_flash(tileview as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the animation time for the Tile view"]
        #[doc = " - __`tileview`__: pointer to a page object"]
        #[doc = " Return: animation time in milliseconds"]
        pub fn get_anim_time(tileview: *mut lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the animation time for the Tile view"]
                #[doc = " - __`tileview`__: pointer to a page object"]
                #[doc = " Return: animation time in milliseconds"]
                pub fn lv_tileview_get_anim_time(tileview: *mut lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_tileview_get_anim_time(tileview as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
    }
    /// Contains Rust bindings for LVGL Window Widget API `lv_win`
    #[allow(non_camel_case_types)]
    #[allow(non_upper_case_globals)]
    #[allow(unused_imports)]
    pub mod win {
        use super::*;
        #[repr(C)]
        pub struct __BindgenBitfieldUnit<Storage, Align> where
                   Storage: AsRef<[u8]> + AsMut<[u8]> {
            storage: Storage,
            align: [Align; 0],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::marker::Copy, Align: ::core::marker::Copy>
         ::core::marker::Copy for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::clone::Clone, Align: ::core::clone::Clone>
         ::core::clone::Clone for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn clone(&self) -> __BindgenBitfieldUnit<Storage, Align> {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } =>
                    __BindgenBitfieldUnit{storage:
                                              ::core::clone::Clone::clone(&(*__self_0_0)),
                                          align:
                                              ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::fmt::Debug, Align: ::core::fmt::Debug>
         ::core::fmt::Debug for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("__BindgenBitfieldUnit");
                        let _ =
                            debug_trait_builder.field("storage",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("align",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::default::Default,
              Align: ::core::default::Default> ::core::default::Default for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn default() -> __BindgenBitfieldUnit<Storage, Align> {
                __BindgenBitfieldUnit{storage:
                                          ::core::default::Default::default(),
                                      align:
                                          ::core::default::Default::default(),}
            }
        }
        impl <Storage, Align> ::core::marker::StructuralEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Eq, Align: ::core::cmp::Eq>
         ::core::cmp::Eq for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Storage>;
                    let _: ::core::cmp::AssertParamIsEq<[Align; 0]>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::hash::Hash, Align: ::core::hash::Hash>
         ::core::hash::Hash for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    __BindgenBitfieldUnit {
                    storage: ref __self_0_0, align: ref __self_0_1 } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::Ord, Align: ::core::cmp::Ord>
         ::core::cmp::Ord for __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn cmp(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::cmp::Ordering {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                    &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal =>
                            match ::core::cmp::Ord::cmp(&(*__self_0_1),
                                                        &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal =>
                                ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl <Storage, Align> ::core::marker::StructuralPartialEq for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialEq, Align: ::core::cmp::PartialEq>
         ::core::cmp::PartialEq for __BindgenBitfieldUnit<Storage, Align>
         where Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            fn eq(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <Storage: ::core::cmp::PartialOrd,
              Align: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
         __BindgenBitfieldUnit<Storage, Align> where Storage: AsRef<[u8]> +
         AsMut<[u8]> {
            #[inline]
            fn partial_cmp(&self,
                           other: &__BindgenBitfieldUnit<Storage, Align>)
             -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                   &(*__self_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                       &(*__self_1_1))
                                {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                =>
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                                cmp => cmp,
                            },
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            == ::core::cmp::Ordering::Less,
                    },
                }
            }
            #[inline]
            fn le(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Greater))
                            != ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            == ::core::cmp::Ordering::Greater,
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &__BindgenBitfieldUnit<Storage, Align>)
             -> bool {
                match *other {
                    __BindgenBitfieldUnit {
                    storage: ref __self_1_0, align: ref __self_1_1 } =>
                    match *self {
                        __BindgenBitfieldUnit {
                        storage: ref __self_0_0, align: ref __self_0_1 } =>
                        ::core::cmp::Ordering::then_with(::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                                                                                                &(*__self_1_0)),
                                                                                           ::core::cmp::Ordering::Equal),
                                                         ||
                                                             ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0_1),
                                                                                                                                    &(*__self_1_1)),
                                                                                               ::core::cmp::Ordering::Less))
                            != ::core::cmp::Ordering::Less,
                    },
                }
            }
        }
        impl <Storage, Align> __BindgenBitfieldUnit<Storage, Align> where
         Storage: AsRef<[u8]> + AsMut<[u8]> {
            #[inline]
            pub fn new(storage: Storage) -> Self { Self{storage, align: [],} }
            #[inline]
            pub fn get_bit(&self, index: usize) -> bool {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = self.storage.as_ref()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                byte & mask == mask
            }
            #[inline]
            pub fn set_bit(&mut self, index: usize, val: bool) {
                if true {
                    if !(index / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                    };
                };
                let byte_index = index / 8;
                let byte = &mut self.storage.as_mut()[byte_index];
                let bit_index =
                    if false { 7 - (index % 8) } else { index % 8 };
                let mask = 1 << bit_index;
                if val { *byte |= mask; } else { *byte &= !mask; }
            }
            #[inline]
            pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                let mut val = 0;
                for i in 0..(bit_width as usize) {
                    if self.get_bit(i + bit_offset) {
                        let index =
                            if false {
                                bit_width as usize - 1 - i
                            } else { i };
                        val |= 1 << index;
                    }
                }
                val
            }
            #[inline]
            pub fn set(&mut self, bit_offset: usize, bit_width: u8,
                       val: u64) {
                if true {
                    if !(bit_width <= 64) {
                        ::core::panicking::panic("assertion failed: bit_width <= 64")
                    };
                };
                if true {
                    if !(bit_offset / 8 < self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                    };
                };
                if true {
                    if !((bit_offset + (bit_width as usize)) / 8 <=
                             self.storage.as_ref().len()) {
                        ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                    };
                };
                for i in 0..(bit_width as usize) {
                    let mask = 1 << i;
                    let val_bit_is_set = val & mask == mask;
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    self.set_bit(index + bit_offset, val_bit_is_set);
                }
            }
        }
        pub type lv_coord_t = i16;
        pub type lv_obj_user_data_t = *mut ::cty::c_void;
        pub type lv_res_t = u8;
        #[doc = " Represents an area of the screen."]
        #[repr(C)]
        pub struct lv_area_t {
            pub x1: lv_coord_t,
            pub y1: lv_coord_t,
            pub x2: lv_coord_t,
            pub y2: lv_coord_t,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for lv_area_t {
            #[inline]
            fn default() -> lv_area_t {
                lv_area_t{x1: ::core::default::Default::default(),
                          y1: ::core::default::Default::default(),
                          x2: ::core::default::Default::default(),
                          y2: ::core::default::Default::default(),}
            }
        }
        pub type lv_align_t = u8;
        pub type lv_anim_enable_t = u8;
        #[repr(C)]
        pub struct lv_style_list_t {
            pub style_list: *mut *mut lv_style_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
            pub __bindgen_padding_0: u32,
        }
        impl Default for lv_style_list_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_style_list_t {
            #[inline]
            pub fn style_cnt(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_style_cnt(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 6u8, val as u64)
                }
            }
            #[inline]
            pub fn has_local(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_local(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn has_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_has_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn skip_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_skip_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_trans(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_trans(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn valid_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_valid_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignore_cache(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_ignore_cache(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn radius_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_radius_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn opa_scale_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_opa_scale_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn clip_corner_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_clip_corner_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn transform_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_transform_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pad_all_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pad_all_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn blend_mode_all_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_blend_mode_all_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(17usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(18usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_opa_cover(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_opa_cover(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(19usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn bg_grad_dir_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_bg_grad_dir_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(20usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(21usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_side_full(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_side_full(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(22usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn border_post_off(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_border_post_off(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(23usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn outline_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_outline_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(24usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn pattern_img_null(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_pattern_img_null(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(25usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn shadow_width_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_shadow_width_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(26usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn value_txt_str(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_value_txt_str(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(27usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn img_recolor_opa_transp(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(28usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_space_zero(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_space_zero(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(29usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_decor_none(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_decor_none(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(30usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn text_font_normal(&self) -> u32 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8)
                                               as u32)
                }
            }
            #[inline]
            pub fn set_text_font_normal(&mut self, val: u32) {
                unsafe {
                    let val: u32 = ::core::mem::transmute(val);
                    self._bitfield_1.set(31usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(style_cnt: u32, has_local: u32,
                                  has_trans: u32, skip_trans: u32,
                                  ignore_trans: u32, valid_cache: u32,
                                  ignore_cache: u32, radius_zero: u32,
                                  opa_scale_cover: u32, clip_corner_off: u32,
                                  transform_all_zero: u32, pad_all_zero: u32,
                                  blend_mode_all_normal: u32,
                                  bg_opa_transp: u32, bg_opa_cover: u32,
                                  bg_grad_dir_none: u32,
                                  border_width_zero: u32,
                                  border_side_full: u32, border_post_off: u32,
                                  outline_width_zero: u32,
                                  pattern_img_null: u32,
                                  shadow_width_zero: u32, value_txt_str: u32,
                                  img_recolor_opa_transp: u32,
                                  text_space_zero: u32, text_decor_none: u32,
                                  text_font_normal: u32)
             -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 4usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 6u8,
                                            {
                                                let style_cnt: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(style_cnt)
                                                    };
                                                style_cnt as u64
                                            });
                __bindgen_bitfield_unit.set(6usize, 1u8,
                                            {
                                                let has_local: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_local)
                                                    };
                                                has_local as u64
                                            });
                __bindgen_bitfield_unit.set(7usize, 1u8,
                                            {
                                                let has_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(has_trans)
                                                    };
                                                has_trans as u64
                                            });
                __bindgen_bitfield_unit.set(8usize, 1u8,
                                            {
                                                let skip_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(skip_trans)
                                                    };
                                                skip_trans as u64
                                            });
                __bindgen_bitfield_unit.set(9usize, 1u8,
                                            {
                                                let ignore_trans: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_trans)
                                                    };
                                                ignore_trans as u64
                                            });
                __bindgen_bitfield_unit.set(10usize, 1u8,
                                            {
                                                let valid_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(valid_cache)
                                                    };
                                                valid_cache as u64
                                            });
                __bindgen_bitfield_unit.set(11usize, 1u8,
                                            {
                                                let ignore_cache: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(ignore_cache)
                                                    };
                                                ignore_cache as u64
                                            });
                __bindgen_bitfield_unit.set(12usize, 1u8,
                                            {
                                                let radius_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(radius_zero)
                                                    };
                                                radius_zero as u64
                                            });
                __bindgen_bitfield_unit.set(13usize, 1u8,
                                            {
                                                let opa_scale_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(opa_scale_cover)
                                                    };
                                                opa_scale_cover as u64
                                            });
                __bindgen_bitfield_unit.set(14usize, 1u8,
                                            {
                                                let clip_corner_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(clip_corner_off)
                                                    };
                                                clip_corner_off as u64
                                            });
                __bindgen_bitfield_unit.set(15usize, 1u8,
                                            {
                                                let transform_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(transform_all_zero)
                                                    };
                                                transform_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(16usize, 1u8,
                                            {
                                                let pad_all_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pad_all_zero)
                                                    };
                                                pad_all_zero as u64
                                            });
                __bindgen_bitfield_unit.set(17usize, 1u8,
                                            {
                                                let blend_mode_all_normal:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(blend_mode_all_normal)
                                                    };
                                                blend_mode_all_normal as u64
                                            });
                __bindgen_bitfield_unit.set(18usize, 1u8,
                                            {
                                                let bg_opa_transp: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_transp)
                                                    };
                                                bg_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(19usize, 1u8,
                                            {
                                                let bg_opa_cover: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_opa_cover)
                                                    };
                                                bg_opa_cover as u64
                                            });
                __bindgen_bitfield_unit.set(20usize, 1u8,
                                            {
                                                let bg_grad_dir_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(bg_grad_dir_none)
                                                    };
                                                bg_grad_dir_none as u64
                                            });
                __bindgen_bitfield_unit.set(21usize, 1u8,
                                            {
                                                let border_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_width_zero)
                                                    };
                                                border_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(22usize, 1u8,
                                            {
                                                let border_side_full: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_side_full)
                                                    };
                                                border_side_full as u64
                                            });
                __bindgen_bitfield_unit.set(23usize, 1u8,
                                            {
                                                let border_post_off: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(border_post_off)
                                                    };
                                                border_post_off as u64
                                            });
                __bindgen_bitfield_unit.set(24usize, 1u8,
                                            {
                                                let outline_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(outline_width_zero)
                                                    };
                                                outline_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(25usize, 1u8,
                                            {
                                                let pattern_img_null: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(pattern_img_null)
                                                    };
                                                pattern_img_null as u64
                                            });
                __bindgen_bitfield_unit.set(26usize, 1u8,
                                            {
                                                let shadow_width_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(shadow_width_zero)
                                                    };
                                                shadow_width_zero as u64
                                            });
                __bindgen_bitfield_unit.set(27usize, 1u8,
                                            {
                                                let value_txt_str: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(value_txt_str)
                                                    };
                                                value_txt_str as u64
                                            });
                __bindgen_bitfield_unit.set(28usize, 1u8,
                                            {
                                                let img_recolor_opa_transp:
                                                        u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(img_recolor_opa_transp)
                                                    };
                                                img_recolor_opa_transp as u64
                                            });
                __bindgen_bitfield_unit.set(29usize, 1u8,
                                            {
                                                let text_space_zero: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_space_zero)
                                                    };
                                                text_space_zero as u64
                                            });
                __bindgen_bitfield_unit.set(30usize, 1u8,
                                            {
                                                let text_decor_none: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_decor_none)
                                                    };
                                                text_decor_none as u64
                                            });
                __bindgen_bitfield_unit.set(31usize, 1u8,
                                            {
                                                let text_font_normal: u32 =
                                                    unsafe {
                                                        ::core::mem::transmute(text_font_normal)
                                                    };
                                                text_font_normal as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " Dummy type to make handling easier"]
        pub type lv_ll_node_t = u8;
        #[doc = " Description of a linked list"]
        #[repr(C)]
        pub struct lv_ll_t {
            pub n_size: u32,
            pub head: *mut lv_ll_node_t,
            pub tail: *mut lv_ll_node_t,
        }
        impl Default for lv_ll_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        pub type lv_drag_dir_t = u8;
        pub type lv_bidi_dir_t = u8;
        pub type lv_design_mode_t = u8;
        pub type lv_design_res_t = u8;
        #[doc =
          " The design callback is used to draw the object on the screen."]
        #[doc =
          " It accepts the object, a mask area, and the mode in which to draw the object."]
        pub type lv_design_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     clip_area:
                                                         *const lv_area_t,
                                                     mode: lv_design_mode_t)
                                    -> lv_design_res_t>;
        pub type lv_event_t = u8;
        #[doc = " @brief Event callback."]
        #[doc =
          " Events are used to notify the user of some action being taken on the object."]
        #[doc = " For details, see ::lv_event_t."]
        pub type lv_event_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     event: lv_event_t)>;
        pub type lv_signal_t = u8;
        pub type lv_signal_cb_t =
         ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t,
                                                     sign: lv_signal_t,
                                                     param:
                                                         *mut ::cty::c_void)
                                    -> lv_res_t>;
        #[repr(C)]
        pub struct lv_realign_t {
            pub base: *const _lv_obj_t,
            pub xofs: lv_coord_t,
            pub yofs: lv_coord_t,
            pub align: lv_align_t,
            pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: u16,
        }
        impl Default for lv_realign_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        impl lv_realign_t {
            #[inline]
            pub fn auto_realign(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_auto_realign(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mid_align(&self) -> u8 {
                unsafe {
                    ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8)
                                               as u8)
                }
            }
            #[inline]
            pub fn set_mid_align(&mut self, val: u8) {
                unsafe {
                    let val: u8 = ::core::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(auto_realign: u8, mid_align: u8)
             -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit:
                        __BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8,
                                            {
                                                let auto_realign: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(auto_realign)
                                                    };
                                                auto_realign as u64
                                            });
                __bindgen_bitfield_unit.set(1usize, 1u8,
                                            {
                                                let mid_align: u8 =
                                                    unsafe {
                                                        ::core::mem::transmute(mid_align)
                                                    };
                                                mid_align as u64
                                            });
                __bindgen_bitfield_unit
            }
        }
        pub type lv_state_t = u8;
        pub type lv_obj_t = _lv_obj_t;
        pub type lv_layout_t = u8;
        pub type lv_scrollbar_mode_t = u8;
        #[doc = "      TYPEDEFS"]
        #[repr(C)]
        pub struct lv_win_ext_t {
            pub page: *mut lv_obj_t,
            pub header: *mut lv_obj_t,
            pub title_txt: *mut ::cty::c_char,
            pub btn_w: lv_coord_t,
        }
        impl Default for lv_win_ext_t {
            fn default() -> Self { unsafe { ::core::mem::zeroed() } }
        }
        #[doc = "< Window object background style."]
        pub const LV_WIN_PART_BG: _bindgen_ty_45 = 0;
        pub const _LV_WIN_PART_VIRTUAL_LAST: _bindgen_ty_45 = 1;
        #[doc = "< Window titlebar background style."]
        pub const LV_WIN_PART_HEADER: _bindgen_ty_45 = 64;
        #[doc = "< Window content style."]
        pub const LV_WIN_PART_CONTENT_SCROLLABLE: _bindgen_ty_45 = 65;
        #[doc = "< Window scrollbar style."]
        pub const LV_WIN_PART_SCROLLBAR: _bindgen_ty_45 = 66;
        pub const _LV_WIN_PART_REAL_LAST: _bindgen_ty_45 = 67;
        #[doc = " Window parts."]
        pub type _bindgen_ty_45 = u32;
        #[doc = " Create a window objects"]
        #[doc =
          " - __`par`__: pointer to an object, it will be the parent of the new window"]
        #[doc =
          " - __`copy`__: pointer to a window object, if not NULL then the new object will be copied from it"]
        #[doc = " Return: pointer to the created window"]
        pub fn create(par: *mut lv_obj_t, copy: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Create a window objects"]
                #[doc =
                  " - __`par`__: pointer to an object, it will be the parent of the new window"]
                #[doc =
                  " - __`copy`__: pointer to a window object, if not NULL then the new object will be copied from it"]
                #[doc = " Return: pointer to the created window"]
                pub fn lv_win_create(par: *mut lv_obj_t,
                                     copy: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_win_create(par as *mut lv_obj_t,
                                  copy as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Delete all children of the scrl object, without deleting scrl child."]
        #[doc = " - __`win`__: pointer to an object"]
        pub fn clean(win: *mut lv_obj_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Delete all children of the scrl object, without deleting scrl child."]
                #[doc = " - __`win`__: pointer to an object"]
                pub fn lv_win_clean(win: *mut lv_obj_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_clean(win as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Add control button on the right side of the window header"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`img_src`__: an image source ('lv_img_t' variable, path to file or a symbol)"]
        #[doc = " Return: pointer to the created button object"]
        pub fn add_btn_right(win: *mut lv_obj_t,
                             img_src: *const ::cty::c_void)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Add control button on the right side of the window header"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`img_src`__: an image source ('lv_img_t' variable, path to file or a symbol)"]
                #[doc = " Return: pointer to the created button object"]
                pub fn lv_win_add_btn_right(win: *mut lv_obj_t,
                                            img_src: *const ::cty::c_void)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_win_add_btn_right(win as *mut lv_obj_t,
                                         img_src as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Add control button on the left side of the window header"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`img_src`__: an image source ('lv_img_t' variable, path to file or a symbol)"]
        #[doc = " Return: pointer to the created button object"]
        pub fn add_btn_left(win: *mut lv_obj_t, img_src: *const ::cty::c_void)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Add control button on the left side of the window header"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`img_src`__: an image source ('lv_img_t' variable, path to file or a symbol)"]
                #[doc = " Return: pointer to the created button object"]
                pub fn lv_win_add_btn_left(win: *mut lv_obj_t,
                                           img_src: *const ::cty::c_void)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_win_add_btn_left(win as *mut lv_obj_t,
                                        img_src as *const ::cty::c_void);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Can be assigned to a window control button to close the window"]
        #[doc =
          " - __`btn`__: pointer to the control button on the widows header"]
        #[doc = " - __`evet`__: the event type"]
        pub fn close_event_cb(btn: *mut lv_obj_t, event: lv_event_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Can be assigned to a window control button to close the window"]
                #[doc =
                  " - __`btn`__: pointer to the control button on the widows header"]
                #[doc = " - __`evet`__: the event type"]
                pub fn lv_win_close_event_cb(btn: *mut lv_obj_t,
                                             event: lv_event_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_close_event_cb(btn as *mut lv_obj_t,
                                      event as lv_event_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the title of a window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " - __`title`__: string of the new title"]
        pub fn set_title(win: *mut lv_obj_t, title: &Strn)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the title of a window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " - __`title`__: string of the new title"]
                pub fn lv_win_set_title(win: *mut lv_obj_t,
                                        title: *const ::cty::c_char);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            title.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_title(win as *mut lv_obj_t,
                                 title.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the control button size of a window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: control button size"]
        pub fn set_header_height(win: *mut lv_obj_t, size: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the control button size of a window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " Return: control button size"]
                pub fn lv_win_set_header_height(win: *mut lv_obj_t,
                                                size: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_header_height(win as *mut lv_obj_t,
                                         size as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the width of the control buttons on the header"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`width`__: width of the control button. 0: to make them square automatically."]
        pub fn set_btn_width(win: *mut lv_obj_t, width: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the width of the control buttons on the header"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`width`__: width of the control button. 0: to make them square automatically."]
                pub fn lv_win_set_btn_width(win: *mut lv_obj_t,
                                            width: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_btn_width(win as *mut lv_obj_t,
                                     width as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the size of the content area."]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " - __`w`__: width"]
        #[doc =
          " - __`h`__: height (the window will be higher with the height of the header)"]
        pub fn set_content_size(win: *mut lv_obj_t, w: lv_coord_t,
                                h: lv_coord_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the size of the content area."]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " - __`w`__: width"]
                #[doc =
                  " - __`h`__: height (the window will be higher with the height of the header)"]
                pub fn lv_win_set_content_size(win: *mut lv_obj_t,
                                               w: lv_coord_t, h: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_content_size(win as *mut lv_obj_t, w as lv_coord_t,
                                        h as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the layout of the window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " - __`layout`__: the layout from 'lv_layout_t'"]
        pub fn set_layout(win: *mut lv_obj_t, layout: lv_layout_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the layout of the window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " - __`layout`__: the layout from 'lv_layout_t'"]
                pub fn lv_win_set_layout(win: *mut lv_obj_t,
                                         layout: lv_layout_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_layout(win as *mut lv_obj_t,
                                  layout as lv_layout_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set the scroll bar mode of a window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`sb_mode`__: the new scroll bar mode from  'lv_scrollbar_mode_t'"]
        pub fn set_scrollbar_mode(win: *mut lv_obj_t,
                                  sb_mode: lv_scrollbar_mode_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the scroll bar mode of a window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`sb_mode`__: the new scroll bar mode from  'lv_scrollbar_mode_t'"]
                pub fn lv_win_set_scrollbar_mode(win: *mut lv_obj_t,
                                                 sb_mode:
                                                     lv_scrollbar_mode_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_scrollbar_mode(win as *mut lv_obj_t,
                                          sb_mode as lv_scrollbar_mode_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Set focus animation duration on `lv_win_focus()`"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " - __`anim_time`__: duration of animation [ms]"]
        pub fn set_anim_time(win: *mut lv_obj_t, anim_time: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set focus animation duration on `lv_win_focus()`"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " - __`anim_time`__: duration of animation [ms]"]
                pub fn lv_win_set_anim_time(win: *mut lv_obj_t,
                                            anim_time: u16);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_anim_time(win as *mut lv_obj_t, anim_time as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Set drag status of a window. If set to 'true' window can be dragged like on a PC."]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " - __`en`__: whether dragging is enabled"]
        pub fn set_drag(win: *mut lv_obj_t, en: bool) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Set drag status of a window. If set to 'true' window can be dragged like on a PC."]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " - __`en`__: whether dragging is enabled"]
                pub fn lv_win_set_drag(win: *mut lv_obj_t, en: bool);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_set_drag(win as *mut lv_obj_t, en as bool);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
          " Get the content holder object of window (`lv_page`) to allow additional customization"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: the Page object where the window's content is"]
        pub fn get_content(win: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the content holder object of window (`lv_page`) to allow additional customization"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " Return: the Page object where the window's content is"]
                pub fn lv_win_get_content(win: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_win_get_content(win as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the header height"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: header height"]
        pub fn get_header_height(win: *const lv_obj_t)
         -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the header height"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " Return: header height"]
                pub fn lv_win_get_header_height(win: *const lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_win_get_header_height(win as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the width of the control buttons on the header"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: width of the control button. 0: square."]
        pub fn get_btn_width(win: *mut lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the width of the control buttons on the header"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " Return: width of the control button. 0: square."]
                pub fn lv_win_get_btn_width(win: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_win_get_btn_width(win as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get the pointer of a widow from one of  its control button."]
        #[doc =
          " It is useful in the action of the control buttons where only button is known."]
        #[doc = " - __`ctrl_btn`__: pointer to a control button of a window"]
        #[doc = " Return: pointer to the window of 'ctrl_btn'"]
        pub fn get_from_btn(ctrl_btn: *const lv_obj_t)
         -> MynewtResult<*mut lv_obj_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get the pointer of a widow from one of  its control button."]
                #[doc =
                  " It is useful in the action of the control buttons where only button is known."]
                #[doc =
                  " - __`ctrl_btn`__: pointer to a control button of a window"]
                #[doc = " Return: pointer to the window of 'ctrl_btn'"]
                pub fn lv_win_get_from_btn(ctrl_btn: *const lv_obj_t)
                -> *mut lv_obj_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_win_get_from_btn(ctrl_btn as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the layout of a window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: the layout of the window (from 'lv_layout_t')"]
        pub fn get_layout(win: *mut lv_obj_t) -> MynewtResult<lv_layout_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the layout of a window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " Return: the layout of the window (from 'lv_layout_t')"]
                pub fn lv_win_get_layout(win: *mut lv_obj_t)
                -> lv_layout_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_win_get_layout(win as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get the scroll bar mode of a window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " Return: the scroll bar mode of the window (from 'lv_sb_mode_t')"]
        pub fn get_sb_mode(win: *mut lv_obj_t)
         -> MynewtResult<lv_scrollbar_mode_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get the scroll bar mode of a window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " Return: the scroll bar mode of the window (from 'lv_sb_mode_t')"]
                pub fn lv_win_get_sb_mode(win: *mut lv_obj_t)
                -> lv_scrollbar_mode_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_win_get_sb_mode(win as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Get focus animation duration"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: duration of animation [ms]"]
        pub fn get_anim_time(win: *const lv_obj_t) -> MynewtResult<u16> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Get focus animation duration"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " Return: duration of animation [ms]"]
                pub fn lv_win_get_anim_time(win: *const lv_obj_t)
                -> u16;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    lv_win_get_anim_time(win as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get width of the content area (page scrollable) of the window"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: the width of the content area"]
        pub fn get_width(win: *mut lv_obj_t) -> MynewtResult<lv_coord_t> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get width of the content area (page scrollable) of the window"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " Return: the width of the content area"]
                pub fn lv_win_get_width(win: *mut lv_obj_t)
                -> lv_coord_t;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_win_get_width(win as *mut lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Get drag status of a window. If set to 'true' window can be dragged like on a PC."]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc = " Return: whether window is draggable"]
        pub fn get_drag(win: *const lv_obj_t) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Get drag status of a window. If set to 'true' window can be dragged like on a PC."]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc = " Return: whether window is draggable"]
                pub fn lv_win_get_drag(win: *const lv_obj_t)
                -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = lv_win_get_drag(win as *const lv_obj_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc =
          " Focus on an object. It ensures that the object will be visible in the window."]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`obj`__: pointer to an object to focus (must be in the window)"]
        #[doc =
          " - __`anim_en`__: LV_ANIM_ON focus with an animation; LV_ANIM_OFF focus without animation"]
        pub fn focus(win: *mut lv_obj_t, obj: *mut lv_obj_t,
                     anim_en: lv_anim_enable_t) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                  " Focus on an object. It ensures that the object will be visible in the window."]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`obj`__: pointer to an object to focus (must be in the window)"]
                #[doc =
                  " - __`anim_en`__: LV_ANIM_ON focus with an animation; LV_ANIM_OFF focus without animation"]
                pub fn lv_win_focus(win: *mut lv_obj_t, obj: *mut lv_obj_t,
                                    anim_en: lv_anim_enable_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_focus(win as *mut lv_obj_t, obj as *mut lv_obj_t,
                             anim_en as lv_anim_enable_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Scroll the window horizontally"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`dist`__: the distance to scroll (< 0: scroll right; > 0 scroll left)"]
        pub fn scroll_hor(win: *mut lv_obj_t, dist: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Scroll the window horizontally"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`dist`__: the distance to scroll (< 0: scroll right; > 0 scroll left)"]
                pub fn lv_win_scroll_hor(win: *mut lv_obj_t,
                                         dist: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_scroll_hor(win as *mut lv_obj_t, dist as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc = " Scroll the window vertically"]
        #[doc = " - __`win`__: pointer to a window object"]
        #[doc =
          " - __`dist`__: the distance to scroll (< 0: scroll down; > 0 scroll up)"]
        pub fn scroll_ver(win: *mut lv_obj_t, dist: lv_coord_t)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Scroll the window vertically"]
                #[doc = " - __`win`__: pointer to a window object"]
                #[doc =
                  " - __`dist`__: the distance to scroll (< 0: scroll down; > 0 scroll up)"]
                pub fn lv_win_scroll_ver(win: *mut lv_obj_t,
                                         dist: lv_coord_t);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                lv_win_scroll_ver(win as *mut lv_obj_t, dist as lv_coord_t);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
    }
}
#[macro_use]
pub mod util {
    //! LVGL Utility Macros for Rust
    #[macro_use]
    pub mod macros {
        //!  Mynewt Macros for Rust. Note that macros defined locally should be called with `$crate::`, like `$crate::parse`.
        //!  This works with Rust compiler versions 1.30 and later.  See https://doc.rust-lang.org/stable/edition-guide/rust-2018/macros/macro-changes.html
        //!  To see the expanded macros: `cargo rustc -- -Z unstable-options --pretty expanded`
        ///  Return a const struct that has all fields set to 0. Used for initialising static mutable structs like `os_task`.
        ///  `fill_zero!(os::os_task)` expands to
        ///  ```
        /// unsafe { 
        ///	::core::mem::transmute::
        ///	<
        ///	  [
        ///		u8; 
        ///		::core::mem::size_of::<os::os_task>()
        ///	  ], 
        ///	  os::os_task
        ///	>
        ///	(
        ///	  [
        ///		0; 
        ///		::core::mem::size_of::<os::os_task>()
        ///	  ]
        ///	) 
        /// }
        ///  ```
        #[macro_export]
        macro_rules! fill_zero {
            ($ ($ tts : tt) *) =>
            {
                unsafe
                {
                    :: core :: mem :: transmute :: <
                    [u8 ; :: core :: mem :: size_of :: < $ ($ tts) * > ()], $
                    ($ tts) * >
                    ([0 ; :: core :: mem :: size_of :: < $ ($ tts) * > ()])
                }
            } ;
        }
        ///  Macro that takes an identifier and returns a `[u8]` containing the identifier, terminated by 0.
        ///  Used to convert an identifier to a C null-terminated string.
        #[macro_export]
        macro_rules! stringify_null {
            ($ key : ident) => { concat ! (stringify ! ($ key), "\0") } ;
        }
        ///  Macro to dump all tokens received as a literal string, e.g.
        ///  `d!(a b c)` returns `"a b c"`
        #[macro_export]
        macro_rules! d {
            ($ ($ token : tt) *) => { stringify ! ($ ($ token) *) } ;
        }
        ///  Macro to display the token being parsed and the remaining tokens
        #[macro_export]
        macro_rules! nx {
            (($ ($ current : tt) *), ($ ($ next : tt) *), ($ ($ rest : tt) *))
            =>
            {
                concat !
                (" >> ", stringify ! ($ ($ current) *), " >> ", stringify !
                 ($ ($ next) *), " >> ", stringify ! ($ ($ rest) *)) ;
            } ;
        }
    }
}
///  Pointer to mutable LVGL object `lv_obj_t`
pub type Ptr = *mut core::obj::lv_obj_t;
