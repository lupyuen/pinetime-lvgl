/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type lv_coord_t = i16;
pub type lv_anim_user_data_t = *mut ::cty::c_void;
pub type lv_img_decoder_user_data_t = *mut ::cty::c_void;
pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
pub type lv_indev_drv_user_data_t = *mut ::cty::c_void;
pub type lv_font_user_data_t = *mut ::cty::c_void;
pub type lv_obj_user_data_t = *mut ::cty::c_void;
pub type lv_log_level_t = i8;
pub type lv_res_t = u8;
pub type lv_uintptr_t = usize;
#[doc = " Heap information structure."]
#[repr(C)]
#[derive(Default)]
pub struct lv_mem_monitor_t {
    #[doc = "< Total heap size"]
    pub total_size: u32,
    pub free_cnt: u32,
    #[doc = "< Size of available memory"]
    pub free_size: u32,
    pub free_biggest_size: u32,
    pub used_cnt: u32,
    #[doc = "< Max size of Heap memory used"]
    pub max_used: u32,
    #[doc = "< Percentage used"]
    pub used_pct: u8,
    #[doc = "< Amount of fragmentation"]
    pub frag_pct: u8,
}
#[repr(C)]
pub struct lv_mem_buf_t {
    pub p: *mut ::cty::c_void,
    pub size: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl Default for lv_mem_buf_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_mem_buf_t {
    #[inline]
    pub fn used(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_used(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(used: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let used: u8 = unsafe { ::core::mem::transmute(used) };
            used as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_mem_buf_arr_t = [lv_mem_buf_t; 16usize];
#[doc = " Represents a point on the screen."]
#[repr(C)]
#[derive(Default)]
pub struct lv_point_t {
    pub x: lv_coord_t,
    pub y: lv_coord_t,
}
#[doc = " Represents an area of the screen."]
#[repr(C)]
#[derive(Default)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
pub const LV_ALIGN_CENTER: lv_align_t = 0;
pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
#[doc = " Alignments"]
pub type _bindgen_ty_3 = u32;
pub type lv_align_t = u8;
#[doc = " Describes the properties of a glyph."]
#[repr(C)]
#[derive(Default)]
pub struct lv_font_glyph_dsc_t {
    #[doc = "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
    pub adv_w: u16,
    #[doc = "< Width of the glyph's bounding box"]
    pub box_w: u16,
    #[doc = "< Height of the glyph's bounding box"]
    pub box_h: u16,
    #[doc = "< x offset of the bounding box"]
    pub ofs_x: i16,
    #[doc = "< y offset of the bounding box"]
    pub ofs_y: i16,
    #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
    pub bpp: u8,
}
pub type lv_font_subpx_t = u8;
#[doc = " Describe the properties of a font"]
#[repr(C)]
pub struct _lv_font_struct {
    #[doc = " Get a glyph's  descriptor from a font"]
    pub get_glyph_dsc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const _lv_font_struct,
            arg2: *mut lv_font_glyph_dsc_t,
            letter: u32,
            letter_next: u32,
        ) -> bool,
    >,
    #[doc = " Get a glyph's bitmap from a font"]
    pub get_glyph_bitmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const _lv_font_struct, arg2: u32) -> *const u8,
    >,
    #[doc = "< The real line height where any text fits"]
    pub line_height: lv_coord_t,
    #[doc = "< Base line measured from the top of the line_height"]
    pub base_line: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Distance between the top of the underline and base line (< 0 means below the base line)"]
    pub underline_position: i8,
    #[doc = "< Thickness of the underline"]
    pub underline_thickness: i8,
    #[doc = "< Store implementation specific or run_time data or caching here"]
    pub dsc: *mut ::cty::c_void,
    #[doc = "< Custom user data for font."]
    pub user_data: lv_font_user_data_t,
}
impl Default for _lv_font_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_font_struct {
    #[inline]
    pub fn subpx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_subpx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subpx: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let subpx: u8 = unsafe { ::core::mem::transmute(subpx) };
            subpx as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_font_t = _lv_font_struct;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Default)]
pub struct lv_sqrt_res_t {
    pub i: u16,
    pub f: u16,
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct lv_color1_t {
    pub ch: __BindgenUnionField<lv_color1_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
pub union lv_color1_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    _bindgen_union_align: u8,
}
impl Default for lv_color1_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_color1_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color1_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_color8_t {
    pub ch: __BindgenUnionField<lv_color8_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[repr(C, packed)]
#[derive(Default)]
pub struct lv_color8_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl lv_color8_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color8_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_color16_t {
    pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn green_h(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_h(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green_l(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        green_h: u16,
        red: u16,
        blue: u16,
        green_l: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let green_h: u16 = unsafe { ::core::mem::transmute(green_h) };
            green_h as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let green_l: u16 = unsafe { ::core::mem::transmute(green_l) };
            green_l as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color16_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_color32_t {
    pub ch: __BindgenUnionField<lv_color32_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_color32_t__bindgen_ty_1 {
    pub blue: u8,
    pub green: u8,
    pub red: u8,
    pub alpha: u8,
}
impl Default for lv_color32_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_color_int_t = u16;
pub type lv_color_t = lv_color16_t;
#[repr(C)]
#[derive(Default)]
pub struct lv_color_hsv_t {
    pub h: u16,
    pub s: u8,
    pub v: u8,
}
#[doc = "! @cond Doxygen_Suppress"]
pub type lv_opa_t = u8;
pub type lv_anim_enable_t = u8;
#[doc = " Type of the animated value"]
pub type lv_anim_value_t = lv_coord_t;
#[doc = " Get the current value during an animation"]
pub type lv_anim_path_cb_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const _lv_anim_path_t, arg2: *const _lv_anim_t) -> lv_anim_value_t,
>;
#[repr(C)]
pub struct _lv_anim_path_t {
    pub cb: lv_anim_path_cb_t,
    pub user_data: *mut ::cty::c_void,
}
impl Default for _lv_anim_path_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_anim_path_t = _lv_anim_path_t;
#[doc = " Generic prototype of \"animator\" functions."]
#[doc = " First parameter is the variable to animate."]
#[doc = " Second parameter is the value to set."]
#[doc = " Compatible with `lv_xxx_set_yyy(obj, value)` functions"]
#[doc = " The `x` in `_xcb_t` means its not a fully generic prototype because"]
#[doc = " it doesn't receive `lv_anim_t *` as its first argument"]
pub type lv_anim_exec_xcb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void, arg2: lv_anim_value_t)>;
#[doc = " Same as `lv_anim_exec_xcb_t` but receives `lv_anim_t *` as the first parameter."]
#[doc = " It's more consistent but less convenient. Might be used by binding generator functions."]
pub type lv_anim_custom_exec_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t, arg2: lv_anim_value_t)>;
#[doc = " Callback to call when the animation is ready"]
pub type lv_anim_ready_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
#[doc = " Callback to call when the animation really stars (considering `delay`)"]
pub type lv_anim_start_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
#[doc = " Describes an animation"]
#[repr(C)]
pub struct _lv_anim_t {
    #[doc = "<Variable to animate"]
    pub var: *mut ::cty::c_void,
    #[doc = "< Function to execute to animate"]
    pub exec_cb: lv_anim_exec_xcb_t,
    #[doc = "< Call it when the animation is starts (considering `delay`)"]
    pub start_cb: lv_anim_start_cb_t,
    #[doc = "< Call it when the animation is ready"]
    pub ready_cb: lv_anim_ready_cb_t,
    #[doc = "< Describe the path (curve) of animations"]
    pub path: lv_anim_path_t,
    #[doc = "< Start value"]
    pub start: i32,
    #[doc = "< Current value"]
    pub current: i32,
    #[doc = "< End value"]
    pub end: i32,
    #[doc = "< Animation time in ms"]
    pub time: i32,
    #[doc = "< Current time in animation. Set to negative to make delay."]
    pub act_time: i32,
    #[doc = "< Wait before play back"]
    pub playback_delay: u32,
    #[doc = "< Duration of playback animation"]
    pub playback_time: u32,
    #[doc = "< Wait before repeat"]
    pub repeat_delay: u32,
    #[doc = "< Repeat count for the animation"]
    pub repeat_cnt: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Custom user data"]
    pub user_data: lv_anim_user_data_t,
    pub time_orig: u32,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for _lv_anim_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_anim_t {
    #[inline]
    pub fn early_apply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_apply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(early_apply: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_apply: u8 = unsafe { ::core::mem::transmute(early_apply) };
            early_apply as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn playback_now(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_playback_now(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_run(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_run(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        playback_now: u8,
        has_run: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let playback_now: u8 = unsafe { ::core::mem::transmute(playback_now) };
            playback_now as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_run: u32 = unsafe { ::core::mem::transmute(has_run) };
            has_run as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_anim_t = _lv_anim_t;
pub type lv_draw_mask_res_t = u8;
pub type lv_draw_mask_type_t = u8;
#[doc = " A common callback type for every mask type."]
#[doc = " Used internally by the library."]
pub type lv_draw_mask_xcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        mask_buf: *mut lv_opa_t,
        abs_x: lv_coord_t,
        abs_y: lv_coord_t,
        len: lv_coord_t,
        p: *mut ::cty::c_void,
    ) -> lv_draw_mask_res_t,
>;
pub type lv_draw_mask_line_side_t = u8;
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_common_dsc_t {
    pub cb: lv_draw_mask_xcb_t,
    pub type_: lv_draw_mask_type_t,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_line_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_line_param_t__bindgen_ty_1,
    pub origo: lv_point_t,
    pub xy_steep: i32,
    pub yx_steep: i32,
    pub steep: i32,
    pub spx: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_line_param_t__bindgen_ty_1 {
    pub p1: lv_point_t,
    pub p2: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_draw_mask_line_param_t__bindgen_ty_1 {
    #[inline]
    pub fn side(&self) -> lv_draw_mask_line_side_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_side(&mut self, val: lv_draw_mask_line_side_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        side: lv_draw_mask_line_side_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let side: u8 = unsafe { ::core::mem::transmute(side) };
            side as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_draw_mask_line_param_t {
    #[inline]
    pub fn flat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(flat: u8, inv: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flat: u8 = unsafe { ::core::mem::transmute(flat) };
            flat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inv: u8 = unsafe { ::core::mem::transmute(inv) };
            inv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_angle_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_angle_param_t__bindgen_ty_1,
    pub start_line: lv_draw_mask_line_param_t,
    pub end_line: lv_draw_mask_line_param_t,
    pub delta_deg: u16,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_angle_param_t__bindgen_ty_1 {
    pub vertex_p: lv_point_t,
    pub start_angle: lv_coord_t,
    pub end_angle: lv_coord_t,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_radius_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_radius_param_t__bindgen_ty_1,
    pub y_prev: i32,
    pub y_prev_x: lv_sqrt_res_t,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_radius_param_t__bindgen_ty_1 {
    pub rect: lv_area_t,
    pub radius: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_draw_mask_radius_param_t__bindgen_ty_1 {
    #[inline]
    pub fn outer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_outer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(outer: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outer: u8 = unsafe { ::core::mem::transmute(outer) };
            outer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_fade_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_fade_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_mask_fade_param_t__bindgen_ty_1 {
    pub coords: lv_area_t,
    pub y_top: lv_coord_t,
    pub y_bottom: lv_coord_t,
    pub opa_top: lv_opa_t,
    pub opa_bottom: lv_opa_t,
}
#[repr(C)]
pub struct _lv_draw_mask_map_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: _lv_draw_mask_map_param_t__bindgen_ty_1,
}
#[repr(C)]
pub struct _lv_draw_mask_map_param_t__bindgen_ty_1 {
    pub coords: lv_area_t,
    pub map: *const lv_opa_t,
}
impl Default for _lv_draw_mask_map_param_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _lv_draw_mask_map_param_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_draw_mask_map_param_t = _lv_draw_mask_map_param_t;
pub type lv_blend_mode_t = u8;
pub type lv_border_side_t = u8;
pub type lv_grad_dir_t = u8;
pub type lv_text_decor_t = u8;
pub type lv_style_attr_t = u8;
pub type lv_style_property_t = u16;
pub type lv_style_state_t = u16;
#[repr(C)]
pub struct lv_style_t {
    pub map: *mut u8,
}
impl Default for lv_style_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_style_int_t = i16;
#[repr(C)]
pub struct lv_style_list_t {
    pub style_list: *mut *mut lv_style_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_padding_0: u32,
}
impl Default for lv_style_list_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_style_list_t {
    #[inline]
    pub fn style_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_style_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn has_local(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_local(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_cache(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_cache(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_cache(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_cache(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn radius_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_radius_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opa_scale_cover(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_opa_scale_cover(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clip_corner_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clip_corner_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blend_mode_all_normal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blend_mode_all_normal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_opa_transp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_opa_transp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_opa_cover(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_opa_cover(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_grad_dir_none(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_grad_dir_none(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_side_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_side_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_post_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_post_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outline_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outline_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pattern_img_null(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pattern_img_null(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shadow_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shadow_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn value_txt_str(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_value_txt_str(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn img_recolor_opa_transp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_space_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_space_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_decor_none(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_decor_none(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_font_normal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_font_normal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style_cnt: u32,
        has_local: u32,
        has_trans: u32,
        skip_trans: u32,
        ignore_trans: u32,
        valid_cache: u32,
        ignore_cache: u32,
        radius_zero: u32,
        opa_scale_cover: u32,
        clip_corner_off: u32,
        transform_all_zero: u32,
        pad_all_zero: u32,
        blend_mode_all_normal: u32,
        bg_opa_transp: u32,
        bg_opa_cover: u32,
        bg_grad_dir_none: u32,
        border_width_zero: u32,
        border_side_full: u32,
        border_post_off: u32,
        outline_width_zero: u32,
        pattern_img_null: u32,
        shadow_width_zero: u32,
        value_txt_str: u32,
        img_recolor_opa_transp: u32,
        text_space_zero: u32,
        text_decor_none: u32,
        text_font_normal: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style_cnt: u32 = unsafe { ::core::mem::transmute(style_cnt) };
            style_cnt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_local: u32 = unsafe { ::core::mem::transmute(has_local) };
            has_local as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_trans: u32 = unsafe { ::core::mem::transmute(has_trans) };
            has_trans as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skip_trans: u32 = unsafe { ::core::mem::transmute(skip_trans) };
            skip_trans as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ignore_trans: u32 = unsafe { ::core::mem::transmute(ignore_trans) };
            ignore_trans as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let valid_cache: u32 = unsafe { ::core::mem::transmute(valid_cache) };
            valid_cache as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ignore_cache: u32 = unsafe { ::core::mem::transmute(ignore_cache) };
            ignore_cache as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let radius_zero: u32 = unsafe { ::core::mem::transmute(radius_zero) };
            radius_zero as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let opa_scale_cover: u32 = unsafe { ::core::mem::transmute(opa_scale_cover) };
            opa_scale_cover as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let clip_corner_off: u32 = unsafe { ::core::mem::transmute(clip_corner_off) };
            clip_corner_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let transform_all_zero: u32 = unsafe { ::core::mem::transmute(transform_all_zero) };
            transform_all_zero as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pad_all_zero: u32 = unsafe { ::core::mem::transmute(pad_all_zero) };
            pad_all_zero as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let blend_mode_all_normal: u32 =
                unsafe { ::core::mem::transmute(blend_mode_all_normal) };
            blend_mode_all_normal as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let bg_opa_transp: u32 = unsafe { ::core::mem::transmute(bg_opa_transp) };
            bg_opa_transp as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let bg_opa_cover: u32 = unsafe { ::core::mem::transmute(bg_opa_cover) };
            bg_opa_cover as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let bg_grad_dir_none: u32 = unsafe { ::core::mem::transmute(bg_grad_dir_none) };
            bg_grad_dir_none as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let border_width_zero: u32 = unsafe { ::core::mem::transmute(border_width_zero) };
            border_width_zero as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let border_side_full: u32 = unsafe { ::core::mem::transmute(border_side_full) };
            border_side_full as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let border_post_off: u32 = unsafe { ::core::mem::transmute(border_post_off) };
            border_post_off as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let outline_width_zero: u32 = unsafe { ::core::mem::transmute(outline_width_zero) };
            outline_width_zero as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let pattern_img_null: u32 = unsafe { ::core::mem::transmute(pattern_img_null) };
            pattern_img_null as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let shadow_width_zero: u32 = unsafe { ::core::mem::transmute(shadow_width_zero) };
            shadow_width_zero as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let value_txt_str: u32 = unsafe { ::core::mem::transmute(value_txt_str) };
            value_txt_str as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let img_recolor_opa_transp: u32 =
                unsafe { ::core::mem::transmute(img_recolor_opa_transp) };
            img_recolor_opa_transp as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let text_space_zero: u32 = unsafe { ::core::mem::transmute(text_space_zero) };
            text_space_zero as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let text_decor_none: u32 = unsafe { ::core::mem::transmute(text_decor_none) };
            text_decor_none as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let text_font_normal: u32 = unsafe { ::core::mem::transmute(text_font_normal) };
            text_font_normal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Dummy type to make handling easier"]
pub type lv_ll_node_t = u8;
#[doc = " Description of a linked list"]
#[repr(C)]
pub struct lv_ll_t {
    pub n_size: u32,
    pub head: *mut lv_ll_node_t,
    pub tail: *mut lv_ll_node_t,
}
impl Default for lv_ll_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Tasks execute this type type of functions."]
pub type lv_task_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
pub type lv_task_prio_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _lv_task_t {
    #[doc = "< How often the task should run"]
    pub period: u32,
    #[doc = "< Last time the task ran"]
    pub last_run: u32,
    #[doc = "< Task function"]
    pub task_cb: lv_task_cb_t,
    #[doc = "< Custom user data"]
    pub user_data: *mut ::cty::c_void,
    #[doc = "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
    pub repeat_count: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for _lv_task_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_task_t {
    #[inline]
    pub fn prio(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prio: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let prio: u8 = unsafe { ::core::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_task_t = _lv_task_t;
#[doc = " Structure for holding display buffer information."]
#[repr(C)]
pub struct lv_disp_buf_t {
    #[doc = "< First display buffer."]
    pub buf1: *mut ::cty::c_void,
    #[doc = "< Second display buffer."]
    pub buf2: *mut ::cty::c_void,
    pub buf_act: *mut ::cty::c_void,
    pub size: u32,
    pub area: lv_area_t,
    pub flushing: ::cty::c_int,
    pub flushing_last: ::cty::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for lv_disp_buf_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_disp_buf_t {
    #[inline]
    pub fn last_area(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_area(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_part(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_part(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        last_area: u32,
        last_part: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_area: u32 = unsafe { ::core::mem::transmute(last_area) };
            last_area as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let last_part: u32 = unsafe { ::core::mem::transmute(last_part) };
            last_part as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Display Driver structure to be registered by HAL"]
#[repr(C)]
pub struct _disp_drv_t {
    #[doc = "< Horizontal resolution."]
    pub hor_res: lv_coord_t,
    #[doc = "< Vertical resolution."]
    pub ver_res: lv_coord_t,
    #[doc = " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
    #[doc = " LVGL will use this buffer(s) to draw the screens contents"]
    pub buffer: *mut lv_disp_buf_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
    #[doc = " called when finished"]
    pub flush_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            area: *const lv_area_t,
            color_p: *mut lv_color_t,
        ),
    >,
    #[doc = " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
    #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
    pub rounder_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, area: *mut lv_area_t),
    >,
    #[doc = " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
    #[doc = " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
    #[doc = " __Note:__ Much slower then drawing with supported color formats."]
    pub set_px_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            buf: *mut u8,
            buf_w: lv_coord_t,
            x: lv_coord_t,
            y: lv_coord_t,
            color: lv_color_t,
            opa: lv_opa_t,
        ),
    >,
    #[doc = " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
    #[doc = " number of flushed pixels"]
    pub monitor_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, time: u32, px: u32),
    >,
    #[doc = " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
    #[doc = " For example flushing or GPU"]
    #[doc = " User can execute very simple tasks here or yield the task"]
    pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
    pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " OPTIONAL: called to wait while the gpu is working"]
    pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " On CHROMA_KEYED images this color will be transparent."]
    #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
    pub color_chroma_key: lv_color_t,
    #[doc = "< Custom display driver user data"]
    pub user_data: lv_disp_drv_user_data_t,
}
impl Default for _disp_drv_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _disp_drv_t {
    #[inline]
    pub fn antialiasing(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_antialiasing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rotated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_dpi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        antialiasing: u32,
        rotated: u32,
        dpi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialiasing: u32 = unsafe { ::core::mem::transmute(antialiasing) };
            antialiasing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rotated: u32 = unsafe { ::core::mem::transmute(rotated) };
            rotated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let dpi: u32 = unsafe { ::core::mem::transmute(dpi) };
            dpi as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_drv_t = _disp_drv_t;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _disp_t {
    pub driver: lv_disp_drv_t,
    pub refr_task: *mut lv_task_t,
    #[doc = " Screens of the display"]
    pub scr_ll: lv_ll_t,
    #[doc = "< Currently active screen on this display"]
    pub act_scr: *mut _lv_obj_t,
    #[doc = "< Previous screen. Used during screen animations"]
    pub prev_scr: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_top"]
    pub top_layer: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_sys"]
    pub sys_layer: *mut _lv_obj_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Default display color when screens are transparent"]
    pub bg_color: lv_color_t,
    #[doc = "< An image source to display as wallpaper"]
    pub bg_img: *const ::cty::c_void,
    #[doc = "<Opacity of the background color or wallpaper"]
    pub bg_opa: lv_opa_t,
    #[doc = " Invalidated (marked to redraw) areas"]
    pub inv_areas: [lv_area_t; 32usize],
    pub inv_area_joined: [u8; 32usize],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = "< Last time there was activity on this display"]
    pub last_activity_time: u32,
}
impl Default for _disp_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _disp_t {
    #[inline]
    pub fn del_prev(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_del_prev(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(del_prev: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let del_prev: u8 = unsafe { ::core::mem::transmute(del_prev) };
            del_prev as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inv_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_inv_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inv_p: u32) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let inv_p: u32 = unsafe { ::core::mem::transmute(inv_p) };
            inv_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_t = _disp_t;
pub const lv_disp_size_t_LV_DISP_SIZE_SMALL: lv_disp_size_t = 0;
pub const lv_disp_size_t_LV_DISP_SIZE_MEDIUM: lv_disp_size_t = 1;
pub const lv_disp_size_t_LV_DISP_SIZE_LARGE: lv_disp_size_t = 2;
pub const lv_disp_size_t_LV_DISP_SIZE_EXTRA_LARGE: lv_disp_size_t = 3;
pub type lv_disp_size_t = u32;
pub type lv_indev_type_t = u8;
pub type lv_indev_state_t = u8;
pub type lv_drag_dir_t = u8;
pub type lv_gesture_dir_t = u8;
#[doc = " Data structure passed to an input driver to fill"]
#[repr(C)]
#[derive(Default)]
pub struct lv_indev_data_t {
    #[doc = "< For LV_INDEV_TYPE_POINTER the currently pressed point"]
    pub point: lv_point_t,
    #[doc = "< For LV_INDEV_TYPE_KEYPAD the currently pressed key"]
    pub key: u32,
    #[doc = "< For LV_INDEV_TYPE_BUTTON the currently pressed button"]
    pub btn_id: u32,
    #[doc = "< For LV_INDEV_TYPE_ENCODER number of steps since the previous read"]
    pub enc_diff: i16,
    #[doc = "< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR"]
    pub state: lv_indev_state_t,
}
#[doc = " Initialized by the user and registered by 'lv_indev_add()'"]
#[repr(C)]
pub struct _lv_indev_drv_t {
    pub type_: lv_indev_type_t,
    pub read_cb: ::core::option::Option<
        unsafe extern "C" fn(indev_drv: *mut _lv_indev_drv_t, data: *mut lv_indev_data_t) -> bool,
    >,
    #[doc = " Called when an action happened on the input device."]
    #[doc = " The second parameter is the event from `lv_event_t`"]
    pub feedback_cb:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_indev_drv_t, arg2: u8)>,
    pub user_data: lv_indev_drv_user_data_t,
    pub disp: *mut _disp_t,
    pub read_task: *mut lv_task_t,
    pub drag_limit: u8,
    pub drag_throw: u8,
    pub gesture_min_velocity: u8,
    pub gesture_limit: u8,
    pub long_press_time: u16,
    pub long_press_rep_time: u16,
}
impl Default for _lv_indev_drv_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_indev_drv_t = _lv_indev_drv_t;
#[doc = " Run time data of input devices"]
#[doc = " Internally used by the library, you should not need to touch it."]
#[repr(C)]
pub struct _lv_indev_proc_t {
    #[doc = "< Current state of the input device."]
    pub state: lv_indev_state_t,
    pub types: _lv_indev_proc_t__bindgen_ty_1,
    #[doc = "< Pressed time stamp"]
    pub pr_timestamp: u32,
    #[doc = "< Long press repeat time stamp"]
    pub longpr_rep_timestamp: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
pub struct _lv_indev_proc_t__bindgen_ty_1 {
    pub pointer: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1>,
    pub keypad: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Current point of input device."]
    pub act_point: lv_point_t,
    #[doc = "< Last point of input device."]
    pub last_point: lv_point_t,
    #[doc = "< Difference between `act_point` and `last_point`."]
    pub vect: lv_point_t,
    pub drag_sum: lv_point_t,
    pub drag_throw_vect: lv_point_t,
    pub act_obj: *mut _lv_obj_t,
    pub last_obj: *mut _lv_obj_t,
    pub last_pressed: *mut _lv_obj_t,
    pub gesture_dir: lv_gesture_dir_t,
    pub gesture_sum: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl Default for _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn drag_limit_out(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_limit_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_in_prog(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_in_prog(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gesture_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gesture_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drag_limit_out: u8,
        drag_in_prog: u8,
        drag_dir: lv_drag_dir_t,
        gesture_sent: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drag_limit_out: u8 = unsafe { ::core::mem::transmute(drag_limit_out) };
            drag_limit_out as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag_in_prog: u8 = unsafe { ::core::mem::transmute(drag_in_prog) };
            drag_in_prog as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gesture_sent: u8 = unsafe { ::core::mem::transmute(gesture_sent) };
            gesture_sent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
    pub last_state: lv_indev_state_t,
    pub last_key: u32,
}
impl Default for _lv_indev_proc_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _lv_indev_proc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_indev_proc_t {
    #[inline]
    pub fn long_pr_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_long_pr_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_query(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset_query(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_until_release(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_until_release(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_pr_sent: u8,
        reset_query: u8,
        disabled: u8,
        wait_until_release: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let long_pr_sent: u8 = unsafe { ::core::mem::transmute(long_pr_sent) };
            long_pr_sent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reset_query: u8 = unsafe { ::core::mem::transmute(reset_query) };
            reset_query as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u8 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_until_release: u8 = unsafe { ::core::mem::transmute(wait_until_release) };
            wait_until_release as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_indev_proc_t = _lv_indev_proc_t;
#[repr(C)]
pub struct _lv_group_t {
    _unused: [u8; 0],
}
#[doc = " The main input device descriptor with driver, runtime data ('proc') and some additional"]
#[doc = " information"]
#[repr(C)]
pub struct _lv_indev_t {
    pub driver: lv_indev_drv_t,
    pub proc_: lv_indev_proc_t,
    #[doc = "< Cursor for LV_INPUT_TYPE_POINTER"]
    pub cursor: *mut _lv_obj_t,
    #[doc = "< Keypad destination group"]
    pub group: *mut _lv_group_t,
    #[doc = "< Array points assigned to the button ()screen will be pressed"]
    #[doc = "here by the buttons"]
    pub btn_points: *const lv_point_t,
}
impl Default for _lv_indev_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_indev_t = _lv_indev_t;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct lv_draw_rect_dsc_t {
    pub radius: lv_style_int_t,
    pub bg_color: lv_color_t,
    pub bg_grad_color: lv_color_t,
    pub bg_grad_dir: lv_grad_dir_t,
    pub bg_main_color_stop: lv_style_int_t,
    pub bg_grad_color_stop: lv_style_int_t,
    pub bg_opa: lv_opa_t,
    pub bg_blend_mode: lv_blend_mode_t,
    pub border_color: lv_color_t,
    pub border_width: lv_style_int_t,
    pub border_side: lv_style_int_t,
    pub border_opa: lv_opa_t,
    pub border_blend_mode: lv_blend_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub outline_color: lv_color_t,
    pub outline_width: lv_style_int_t,
    pub outline_pad: lv_style_int_t,
    pub outline_opa: lv_opa_t,
    pub outline_blend_mode: lv_blend_mode_t,
    pub shadow_color: lv_color_t,
    pub shadow_width: lv_style_int_t,
    pub shadow_ofs_x: lv_style_int_t,
    pub shadow_ofs_y: lv_style_int_t,
    pub shadow_spread: lv_style_int_t,
    pub shadow_opa: lv_opa_t,
    pub shadow_blend_mode: lv_blend_mode_t,
    pub pattern_image: *const ::cty::c_void,
    pub pattern_font: *const lv_font_t,
    pub pattern_recolor: lv_color_t,
    pub pattern_opa: lv_opa_t,
    pub pattern_recolor_opa: lv_opa_t,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub pattern_blend_mode: lv_blend_mode_t,
    pub value_str: *const ::cty::c_char,
    pub value_font: *const lv_font_t,
    pub value_opa: lv_opa_t,
    pub value_color: lv_color_t,
    pub value_ofs_x: lv_style_int_t,
    pub value_ofs_y: lv_style_int_t,
    pub value_letter_space: lv_style_int_t,
    pub value_line_space: lv_style_int_t,
    pub value_align: lv_align_t,
    pub value_blend_mode: lv_blend_mode_t,
}
impl Default for lv_draw_rect_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_draw_rect_dsc_t {
    #[inline]
    pub fn border_post(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_border_post(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(border_post: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let border_post: u8 = unsafe { ::core::mem::transmute(border_post) };
            border_post as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pattern_repeat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pattern_repeat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(pattern_repeat: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pattern_repeat: u8 = unsafe { ::core::mem::transmute(pattern_repeat) };
            pattern_repeat as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_bidi_dir_t = u8;
pub type lv_txt_flag_t = u8;
pub type lv_txt_cmd_state_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct lv_draw_label_dsc_t {
    pub color: lv_color_t,
    pub sel_color: lv_color_t,
    pub font: *const lv_font_t,
    pub opa: lv_opa_t,
    pub line_space: lv_style_int_t,
    pub letter_space: lv_style_int_t,
    pub sel_start: u32,
    pub sel_end: u32,
    pub ofs_x: lv_coord_t,
    pub ofs_y: lv_coord_t,
    pub bidi_dir: lv_bidi_dir_t,
    pub flag: lv_txt_flag_t,
    pub decor: lv_text_decor_t,
    pub blend_mode: lv_blend_mode_t,
}
impl Default for lv_draw_label_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Store some info to speed up drawing of very large texts"]
#[doc = " It takes a lot of time to get the first visible character because"]
#[doc = " all the previous characters needs to be checked to calculate the positions."]
#[doc = " This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line."]
#[doc = " Therefore the calculations can start from here."]
#[repr(C)]
#[derive(Default)]
pub struct lv_draw_label_hint_t {
    #[doc = " Index of the line at `y` coordinate"]
    pub line_start: i32,
    #[doc = " Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates"]
    pub y: i32,
    #[doc = " The 'y1' coordinate of the label when the hint was saved."]
    #[doc = " Used to invalidate the hint if the label has moved too much."]
    pub coord_y: i32,
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct lv_draw_line_dsc_t {
    pub color: lv_color_t,
    pub width: lv_style_int_t,
    pub dash_width: lv_style_int_t,
    pub dash_gap: lv_style_int_t,
    pub opa: lv_opa_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl Default for lv_draw_line_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_draw_line_dsc_t {
    #[inline]
    pub fn blend_mode(&self) -> lv_blend_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blend_mode(&mut self, val: lv_blend_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn round_start(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_round_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn round_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_round_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn raw_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_raw_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        blend_mode: lv_blend_mode_t,
        round_start: u8,
        round_end: u8,
        raw_end: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blend_mode: u8 = unsafe { ::core::mem::transmute(blend_mode) };
            blend_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let round_start: u8 = unsafe { ::core::mem::transmute(round_start) };
            round_start as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let round_end: u8 = unsafe { ::core::mem::transmute(round_end) };
            round_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let raw_end: u8 = unsafe { ::core::mem::transmute(raw_end) };
            raw_end as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_img_cf_t = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Default)]
pub struct lv_img_header_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl lv_img_header_t {
    #[inline]
    pub fn cf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn always_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_always_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn w(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_w(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cf: u32,
        always_zero: u32,
        reserved: u32,
        w: u32,
        h: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let cf: u32 = unsafe { ::core::mem::transmute(cf) };
            cf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let always_zero: u32 = unsafe { ::core::mem::transmute(always_zero) };
            always_zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(10usize, 11u8, {
            let w: u32 = unsafe { ::core::mem::transmute(w) };
            w as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let h: u32 = unsafe { ::core::mem::transmute(h) };
            h as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Image header it is compatible with"]
#[doc = " the result from image converter utility"]
#[repr(C)]
pub struct lv_img_dsc_t {
    pub header: lv_img_header_t,
    pub data_size: u32,
    pub data: *const u8,
}
impl Default for lv_img_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_img_transform_dsc_t {
    pub cfg: lv_img_transform_dsc_t__bindgen_ty_1,
    pub res: lv_img_transform_dsc_t__bindgen_ty_2,
    pub tmp: lv_img_transform_dsc_t__bindgen_ty_3,
}
#[repr(C)]
pub struct lv_img_transform_dsc_t__bindgen_ty_1 {
    pub src: *const ::cty::c_void,
    pub src_w: lv_coord_t,
    pub src_h: lv_coord_t,
    pub pivot_x: lv_coord_t,
    pub pivot_y: lv_coord_t,
    pub angle: i16,
    pub zoom: u16,
    pub color: lv_color_t,
    pub cf: lv_img_cf_t,
    pub antialias: bool,
}
impl Default for lv_img_transform_dsc_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_img_transform_dsc_t__bindgen_ty_2 {
    pub color: lv_color_t,
    pub opa: lv_opa_t,
}
impl Default for lv_img_transform_dsc_t__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_img_transform_dsc_t__bindgen_ty_3 {
    pub img_dsc: lv_img_dsc_t,
    pub pivot_x_256: i32,
    pub pivot_y_256: i32,
    pub sinma: i32,
    pub cosma: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub zoom_inv: u32,
    pub xs: lv_coord_t,
    pub ys: lv_coord_t,
    pub xs_int: lv_coord_t,
    pub ys_int: lv_coord_t,
    pub pxi: u32,
    pub px_size: u8,
}
impl Default for lv_img_transform_dsc_t__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_img_transform_dsc_t__bindgen_ty_3 {
    #[inline]
    pub fn chroma_keyed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_chroma_keyed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_alpha(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_alpha(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn native_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_native_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_keyed: u8,
        has_alpha: u8,
        native_color: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let chroma_keyed: u8 = unsafe { ::core::mem::transmute(chroma_keyed) };
            chroma_keyed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_alpha: u8 = unsafe { ::core::mem::transmute(has_alpha) };
            has_alpha as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let native_color: u8 = unsafe { ::core::mem::transmute(native_color) };
            native_color as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_img_transform_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_img_src_t = u8;
#[doc = " Get info from an image and store in the `header`"]
#[doc = " - __`src`__: the image source. Can be a pointer to a C array or a file name (Use"]
#[doc = " `lv_img_src_get_type` to determine the type)"]
#[doc = " - __`header`__: store the info here"]
#[doc = " Return: LV_RES_OK: info written correctly; LV_RES_INV: failed"]
pub type lv_img_decoder_info_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut _lv_img_decoder,
        src: *const ::cty::c_void,
        header: *mut lv_img_header_t,
    ) -> lv_res_t,
>;
#[doc = " Open an image for decoding. Prepare it as it is required to read it later"]
#[doc = " - __`decoder`__: pointer to the decoder the function associated with"]
#[doc = " - __`dsc`__: pointer to decoder descriptor. `src`, `style` are already initialized in it."]
pub type lv_img_decoder_open_f_t = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut _lv_img_decoder, dsc: *mut _lv_img_decoder_dsc) -> lv_res_t,
>;
#[doc = " Decode `len` pixels starting from the given `x`, `y` coordinates and store them in `buf`."]
#[doc = " Required only if the \"open\" function can't return with the whole decoded pixel array."]
#[doc = " - __`decoder`__: pointer to the decoder the function associated with"]
#[doc = " - __`dsc`__: pointer to decoder descriptor"]
#[doc = " - __`x`__: start x coordinate"]
#[doc = " - __`y`__: start y coordinate"]
#[doc = " - __`len`__: number of pixels to decode"]
#[doc = " - __`buf`__: a buffer to store the decoded pixels"]
#[doc = " Return: LV_RES_OK: ok; LV_RES_INV: failed"]
pub type lv_img_decoder_read_line_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut _lv_img_decoder,
        dsc: *mut _lv_img_decoder_dsc,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t,
>;
#[doc = " Close the pending decoding. Free resources etc."]
#[doc = " - __`decoder`__: pointer to the decoder the function associated with"]
#[doc = " - __`dsc`__: pointer to decoder descriptor"]
pub type lv_img_decoder_close_f_t = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut _lv_img_decoder, dsc: *mut _lv_img_decoder_dsc),
>;
#[repr(C)]
pub struct _lv_img_decoder {
    pub info_cb: lv_img_decoder_info_f_t,
    pub open_cb: lv_img_decoder_open_f_t,
    pub read_line_cb: lv_img_decoder_read_line_f_t,
    pub close_cb: lv_img_decoder_close_f_t,
    pub user_data: lv_img_decoder_user_data_t,
}
impl Default for _lv_img_decoder {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_img_decoder_t = _lv_img_decoder;
#[doc = "Describe an image decoding session. Stores data about the decoding"]
#[repr(C)]
pub struct _lv_img_decoder_dsc {
    #[doc = "The decoder which was able to open the image source"]
    pub decoder: *mut lv_img_decoder_t,
    #[doc = "The image source. A file path like \"S:my_img.png\" or pointer to an `lv_img_dsc_t` variable"]
    pub src: *const ::cty::c_void,
    #[doc = "Style to draw the image."]
    pub color: lv_color_t,
    #[doc = "Type of the source: file or variable. Can be set in `open` function if required"]
    pub src_type: lv_img_src_t,
    #[doc = "Info about the opened image: color format, size, etc. MUST be set in `open` function"]
    pub header: lv_img_header_t,
    #[doc = " Pointer to a buffer where the image's data (pixels) are stored in a decoded, plain format."]
    #[doc = "  MUST be set in `open` function"]
    pub img_data: *const u8,
    #[doc = " How much time did it take to open the image. [ms]"]
    #[doc = "  If not set `lv_img_cache` will measure and set the time to open"]
    pub time_to_open: u32,
    #[doc = "A text to display instead of the image when the image can't be opened."]
    #[doc = " Can be set in `open` function or set NULL."]
    pub error_msg: *const ::cty::c_char,
    #[doc = "Store any custom data here is required"]
    pub user_data: *mut ::cty::c_void,
}
impl Default for _lv_img_decoder_dsc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_img_decoder_dsc_t = _lv_img_decoder_dsc;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct lv_draw_img_dsc_t {
    pub opa: lv_opa_t,
    pub angle: u16,
    pub pivot: lv_point_t,
    pub zoom: u16,
    pub recolor_opa: lv_opa_t,
    pub recolor: lv_color_t,
    pub blend_mode: lv_blend_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl Default for lv_draw_img_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_draw_img_dsc_t {
    #[inline]
    pub fn antialias(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antialias(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(antialias: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialias: u8 = unsafe { ::core::mem::transmute(antialias) };
            antialias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Draw the main portion of the object"]
pub const LV_DESIGN_DRAW_MAIN: lv_design_res_t = 0;
#[doc = "< Draw extras on the object"]
pub const LV_DESIGN_DRAW_POST: lv_design_res_t = 1;
#[doc = "< Check if the object fully covers the 'mask_p' area"]
pub const LV_DESIGN_COVER_CHK: lv_design_res_t = 2;
#[doc = " Design modes"]
pub type _bindgen_ty_25 = u32;
pub type lv_design_mode_t = u8;
#[doc = "< Draw ready"]
pub const LV_DESIGN_RES_OK: lv_design_res_t = 0;
#[doc = "< Returned on `LV_DESIGN_COVER_CHK` if the areas is fully covered"]
pub const LV_DESIGN_RES_COVER: lv_design_res_t = 1;
#[doc = "< Returned on `LV_DESIGN_COVER_CHK` if the areas is not covered"]
pub const LV_DESIGN_RES_NOT_COVER: lv_design_res_t = 2;
#[doc = "< Returned on `LV_DESIGN_COVER_CHK` if the areas is masked out (children also not cover)"]
pub const LV_DESIGN_RES_MASKED: lv_design_res_t = 3;
#[doc = " Design results"]
pub type _bindgen_ty_26 = u32;
pub type lv_design_res_t = u8;
#[doc = " The design callback is used to draw the object on the screen."]
#[doc = " It accepts the object, a mask area, and the mode in which to draw the object."]
pub type lv_design_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        clip_area: *const lv_area_t,
        mode: lv_design_mode_t,
    ) -> lv_design_res_t,
>;
#[doc = "< The object has been pressed"]
pub const LV_EVENT_PRESSED: lv_event_t = 0;
#[doc = "< The object is being pressed (called continuously while pressing)"]
pub const LV_EVENT_PRESSING: lv_event_t = 1;
#[doc = "< User is still pressing but slid cursor/finger off of the object"]
pub const LV_EVENT_PRESS_LOST: lv_event_t = 2;
#[doc = "< User pressed object for a short period of time, then released it. Not called if dragged."]
pub const LV_EVENT_SHORT_CLICKED: lv_event_t = 3;
#[doc = "< Object has been pressed for at least `LV_INDEV_LONG_PRESS_TIME`.  Not called if dragged."]
pub const LV_EVENT_LONG_PRESSED: lv_event_t = 4;
#[doc = "< Called after `LV_INDEV_LONG_PRESS_TIME` in every"]
#[doc = "`LV_INDEV_LONG_PRESS_REP_TIME` ms.  Not called if dragged."]
pub const LV_EVENT_LONG_PRESSED_REPEAT: lv_event_t = 5;
#[doc = "< Called on release if not dragged (regardless to long press)"]
pub const LV_EVENT_CLICKED: lv_event_t = 6;
#[doc = "< Called in every cases when the object has been released"]
pub const LV_EVENT_RELEASED: lv_event_t = 7;
pub const LV_EVENT_DRAG_BEGIN: lv_event_t = 8;
pub const LV_EVENT_DRAG_END: lv_event_t = 9;
pub const LV_EVENT_DRAG_THROW_BEGIN: lv_event_t = 10;
#[doc = "< The object has been gesture"]
pub const LV_EVENT_GESTURE: lv_event_t = 11;
pub const LV_EVENT_KEY: lv_event_t = 12;
pub const LV_EVENT_FOCUSED: lv_event_t = 13;
pub const LV_EVENT_DEFOCUSED: lv_event_t = 14;
pub const LV_EVENT_LEAVE: lv_event_t = 15;
#[doc = "< The object's value has changed (i.e. slider moved)"]
pub const LV_EVENT_VALUE_CHANGED: lv_event_t = 16;
pub const LV_EVENT_INSERT: lv_event_t = 17;
pub const LV_EVENT_REFRESH: lv_event_t = 18;
#[doc = "< \"Ok\", \"Apply\" or similar specific button has clicked"]
pub const LV_EVENT_APPLY: lv_event_t = 19;
#[doc = "< \"Close\", \"Cancel\" or similar specific button has clicked"]
pub const LV_EVENT_CANCEL: lv_event_t = 20;
#[doc = "< Object is being deleted"]
pub const LV_EVENT_DELETE: lv_event_t = 21;
pub const _LV_EVENT_LAST: _bindgen_ty_27 = 22;
pub type _bindgen_ty_27 = u32;
pub type lv_event_t = u8;
#[doc = " @brief Event callback."]
#[doc = " Events are used to notify the user of some action being taken on the object."]
#[doc = " For details, see ::lv_event_t."]
pub type lv_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t, event: lv_event_t)>;
#[doc = "< Object is being deleted"]
pub const LV_SIGNAL_CLEANUP: lv_signal_t = 0;
#[doc = "< Child was removed/added"]
pub const LV_SIGNAL_CHILD_CHG: lv_signal_t = 1;
#[doc = "< Object coordinates/size have changed"]
pub const LV_SIGNAL_COORD_CHG: lv_signal_t = 2;
#[doc = "< Parent's size has changed"]
pub const LV_SIGNAL_PARENT_SIZE_CHG: lv_signal_t = 3;
#[doc = "< Object's style has changed"]
pub const LV_SIGNAL_STYLE_CHG: lv_signal_t = 4;
#[doc = "<The base dir has changed"]
pub const LV_SIGNAL_BASE_DIR_CHG: lv_signal_t = 5;
#[doc = "< Object's extra padding has changed"]
pub const LV_SIGNAL_REFR_EXT_DRAW_PAD: lv_signal_t = 6;
#[doc = "< LVGL needs to retrieve the object's type"]
pub const LV_SIGNAL_GET_TYPE: lv_signal_t = 7;
#[doc = "<Get the style of an object"]
pub const LV_SIGNAL_GET_STYLE: lv_signal_t = 8;
#[doc = "<Get the state of the object"]
pub const LV_SIGNAL_GET_STATE_DSC: lv_signal_t = 9;
#[doc = "< Advanced hit-testing"]
pub const LV_SIGNAL_HIT_TEST: lv_signal_t = 10;
#[doc = "< The object has been pressed"]
pub const LV_SIGNAL_PRESSED: lv_signal_t = 11;
#[doc = "< The object is being pressed (called continuously while pressing)"]
pub const LV_SIGNAL_PRESSING: lv_signal_t = 12;
#[doc = "< User is still pressing but slid cursor/finger off of the object"]
pub const LV_SIGNAL_PRESS_LOST: lv_signal_t = 13;
#[doc = "< User pressed object for a short period of time, then released it. Not called if dragged."]
pub const LV_SIGNAL_RELEASED: lv_signal_t = 14;
#[doc = "< Object has been pressed for at least `LV_INDEV_LONG_PRESS_TIME`.  Not called if dragged."]
pub const LV_SIGNAL_LONG_PRESS: lv_signal_t = 15;
#[doc = "< Called after `LV_INDEV_LONG_PRESS_TIME` in every `LV_INDEV_LONG_PRESS_REP_TIME` ms.  Not called if dragged."]
pub const LV_SIGNAL_LONG_PRESS_REP: lv_signal_t = 16;
pub const LV_SIGNAL_DRAG_BEGIN: lv_signal_t = 17;
pub const LV_SIGNAL_DRAG_THROW_BEGIN: lv_signal_t = 18;
pub const LV_SIGNAL_DRAG_END: lv_signal_t = 19;
#[doc = "< The object has been gesture"]
pub const LV_SIGNAL_GESTURE: lv_signal_t = 20;
#[doc = "< Another object is clicked or chosen via an input device"]
pub const LV_SIGNAL_LEAVE: lv_signal_t = 21;
pub const LV_SIGNAL_FOCUS: lv_signal_t = 22;
pub const LV_SIGNAL_DEFOCUS: lv_signal_t = 23;
pub const LV_SIGNAL_CONTROL: lv_signal_t = 24;
pub const LV_SIGNAL_GET_EDITABLE: lv_signal_t = 25;
#[doc = " Signals are for use by the object itself or to extend the object's functionality."]
#[doc = " Applications should use ::lv_obj_set_event_cb to be notified of events that occur"]
#[doc = " on the object."]
pub type _bindgen_ty_28 = u32;
pub type lv_signal_t = u8;
pub type lv_signal_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        sign: lv_signal_t,
        param: *mut ::cty::c_void,
    ) -> lv_res_t,
>;
#[repr(C)]
pub struct lv_realign_t {
    pub base: *const _lv_obj_t,
    pub xofs: lv_coord_t,
    pub yofs: lv_coord_t,
    pub align: lv_align_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
impl Default for lv_realign_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_realign_t {
    #[inline]
    pub fn auto_realign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_realign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mid_align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mid_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        auto_realign: u8,
        mid_align: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_realign: u8 = unsafe { ::core::mem::transmute(auto_realign) };
            auto_realign as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mid_align: u8 = unsafe { ::core::mem::transmute(mid_align) };
            mid_align as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_PROTECT_NONE: lv_protect_t = 0;
#[doc = "< Disable the child change signal. Used by the library"]
pub const LV_PROTECT_CHILD_CHG: lv_protect_t = 1;
#[doc = "< Prevent automatic parent change (e.g. in lv_page)"]
pub const LV_PROTECT_PARENT: lv_protect_t = 2;
#[doc = "< Prevent automatic positioning (e.g. in lv_cont layout)"]
pub const LV_PROTECT_POS: lv_protect_t = 4;
#[doc = "< Prevent the object be followed in automatic ordering (e.g. in"]
#[doc = "lv_cont PRETTY layout)"]
pub const LV_PROTECT_FOLLOW: lv_protect_t = 8;
#[doc = "< If the `indev` was pressing this object but swiped out while"]
#[doc = "pressing do not search other object."]
pub const LV_PROTECT_PRESS_LOST: lv_protect_t = 16;
#[doc = "< Prevent focusing the object by clicking on it"]
pub const LV_PROTECT_CLICK_FOCUS: lv_protect_t = 32;
pub type _bindgen_ty_29 = u32;
pub type lv_protect_t = u8;
pub const LV_STATE_DEFAULT: lv_state_t = 0;
pub const LV_STATE_CHECKED: lv_state_t = 1;
pub const LV_STATE_FOCUSED: lv_state_t = 2;
pub const LV_STATE_EDITED: lv_state_t = 4;
pub const LV_STATE_HOVERED: lv_state_t = 8;
pub const LV_STATE_PRESSED: lv_state_t = 16;
pub const LV_STATE_DISABLED: lv_state_t = 32;
pub type _bindgen_ty_30 = u32;
pub type lv_state_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _lv_obj_t {
    #[doc = "< Pointer to the parent object"]
    pub parent: *mut _lv_obj_t,
    #[doc = "< Linked list to store the children objects"]
    pub child_ll: lv_ll_t,
    #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
    pub coords: lv_area_t,
    #[doc = "< Event callback function"]
    pub event_cb: lv_event_cb_t,
    #[doc = "< Object type specific signal function"]
    pub signal_cb: lv_signal_cb_t,
    #[doc = "< Object type specific design function"]
    pub design_cb: lv_design_cb_t,
    #[doc = "< Object type specific extended data"]
    pub ext_attr: *mut ::cty::c_void,
    pub style_list: lv_style_list_t,
    #[doc = "< Extra click padding in horizontal direction"]
    pub ext_click_pad_hor: u8,
    #[doc = "< Extra click padding in vertical direction"]
    pub ext_click_pad_ver: u8,
    #[doc = "< EXTend the size in every direction for drawing."]
    pub ext_draw_pad: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    #[doc = "< Automatically happening actions can be prevented."]
    #[doc = "'OR'ed values from `lv_protect_t`"]
    pub protect: u8,
    pub state: lv_state_t,
    #[doc = "< Information about the last call to ::lv_obj_align."]
    pub realign: lv_realign_t,
    #[doc = "< Custom user data for object."]
    pub user_data: lv_obj_user_data_t,
}
impl Default for _lv_obj_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_obj_t {
    #[inline]
    pub fn click(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_throw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_throw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_top(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parent_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parent_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adv_hittest(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_adv_hittest(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gesture_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gesture_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_focus_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn base_dir(&self) -> lv_bidi_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        click: u8,
        drag: u8,
        drag_throw: u8,
        drag_parent: u8,
        hidden: u8,
        top: u8,
        parent_event: u8,
        adv_hittest: u8,
        gesture_parent: u8,
        focus_parent: u8,
        drag_dir: lv_drag_dir_t,
        base_dir: lv_bidi_dir_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let click: u8 = unsafe { ::core::mem::transmute(click) };
            click as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag: u8 = unsafe { ::core::mem::transmute(drag) };
            drag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_throw: u8 = unsafe { ::core::mem::transmute(drag_throw) };
            drag_throw as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drag_parent: u8 = unsafe { ::core::mem::transmute(drag_parent) };
            drag_parent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hidden: u8 = unsafe { ::core::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let top: u8 = unsafe { ::core::mem::transmute(top) };
            top as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let parent_event: u8 = unsafe { ::core::mem::transmute(parent_event) };
            parent_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let adv_hittest: u8 = unsafe { ::core::mem::transmute(adv_hittest) };
            adv_hittest as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let gesture_parent: u8 = unsafe { ::core::mem::transmute(gesture_parent) };
            gesture_parent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let focus_parent: u8 = unsafe { ::core::mem::transmute(focus_parent) };
            focus_parent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let base_dir: u8 = unsafe { ::core::mem::transmute(base_dir) };
            base_dir as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_obj_t = _lv_obj_t;
pub const LV_OBJ_PART_MAIN: lv_obj_part_t = 0;
pub const _LV_OBJ_PART_VIRTUAL_LAST: lv_obj_part_t = 1;
pub const _LV_OBJ_PART_REAL_LAST: lv_obj_part_t = 64;
pub const LV_OBJ_PART_ALL: lv_obj_part_t = 255;
pub type _bindgen_ty_31 = u32;
pub type lv_obj_part_t = u8;
#[doc = " Used by `lv_obj_get_type()`. The object's and its ancestor types are stored here"]
#[repr(C)]
pub struct lv_obj_type_t {
    #[doc = "< [0]: the actual type, [1]: ancestor, [2] #1's ancestor"]
    #[doc = "... [x]: \"lv_obj\""]
    pub type_: [*const ::cty::c_char; 8usize],
}
impl Default for lv_obj_type_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_hit_test_info_t {
    pub point: *mut lv_point_t,
    pub result: bool,
}
impl Default for lv_hit_test_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_get_style_info_t {
    pub part: u8,
    pub result: *mut lv_style_list_t,
}
impl Default for lv_get_style_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct lv_get_state_info_t {
    pub part: u8,
    pub result: lv_state_t,
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create a basic object"]
    #[doc = " - __`parent`__: pointer to a parent object."]
    #[doc = "                  If NULL then a screen will be created"]
    #[doc = " - __`copy`__: pointer to a base object, if not NULL then the new object will be copied from it"]
    #[doc = " Return: pointer to the new object"]
    pub fn lv_obj_create(parent: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Delete 'obj' and all of its children"]
    #[doc = " - __`obj`__: pointer to an object to delete"]
    #[doc = " Return: LV_RES_INV because the object is deleted"]
    pub fn lv_obj_del(obj: *mut lv_obj_t) -> lv_res_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " A function to be easily used in animation ready callback to delete an object when the animation is ready"]
    #[doc = " - __`a`__: pointer to the animation"]
    pub fn lv_obj_del_anim_ready_cb(a: *mut lv_anim_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Helper function for asynchronously deleting objects."]
    #[doc = " Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent)."]
    #[doc = " - __`obj`__: object to delete"]
    #[doc = " @see lv_async_call"]
    pub fn lv_obj_del_async(obj: *mut _lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Delete all children of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    pub fn lv_obj_clean(obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Mark an area of an object as invalid."]
    #[doc = " This area will be redrawn by 'lv_refr_task'"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`area`__: the area to redraw"]
    pub fn lv_obj_invalidate_area(obj: *const lv_obj_t, area: *const lv_area_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'"]
    #[doc = " - __`obj`__: pointer to an object"]
    pub fn lv_obj_invalidate(obj: *const lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Tell whether an area of an object is visible (even partially) now or not"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`area`__: the are to check. The visible part of the area will be written back here."]
    #[doc = " Return: true: visible; false: not visible (hidden, out of parent, on other screen, etc)"]
    pub fn lv_obj_area_is_visible(obj: *const lv_obj_t, area: *mut lv_area_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Tell whether an object is visible (even partially) now or not"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: visible; false: not visible (hidden, out of parent, on other screen, etc)"]
    pub fn lv_obj_is_visible(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a new parent for an object. Its relative position will be the same."]
    #[doc = " - __`obj`__: pointer to an object. Can't be a screen."]
    #[doc = " - __`parent`__: pointer to the new parent object. (Can't be NULL)"]
    pub fn lv_obj_set_parent(obj: *mut lv_obj_t, parent: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Move and object to the foreground"]
    #[doc = " - __`obj`__: pointer to an object"]
    pub fn lv_obj_move_foreground(obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Move and object to the background"]
    #[doc = " - __`obj`__: pointer to an object"]
    pub fn lv_obj_move_background(obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set relative the position of an object (relative to the parent)"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`x`__: new distance from the left side of the parent"]
    #[doc = " - __`y`__: new distance from the top of the parent"]
    pub fn lv_obj_set_pos(obj: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the x coordinate of a object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`x`__: new distance from the left side from the parent"]
    pub fn lv_obj_set_x(obj: *mut lv_obj_t, x: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the y coordinate of a object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`y`__: new distance from the top of the parent"]
    pub fn lv_obj_set_y(obj: *mut lv_obj_t, y: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the size of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`w`__: new width"]
    #[doc = " - __`h`__: new height"]
    pub fn lv_obj_set_size(obj: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the width of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`w`__: new width"]
    pub fn lv_obj_set_width(obj: *mut lv_obj_t, w: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the height of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`h`__: new height"]
    pub fn lv_obj_set_height(obj: *mut lv_obj_t, h: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the width reduced by the left and right padding."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`w`__: the width without paddings"]
    pub fn lv_obj_set_width_fit(obj: *mut lv_obj_t, w: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the height reduced by the top and bottom padding."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`h`__: the height without paddings"]
    pub fn lv_obj_set_height_fit(obj: *mut lv_obj_t, h: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the width of an object by taking the left and right margin into account."]
    #[doc = " The object width will be `obj_w = w - margin_left - margin_right`"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`w`__: new height including margins"]
    pub fn lv_obj_set_width_margin(obj: *mut lv_obj_t, w: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the height of an object by taking the top and bottom margin into account."]
    #[doc = " The object height will be `obj_h = h - margin_top - margin_bottom`"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`h`__: new height including margins"]
    pub fn lv_obj_set_height_margin(obj: *mut lv_obj_t, h: lv_coord_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Align an object to an other object."]
    #[doc = " - __`obj`__: pointer to an object to align"]
    #[doc = " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
    #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
    #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
    pub fn lv_obj_align(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
        y_ofs: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Align an object to an other object horizontally."]
    #[doc = " - __`obj`__: pointer to an object to align"]
    #[doc = " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
    #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
    pub fn lv_obj_align_x(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Align an object to an other object vertically."]
    #[doc = " - __`obj`__: pointer to an object to align"]
    #[doc = " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
    #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
    pub fn lv_obj_align_y(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        y_ofs: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Align an object to an other object."]
    #[doc = " - __`obj`__: pointer to an object to align"]
    #[doc = " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
    #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
    #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
    pub fn lv_obj_align_mid(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
        y_ofs: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Align an object's middle point to an other object horizontally."]
    #[doc = " - __`obj`__: pointer to an object to align"]
    #[doc = " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
    #[doc = " - __`x_ofs`__: x coordinate offset after alignment"]
    pub fn lv_obj_align_mid_x(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Align an object's middle point to an other object vertically."]
    #[doc = " - __`obj`__: pointer to an object to align"]
    #[doc = " - __`base`__: pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " - __`align`__: type of alignment (see 'lv_align_t' enum)"]
    #[doc = " - __`y_ofs`__: y coordinate offset after alignment"]
    pub fn lv_obj_align_mid_y(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        y_ofs: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Realign the object based on the last `lv_obj_align` parameters."]
    #[doc = " - __`obj`__: pointer to an object"]
    pub fn lv_obj_realign(obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable the automatic realign of the object when its size has changed based on the last"]
    #[doc = " `lv_obj_align` parameters."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable auto realign; false: disable auto realign"]
    pub fn lv_obj_set_auto_realign(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the size of an extended clickable area"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`left`__: extended clickable are on the left [px]"]
    #[doc = " - __`right`__: extended clickable are on the right [px]"]
    #[doc = " - __`top`__: extended clickable are on the top [px]"]
    #[doc = " - __`bottom`__: extended clickable are on the bottom [px]"]
    pub fn lv_obj_set_ext_click_area(
        obj: *mut lv_obj_t,
        left: lv_coord_t,
        right: lv_coord_t,
        top: lv_coord_t,
        bottom: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Add a new style to the style list of an object."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: the part of the object which style property should be set."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    #[doc = " - __`style`__: pointer to a style to add (Only its pointer will be saved)"]
    pub fn lv_obj_add_style(obj: *mut lv_obj_t, part: u8, style: *mut lv_style_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove a style from the style list of an object."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: the part of the object which style property should be set."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    #[doc = " - __`style`__: pointer to a style to remove"]
    pub fn lv_obj_remove_style(obj: *mut lv_obj_t, part: u8, style: *mut lv_style_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset a style to the default (empty) state."]
    #[doc = " Release all used memories and cancel pending related transitions."]
    #[doc = " Typically used in `LV_SIGN_CLEAN_UP."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: the part of the object which style list should be reseted."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    pub fn lv_obj_clean_style_list(obj: *mut lv_obj_t, part: u8);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset a style to the default (empty) state."]
    #[doc = " Release all used memories and cancel pending related transitions."]
    #[doc = " Also notifies the object about the style change."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: the part of the object which style list should be reseted."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    pub fn lv_obj_reset_style_list(obj: *mut lv_obj_t, part: u8);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Notify an object (and its children) about its style is modified"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`prop`__: `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed."]
    pub fn lv_obj_refresh_style(obj: *mut lv_obj_t, part: u8, prop: lv_style_property_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Notify all object if a style is modified"]
    #[doc = " - __`style`__: pointer to a style. Only the objects with this style will be notified"]
    #[doc = "               (NULL to notify all objects)"]
    pub fn lv_obj_report_style_mod(style: *mut lv_style_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove a local style property from a part of an object with a given state."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: the part of the object which style property should be removed."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    #[doc = " - __`prop`__: a style property ORed with a state."]
    #[doc = " E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`"]
    #[doc = " __Note:__ shouldn't be used directly. Use the specific property remove functions instead."]
    #[doc = "       For example: `lv_obj_style_remove_border_opa()`"]
    #[doc = " Return: true: the property was found and removed; false: the property was not found"]
    pub fn lv_obj_remove_style_local_prop(
        obj: *mut lv_obj_t,
        part: u8,
        prop: lv_style_property_t,
    ) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Hide an object. It won't be visible and clickable."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: hide the object"]
    pub fn lv_obj_set_hidden(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set whether advanced hit-testing is enabled on an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: advanced hit-testing is enabled"]
    pub fn lv_obj_set_adv_hittest(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable or disable the clicking of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: make the object clickable"]
    pub fn lv_obj_set_click(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable to bring this object to the foreground if it"]
    #[doc = " or any of its children is clicked"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable the auto top feature"]
    pub fn lv_obj_set_top(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable the dragging of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: make the object draggable"]
    pub fn lv_obj_set_drag(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the directions an object can be dragged in"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`drag_dir`__: bitwise OR of allowed drag directions"]
    pub fn lv_obj_set_drag_dir(obj: *mut lv_obj_t, drag_dir: lv_drag_dir_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable the throwing of an object after is is dragged"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable the drag throw"]
    pub fn lv_obj_set_drag_throw(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable to use parent for drag related operations."]
    #[doc = " If trying to drag the object the parent will be moved instead"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable the 'drag parent' for the object"]
    pub fn lv_obj_set_drag_parent(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable to use parent for focus state."]
    #[doc = " When object is focused the parent will get the state instead (visual only)"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable the 'focus parent' for the object"]
    pub fn lv_obj_set_focus_parent(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable to use parent for gesture related operations."]
    #[doc = " If trying to gesture the object the parent will be moved instead"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable the 'gesture parent' for the object"]
    pub fn lv_obj_set_gesture_parent(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Propagate the events to the parent too"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`en`__: true: enable the event propagation"]
    pub fn lv_obj_set_parent_event(obj: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the base direction of the object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`dir`__: the new base direction. `LV_BIDI_DIR_LTR/RTL/AUTO/INHERIT`"]
    pub fn lv_obj_set_base_dir(obj: *mut lv_obj_t, dir: lv_bidi_dir_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a bit or bits in the protect filed"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
    pub fn lv_obj_add_protect(obj: *mut lv_obj_t, prot: u8);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Clear a bit or bits in the protect filed"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`prot`__: 'OR'-ed values from `lv_protect_t`"]
    pub fn lv_obj_clear_protect(obj: *mut lv_obj_t, prot: u8);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the state (fully overwrite) of an object."]
    #[doc = " If specified in the styles a transition animation will be started"]
    #[doc = " from the previous state to the current"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`state`__: the new state"]
    pub fn lv_obj_set_state(obj: *mut lv_obj_t, state: lv_state_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Add a given state or states to the object. The other state bits will remain unchanged."]
    #[doc = " If specified in the styles a transition animation will be started"]
    #[doc = " from the previous state to the current"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`state`__: the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`"]
    pub fn lv_obj_add_state(obj: *mut lv_obj_t, state: lv_state_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove a given state or states to the object. The other state bits will remain unchanged."]
    #[doc = " If specified in the styles a transition animation will be started"]
    #[doc = " from the previous state to the current"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`state`__: the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`"]
    pub fn lv_obj_clear_state(obj: *mut lv_obj_t, state: lv_state_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Finish all pending transitions on a part of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: part of the object, e.g `LV_BRN_PART_MAIN` or `LV_OBJ_PART_ALL` for all parts"]
    pub fn lv_obj_finish_transitions(obj: *mut lv_obj_t, part: u8);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a an event handler function for an object."]
    #[doc = " Used by the user to react on event which happens with the object."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`event_cb`__: the new event function"]
    pub fn lv_obj_set_event_cb(obj: *mut lv_obj_t, event_cb: lv_event_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the a signal function of an object. Used internally by the library."]
    #[doc = " Always call the previous signal function in the new."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`signal_cb`__: the new signal function"]
    pub fn lv_obj_set_signal_cb(obj: *mut lv_obj_t, signal_cb: lv_signal_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a new design function for an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`design_cb`__: the new design function"]
    pub fn lv_obj_set_design_cb(obj: *mut lv_obj_t, design_cb: lv_design_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Allocate a new ext. data for an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`ext_size`__: the size of the new ext. data"]
    #[doc = " Return: pointer to the allocated ext"]
    pub fn lv_obj_allocate_ext_attr(obj: *mut lv_obj_t, ext_size: u16) -> *mut ::cty::c_void;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area."]
    #[doc = " he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function."]
    #[doc = " - __`obj`__: pointer to an object"]
    pub fn lv_obj_refresh_ext_draw_pad(obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Return with the screen of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: pointer to a screen"]
    pub fn lv_obj_get_screen(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the display of an object"]
    #[doc = " Return: pointer the object's display"]
    pub fn lv_obj_get_disp(obj: *const lv_obj_t) -> *mut lv_disp_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Returns with the parent of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: pointer to the parent of  'obj'"]
    pub fn lv_obj_get_parent(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Iterate through the children of an object (start from the \"youngest, lastly created\")"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`child`__: NULL at first call to get the next children"]
    #[doc = "                  and the previous return value later"]
    #[doc = " Return: the child after 'act_child' or NULL if no more child"]
    pub fn lv_obj_get_child(obj: *const lv_obj_t, child: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Iterate through the children of an object (start from the \"oldest\", firstly created)"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`child`__: NULL at first call to get the next children"]
    #[doc = "                  and the previous return value later"]
    #[doc = " Return: the child after 'act_child' or NULL if no more child"]
    pub fn lv_obj_get_child_back(obj: *const lv_obj_t, child: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Count the children of an object (only children directly on 'obj')"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: children number of 'obj'"]
    pub fn lv_obj_count_children(obj: *const lv_obj_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Recursively count the children of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: children number of 'obj'"]
    pub fn lv_obj_count_children_recursive(obj: *const lv_obj_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Copy the coordinates of an object to an area"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`cords_p`__: pointer to an area to store the coordinates"]
    pub fn lv_obj_get_coords(obj: *const lv_obj_t, cords_p: *mut lv_area_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object."]
    #[doc = " (Without the size of the border or other extra graphical elements)"]
    #[doc = " - __`coords_p`__: store the result area here"]
    pub fn lv_obj_get_inner_coords(obj: *const lv_obj_t, coords_p: *mut lv_area_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the x coordinate of object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: distance of 'obj' from the left side of its parent"]
    pub fn lv_obj_get_x(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the y coordinate of object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: distance of 'obj' from the top of its parent"]
    pub fn lv_obj_get_y(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the width of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the width"]
    pub fn lv_obj_get_width(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the height of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the height"]
    pub fn lv_obj_get_height(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get that width reduced by the left and right padding."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the width which still fits into the container"]
    pub fn lv_obj_get_width_fit(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get that height reduced by the top an bottom padding."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the height which still fits into the container"]
    pub fn lv_obj_get_height_fit(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the height of an object by taking the top and bottom margin into account."]
    #[doc = " The returned height will be `obj_h + margin_top + margin_bottom`"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the height including thee margins"]
    pub fn lv_obj_get_height_margin(obj: *mut lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the width of an object by taking the left and right margin into account."]
    #[doc = " The returned width will be `obj_w + margin_left + margin_right`"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the height including thee margins"]
    pub fn lv_obj_get_width_margin(obj: *mut lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Divide the width of the object and get the width of a given number of columns."]
    #[doc = " Take paddings into account."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`div`__: indicates how many columns are assumed."]
    #[doc = " If 1 the width will be set the the parent's width"]
    #[doc = " If 2 only half parent width - inner padding of the parent"]
    #[doc = " If 3 only third parent width - 2 * inner padding of the parent"]
    #[doc = " - __`span`__: how many columns are combined"]
    #[doc = " Return: the width according to the given parameters"]
    pub fn lv_obj_get_width_grid(obj: *mut lv_obj_t, div: u8, span: u8) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Divide the height of the object and get the width of a given number of columns."]
    #[doc = " Take paddings into account."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`div`__: indicates how many rows are assumed."]
    #[doc = " If 1 the height will be set the the parent's height"]
    #[doc = " If 2 only half parent height - inner padding of the parent"]
    #[doc = " If 3 only third parent height - 2 * inner padding of the parent"]
    #[doc = " - __`span`__: how many rows are combined"]
    #[doc = " Return: the height according to the given parameters"]
    pub fn lv_obj_get_height_grid(obj: *mut lv_obj_t, div: u8, span: u8) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the automatic realign property of the object."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return:  true: auto realign is enabled; false: auto realign is disabled"]
    pub fn lv_obj_get_auto_realign(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the left padding of extended clickable area"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the extended left padding"]
    pub fn lv_obj_get_ext_click_pad_left(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the right padding of extended clickable area"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the extended right padding"]
    pub fn lv_obj_get_ext_click_pad_right(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the top padding of extended clickable area"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the extended top padding"]
    pub fn lv_obj_get_ext_click_pad_top(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the bottom padding of extended clickable area"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the extended bottom padding"]
    pub fn lv_obj_get_ext_click_pad_bottom(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the extended size attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the extended size attribute"]
    pub fn lv_obj_get_ext_draw_pad(obj: *const lv_obj_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the style list of an object's part."]
    #[doc = " - __`obj`__: pointer to an object."]
    #[doc = " - __`part`__: part the part of the object which style list should be get."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    #[doc = " Return: pointer to the style list. (Can be `NULL`)"]
    pub fn lv_obj_get_style_list(obj: *const lv_obj_t, part: u8) -> *mut lv_style_list_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the local style of a part of an object."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: the part of the object which style property should be set."]
    #[doc = " E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`"]
    #[doc = " Return: pointer to the local style if exists else `NULL`."]
    pub fn lv_obj_get_local_style(obj: *mut lv_obj_t, part: u8) -> *mut lv_style_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_radius(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_radius(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_clip_corner(obj: *const lv_obj_t, part: u8) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_clip_corner(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: bool,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_size(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_size(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transform_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transform_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transform_height(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transform_height(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transform_angle(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transform_angle(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transform_zoom(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transform_zoom(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_opa_scale(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_opa_scale(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pad_top(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_top(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pad_bottom(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_bottom(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pad_left(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_left(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pad_right(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_right(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pad_inner(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_inner(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_margin_top(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_top(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_margin_bottom(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_bottom(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_margin_left(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_left(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_margin_right(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_right(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_main_stop(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_main_stop(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_grad_stop(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_grad_stop(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_grad_dir(obj: *const lv_obj_t, part: u8) -> lv_grad_dir_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_grad_dir(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_grad_dir_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_grad_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_grad_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_bg_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_bg_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_border_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_border_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_border_side(obj: *const lv_obj_t, part: u8) -> lv_border_side_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_border_side(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_border_side_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_border_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_border_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_border_post(obj: *const lv_obj_t, part: u8) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_border_post(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: bool,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_border_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_border_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_border_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_border_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_outline_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_outline_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_outline_pad(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_outline_pad(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_outline_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_outline_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_outline_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_outline_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_outline_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_outline_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_ofs_x(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_ofs_x(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_ofs_y(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_ofs_y(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_spread(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_spread(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_shadow_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_shadow_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pattern_repeat(obj: *const lv_obj_t, part: u8) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pattern_repeat(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: bool,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pattern_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pattern_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pattern_recolor(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pattern_recolor(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pattern_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pattern_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pattern_recolor_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pattern_recolor_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_pattern_image(obj: *const lv_obj_t, part: u8) -> *const ::cty::c_void;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pattern_image(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: *const ::cty::c_void,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_letter_space(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_letter_space(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_line_space(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_line_space(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_ofs_x(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_ofs_x(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_ofs_y(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_ofs_y(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_align(obj: *const lv_obj_t, part: u8) -> lv_align_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_align(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_align_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_value_font(obj: *const lv_obj_t, part: u8) -> *const lv_font_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_font(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: *const lv_font_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_value_str(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: *const ::cty::c_char,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_letter_space(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_letter_space(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_line_space(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_line_space(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_decor(obj: *const lv_obj_t, part: u8) -> lv_text_decor_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_decor(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_text_decor_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_sel_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_sel_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_text_font(obj: *const lv_obj_t, part: u8) -> *const lv_font_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_text_font(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: *const lv_font_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_dash_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_dash_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_dash_gap(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_dash_gap(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_rounded(obj: *const lv_obj_t, part: u8) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_rounded(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: bool,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_line_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_line_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_image_blend_mode(obj: *const lv_obj_t, part: u8) -> lv_blend_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_image_blend_mode(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_blend_mode_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_image_recolor(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_image_recolor(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_image_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_image_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_image_recolor_opa(obj: *const lv_obj_t, part: u8) -> lv_opa_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_image_recolor_opa(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_time(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_time(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_delay(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_delay(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_prop_1(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_prop_1(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_prop_2(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_prop_2(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_prop_3(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_prop_3(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_prop_4(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_prop_4(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_prop_5(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_prop_5(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_prop_6(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_prop_6(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_transition_path(obj: *const lv_obj_t, part: u8) -> *mut lv_anim_path_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_transition_path(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: *mut lv_anim_path_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_scale_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_scale_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_scale_border_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_scale_border_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_scale_end_border_width(
        obj: *const lv_obj_t,
        part: u8,
    ) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_scale_end_border_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_scale_end_line_width(obj: *const lv_obj_t, part: u8) -> lv_style_int_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_scale_end_line_width(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_scale_grad_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_scale_grad_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_style_scale_end_color(obj: *const lv_obj_t, part: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_scale_end_color(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_color_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_all(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_hor(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_pad_ver(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_all(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_hor(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_set_style_local_margin_ver(
        obj: *mut lv_obj_t,
        part: u8,
        state: lv_state_t,
        value: lv_style_int_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the hidden attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: the object is hidden"]
    pub fn lv_obj_get_hidden(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get whether advanced hit-testing is enabled on an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: advanced hit-testing is enabled"]
    pub fn lv_obj_get_adv_hittest(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the click enable attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: the object is clickable"]
    pub fn lv_obj_get_click(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the top enable attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: the auto top feature is enabled"]
    pub fn lv_obj_get_top(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the drag enable attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: the object is draggable"]
    pub fn lv_obj_get_drag(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the directions an object can be dragged"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: bitwise OR of allowed directions an object can be dragged in"]
    pub fn lv_obj_get_drag_dir(obj: *const lv_obj_t) -> lv_drag_dir_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the drag throw enable attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: drag throw is enabled"]
    pub fn lv_obj_get_drag_throw(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the drag parent attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: drag parent is enabled"]
    pub fn lv_obj_get_drag_parent(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the focus parent attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: focus parent is enabled"]
    pub fn lv_obj_get_focus_parent(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the drag parent attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: drag parent is enabled"]
    pub fn lv_obj_get_parent_event(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the gesture parent attribute of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: gesture parent is enabled"]
    pub fn lv_obj_get_gesture_parent(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_base_dir(obj: *const lv_obj_t) -> lv_bidi_dir_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the protect field of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: protect field ('OR'ed values of `lv_protect_t`)"]
    pub fn lv_obj_get_protect(obj: *const lv_obj_t) -> u8;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check at least one bit of a given protect bitfield is set"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`prot`__: protect bits to test ('OR'ed values of `lv_protect_t`)"]
    #[doc = " Return: false: none of the given bits are set, true: at least one bit is set"]
    pub fn lv_obj_is_protected(obj: *const lv_obj_t, prot: u8) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_get_state(obj: *const lv_obj_t, part: u8) -> lv_state_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the signal function of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the signal function"]
    pub fn lv_obj_get_signal_cb(obj: *const lv_obj_t) -> lv_signal_cb_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the design function of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the design function"]
    pub fn lv_obj_get_design_cb(obj: *const lv_obj_t) -> lv_design_cb_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the event function of an object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the event function"]
    pub fn lv_obj_get_event_cb(obj: *const lv_obj_t) -> lv_event_cb_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check if a given screen-space point is on an object's coordinates."]
    #[doc = ""]
    #[doc = " This method is intended to be used mainly by advanced hit testing algorithms to check"]
    #[doc = " whether the point is even within the object (as an optimization)."]
    #[doc = " - __`obj`__: object to check"]
    #[doc = " - __`point`__: screen-space point"]
    pub fn lv_obj_is_point_on_coords(obj: *mut lv_obj_t, point: *const lv_point_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Hit-test an object given a particular point in screen space."]
    #[doc = " - __`obj`__: object to hit-test"]
    #[doc = " - __`point`__: screen-space point"]
    #[doc = " Return: true if the object is considered under the point"]
    pub fn lv_obj_hittest(obj: *mut lv_obj_t, point: *mut lv_point_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the ext pointer"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the ext pointer but not the dynamic version"]
    #[doc = "         Use it as ext->data1, and NOT da(ext)->data1"]
    pub fn lv_obj_get_ext_attr(obj: *const lv_obj_t) -> *mut ::cty::c_void;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get object's and its ancestors type. Put their name in `type_buf` starting with the current type."]
    #[doc = " E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\""]
    #[doc = " - __`obj`__: pointer to an object which type should be get"]
    #[doc = " - __`buf`__: pointer to an `lv_obj_type_t` buffer to store the types"]
    pub fn lv_obj_get_type(obj: *const lv_obj_t, buf: *mut lv_obj_type_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the object's user data"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: user data"]
    pub fn lv_obj_get_user_data(obj: *const lv_obj_t) -> lv_obj_user_data_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get a pointer to the object's user data"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: pointer to the user data"]
    pub fn lv_obj_get_user_data_ptr(obj: *const lv_obj_t) -> *mut lv_obj_user_data_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the object's user data. The data will be copied."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`data`__: user data"]
    pub fn lv_obj_set_user_data(obj: *mut lv_obj_t, data: lv_obj_user_data_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the group of the object"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: the pointer to group of the object"]
    pub fn lv_obj_get_group(obj: *const lv_obj_t) -> *mut ::cty::c_void;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Tell whether the object is the focused object of a group or not."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " Return: true: the object is focused, false: the object is not focused or not in a group"]
    pub fn lv_obj_is_focused(obj: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the really focused object by taking `focus_parent` into account."]
    #[doc = " - __`obj`__: the start object"]
    #[doc = " Return: the object to really focus"]
    pub fn lv_obj_get_focused_obj(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal"]
    #[doc = " - __`buf`__: pointer to `lv_obj_type_t`. (`param` in the signal callback)"]
    #[doc = " - __`name`__: name of the object. E.g. \"lv_btn\". (Only the pointer is saved)"]
    #[doc = " Return: LV_RES_OK"]
    pub fn lv_obj_handle_get_type_signal(
        buf: *mut lv_obj_type_t,
        name: *const ::cty::c_char,
    ) -> lv_res_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a rectangle descriptor from an object's styles"]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`type`__: type of style. E.g.  `LV_OBJ_PART_MAIN`, `LV_BTN_SLIDER_KOB`"]
    #[doc = " - __`draw_dsc`__: the descriptor the initialize"]
    #[doc = " __Note:__ Only the relevant fields will be set."]
    #[doc = " E.g. if `border width == 0` the other border properties won't be evaluated."]
    pub fn lv_obj_init_draw_rect_dsc(
        obj: *mut lv_obj_t,
        type_: u8,
        draw_dsc: *mut lv_draw_rect_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_init_draw_label_dsc(
        obj: *mut lv_obj_t,
        type_: u8,
        draw_dsc: *mut lv_draw_label_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_init_draw_img_dsc(obj: *mut lv_obj_t, part: u8, draw_dsc: *mut lv_draw_img_dsc_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_obj_init_draw_line_dsc(
        obj: *mut lv_obj_t,
        part: u8,
        draw_dsc: *mut lv_draw_line_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the required extra size (around the object's part) to draw shadow, outline, value etc."]
    #[doc = " - __`obj`__: pointer to an object"]
    #[doc = " - __`part`__: part of the object"]
    pub fn lv_obj_get_draw_rect_ext_pad_size(obj: *mut lv_obj_t, part: u8) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Fade in (from transparent to fully cover) an object and all its children using an `opa_scale` animation."]
    #[doc = " - __`obj`__: the object to fade in"]
    #[doc = " - __`time`__: duration of the animation [ms]"]
    #[doc = " - __`delay`__: wait before the animation starts [ms]"]
    pub fn lv_obj_fade_in(obj: *mut lv_obj_t, time: u32, delay: u32);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Fade out (from fully cover to transparent) an object and all its children using an `opa_scale` animation."]
    #[doc = " - __`obj`__: the object to fade in"]
    #[doc = " - __`time`__: duration of the animation [ms]"]
    #[doc = " - __`delay`__: wait before the animation starts [ms]"]
    pub fn lv_obj_fade_out(obj: *mut lv_obj_t, time: u32, delay: u32);
}
