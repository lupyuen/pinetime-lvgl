/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const LV_INDEV_DEF_READ_PERIOD: u32 = 30;
pub const LV_INDEV_DEF_DRAG_LIMIT: u32 = 10;
pub const LV_INDEV_DEF_DRAG_THROW: u32 = 20;
pub const LV_INDEV_DEF_LONG_PRESS_TIME: u32 = 400;
pub const LV_INDEV_DEF_LONG_PRESS_REP_TIME: u32 = 100;
pub const LV_INDEV_DEF_GESTURE_LIMIT: u32 = 50;
pub const LV_INDEV_DEF_GESTURE_MIN_VELOCITY: u32 = 3;
pub type lv_coord_t = i16;
pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
pub type lv_indev_drv_user_data_t = *mut ::cty::c_void;
pub type lv_obj_user_data_t = *mut ::cty::c_void;
pub type lv_res_t = u8;
#[doc = " Represents a point on the screen."]
#[repr(C)]
#[derive(Default)]
pub struct lv_point_t {
    pub x: lv_coord_t,
    pub y: lv_coord_t,
}
#[doc = " Represents an area of the screen."]
#[repr(C)]
#[derive(Default)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
pub const LV_ALIGN_CENTER: lv_align_t = 0;
pub const LV_ALIGN_IN_TOP_LEFT: lv_align_t = 1;
pub const LV_ALIGN_IN_TOP_MID: lv_align_t = 2;
pub const LV_ALIGN_IN_TOP_RIGHT: lv_align_t = 3;
pub const LV_ALIGN_IN_BOTTOM_LEFT: lv_align_t = 4;
pub const LV_ALIGN_IN_BOTTOM_MID: lv_align_t = 5;
pub const LV_ALIGN_IN_BOTTOM_RIGHT: lv_align_t = 6;
pub const LV_ALIGN_IN_LEFT_MID: lv_align_t = 7;
pub const LV_ALIGN_IN_RIGHT_MID: lv_align_t = 8;
pub const LV_ALIGN_OUT_TOP_LEFT: lv_align_t = 9;
pub const LV_ALIGN_OUT_TOP_MID: lv_align_t = 10;
pub const LV_ALIGN_OUT_TOP_RIGHT: lv_align_t = 11;
pub const LV_ALIGN_OUT_BOTTOM_LEFT: lv_align_t = 12;
pub const LV_ALIGN_OUT_BOTTOM_MID: lv_align_t = 13;
pub const LV_ALIGN_OUT_BOTTOM_RIGHT: lv_align_t = 14;
pub const LV_ALIGN_OUT_LEFT_TOP: lv_align_t = 15;
pub const LV_ALIGN_OUT_LEFT_MID: lv_align_t = 16;
pub const LV_ALIGN_OUT_LEFT_BOTTOM: lv_align_t = 17;
pub const LV_ALIGN_OUT_RIGHT_TOP: lv_align_t = 18;
pub const LV_ALIGN_OUT_RIGHT_MID: lv_align_t = 19;
pub const LV_ALIGN_OUT_RIGHT_BOTTOM: lv_align_t = 20;
#[doc = " Alignments"]
pub type _bindgen_ty_3 = u32;
pub type lv_align_t = u8;
#[repr(C)]
pub struct lv_color16_t {
    pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn green_h(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_h(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green_l(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        green_h: u16,
        red: u16,
        blue: u16,
        green_l: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let green_h: u16 = unsafe { ::core::mem::transmute(green_h) };
            green_h as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let green_l: u16 = unsafe { ::core::mem::transmute(green_l) };
            green_l as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color16_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_color_t = lv_color16_t;
#[doc = "! @cond Doxygen_Suppress"]
pub type lv_opa_t = u8;
#[repr(C)]
pub struct lv_style_t {
    pub map: *mut u8,
}
impl Default for lv_style_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_style_list_t {
    pub style_list: *mut *mut lv_style_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_padding_0: u32,
}
impl Default for lv_style_list_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_style_list_t {
    #[inline]
    pub fn style_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_style_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn has_local(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_local(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_cache(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_cache(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_cache(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_cache(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn radius_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_radius_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opa_scale_cover(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_opa_scale_cover(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clip_corner_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clip_corner_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blend_mode_all_normal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blend_mode_all_normal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_opa_transp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_opa_transp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_opa_cover(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_opa_cover(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_grad_dir_none(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_grad_dir_none(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_side_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_side_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_post_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_post_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outline_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outline_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pattern_img_null(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pattern_img_null(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shadow_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shadow_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn value_txt_str(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_value_txt_str(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn img_recolor_opa_transp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_space_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_space_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_decor_none(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_decor_none(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_font_normal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_font_normal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style_cnt: u32,
        has_local: u32,
        has_trans: u32,
        skip_trans: u32,
        ignore_trans: u32,
        valid_cache: u32,
        ignore_cache: u32,
        radius_zero: u32,
        opa_scale_cover: u32,
        clip_corner_off: u32,
        transform_all_zero: u32,
        pad_all_zero: u32,
        blend_mode_all_normal: u32,
        bg_opa_transp: u32,
        bg_opa_cover: u32,
        bg_grad_dir_none: u32,
        border_width_zero: u32,
        border_side_full: u32,
        border_post_off: u32,
        outline_width_zero: u32,
        pattern_img_null: u32,
        shadow_width_zero: u32,
        value_txt_str: u32,
        img_recolor_opa_transp: u32,
        text_space_zero: u32,
        text_decor_none: u32,
        text_font_normal: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style_cnt: u32 = unsafe { ::core::mem::transmute(style_cnt) };
            style_cnt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_local: u32 = unsafe { ::core::mem::transmute(has_local) };
            has_local as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_trans: u32 = unsafe { ::core::mem::transmute(has_trans) };
            has_trans as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skip_trans: u32 = unsafe { ::core::mem::transmute(skip_trans) };
            skip_trans as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ignore_trans: u32 = unsafe { ::core::mem::transmute(ignore_trans) };
            ignore_trans as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let valid_cache: u32 = unsafe { ::core::mem::transmute(valid_cache) };
            valid_cache as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ignore_cache: u32 = unsafe { ::core::mem::transmute(ignore_cache) };
            ignore_cache as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let radius_zero: u32 = unsafe { ::core::mem::transmute(radius_zero) };
            radius_zero as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let opa_scale_cover: u32 = unsafe { ::core::mem::transmute(opa_scale_cover) };
            opa_scale_cover as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let clip_corner_off: u32 = unsafe { ::core::mem::transmute(clip_corner_off) };
            clip_corner_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let transform_all_zero: u32 = unsafe { ::core::mem::transmute(transform_all_zero) };
            transform_all_zero as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pad_all_zero: u32 = unsafe { ::core::mem::transmute(pad_all_zero) };
            pad_all_zero as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let blend_mode_all_normal: u32 =
                unsafe { ::core::mem::transmute(blend_mode_all_normal) };
            blend_mode_all_normal as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let bg_opa_transp: u32 = unsafe { ::core::mem::transmute(bg_opa_transp) };
            bg_opa_transp as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let bg_opa_cover: u32 = unsafe { ::core::mem::transmute(bg_opa_cover) };
            bg_opa_cover as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let bg_grad_dir_none: u32 = unsafe { ::core::mem::transmute(bg_grad_dir_none) };
            bg_grad_dir_none as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let border_width_zero: u32 = unsafe { ::core::mem::transmute(border_width_zero) };
            border_width_zero as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let border_side_full: u32 = unsafe { ::core::mem::transmute(border_side_full) };
            border_side_full as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let border_post_off: u32 = unsafe { ::core::mem::transmute(border_post_off) };
            border_post_off as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let outline_width_zero: u32 = unsafe { ::core::mem::transmute(outline_width_zero) };
            outline_width_zero as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let pattern_img_null: u32 = unsafe { ::core::mem::transmute(pattern_img_null) };
            pattern_img_null as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let shadow_width_zero: u32 = unsafe { ::core::mem::transmute(shadow_width_zero) };
            shadow_width_zero as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let value_txt_str: u32 = unsafe { ::core::mem::transmute(value_txt_str) };
            value_txt_str as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let img_recolor_opa_transp: u32 =
                unsafe { ::core::mem::transmute(img_recolor_opa_transp) };
            img_recolor_opa_transp as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let text_space_zero: u32 = unsafe { ::core::mem::transmute(text_space_zero) };
            text_space_zero as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let text_decor_none: u32 = unsafe { ::core::mem::transmute(text_decor_none) };
            text_decor_none as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let text_font_normal: u32 = unsafe { ::core::mem::transmute(text_font_normal) };
            text_font_normal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Dummy type to make handling easier"]
pub type lv_ll_node_t = u8;
#[doc = " Description of a linked list"]
#[repr(C)]
pub struct lv_ll_t {
    pub n_size: u32,
    pub head: *mut lv_ll_node_t,
    pub tail: *mut lv_ll_node_t,
}
impl Default for lv_ll_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Tasks execute this type type of functions."]
pub type lv_task_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _lv_task_t {
    #[doc = "< How often the task should run"]
    pub period: u32,
    #[doc = "< Last time the task ran"]
    pub last_run: u32,
    #[doc = "< Task function"]
    pub task_cb: lv_task_cb_t,
    #[doc = "< Custom user data"]
    pub user_data: *mut ::cty::c_void,
    #[doc = "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
    pub repeat_count: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for _lv_task_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_task_t {
    #[inline]
    pub fn prio(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prio: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let prio: u8 = unsafe { ::core::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_task_t = _lv_task_t;
#[doc = " Structure for holding display buffer information."]
#[repr(C)]
pub struct lv_disp_buf_t {
    #[doc = "< First display buffer."]
    pub buf1: *mut ::cty::c_void,
    #[doc = "< Second display buffer."]
    pub buf2: *mut ::cty::c_void,
    pub buf_act: *mut ::cty::c_void,
    pub size: u32,
    pub area: lv_area_t,
    pub flushing: ::cty::c_int,
    pub flushing_last: ::cty::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for lv_disp_buf_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_disp_buf_t {
    #[inline]
    pub fn last_area(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_area(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_part(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_part(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        last_area: u32,
        last_part: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_area: u32 = unsafe { ::core::mem::transmute(last_area) };
            last_area as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let last_part: u32 = unsafe { ::core::mem::transmute(last_part) };
            last_part as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Display Driver structure to be registered by HAL"]
#[repr(C)]
pub struct _disp_drv_t {
    #[doc = "< Horizontal resolution."]
    pub hor_res: lv_coord_t,
    #[doc = "< Vertical resolution."]
    pub ver_res: lv_coord_t,
    #[doc = " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
    #[doc = " LVGL will use this buffer(s) to draw the screens contents"]
    pub buffer: *mut lv_disp_buf_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
    #[doc = " called when finished"]
    pub flush_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            area: *const lv_area_t,
            color_p: *mut lv_color_t,
        ),
    >,
    #[doc = " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
    #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
    pub rounder_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, area: *mut lv_area_t),
    >,
    #[doc = " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
    #[doc = " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
    #[doc = " __Note:__ Much slower then drawing with supported color formats."]
    pub set_px_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            buf: *mut u8,
            buf_w: lv_coord_t,
            x: lv_coord_t,
            y: lv_coord_t,
            color: lv_color_t,
            opa: lv_opa_t,
        ),
    >,
    #[doc = " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
    #[doc = " number of flushed pixels"]
    pub monitor_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, time: u32, px: u32),
    >,
    #[doc = " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
    #[doc = " For example flushing or GPU"]
    #[doc = " User can execute very simple tasks here or yield the task"]
    pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
    pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " OPTIONAL: called to wait while the gpu is working"]
    pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " On CHROMA_KEYED images this color will be transparent."]
    #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
    pub color_chroma_key: lv_color_t,
    #[doc = "< Custom display driver user data"]
    pub user_data: lv_disp_drv_user_data_t,
}
impl Default for _disp_drv_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _disp_drv_t {
    #[inline]
    pub fn antialiasing(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_antialiasing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rotated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_dpi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        antialiasing: u32,
        rotated: u32,
        dpi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialiasing: u32 = unsafe { ::core::mem::transmute(antialiasing) };
            antialiasing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rotated: u32 = unsafe { ::core::mem::transmute(rotated) };
            rotated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let dpi: u32 = unsafe { ::core::mem::transmute(dpi) };
            dpi as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_drv_t = _disp_drv_t;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _disp_t {
    pub driver: lv_disp_drv_t,
    pub refr_task: *mut lv_task_t,
    #[doc = " Screens of the display"]
    pub scr_ll: lv_ll_t,
    #[doc = "< Currently active screen on this display"]
    pub act_scr: *mut _lv_obj_t,
    #[doc = "< Previous screen. Used during screen animations"]
    pub prev_scr: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_top"]
    pub top_layer: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_sys"]
    pub sys_layer: *mut _lv_obj_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Default display color when screens are transparent"]
    pub bg_color: lv_color_t,
    #[doc = "< An image source to display as wallpaper"]
    pub bg_img: *const ::cty::c_void,
    #[doc = "<Opacity of the background color or wallpaper"]
    pub bg_opa: lv_opa_t,
    #[doc = " Invalidated (marked to redraw) areas"]
    pub inv_areas: [lv_area_t; 32usize],
    pub inv_area_joined: [u8; 32usize],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = "< Last time there was activity on this display"]
    pub last_activity_time: u32,
}
impl Default for _disp_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _disp_t {
    #[inline]
    pub fn del_prev(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_del_prev(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(del_prev: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let del_prev: u8 = unsafe { ::core::mem::transmute(del_prev) };
            del_prev as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inv_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_inv_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inv_p: u32) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let inv_p: u32 = unsafe { ::core::mem::transmute(inv_p) };
            inv_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_t = _disp_t;
#[doc = "< Uninitialized state"]
pub const LV_INDEV_TYPE_NONE: _bindgen_ty_16 = 0;
#[doc = "< Touch pad, mouse, external button"]
pub const LV_INDEV_TYPE_POINTER: _bindgen_ty_16 = 1;
#[doc = "< Keypad or keyboard"]
pub const LV_INDEV_TYPE_KEYPAD: _bindgen_ty_16 = 2;
#[doc = "< External (hardware button) which is assigned to a specific point of the"]
#[doc = "screen"]
pub const LV_INDEV_TYPE_BUTTON: _bindgen_ty_16 = 3;
#[doc = "< Encoder with only Left, Right turn and a Button"]
pub const LV_INDEV_TYPE_ENCODER: _bindgen_ty_16 = 4;
#[doc = " Possible input device types"]
pub type _bindgen_ty_16 = u32;
pub type lv_indev_type_t = u8;
pub const LV_INDEV_STATE_REL: _bindgen_ty_17 = 0;
pub const LV_INDEV_STATE_PR: _bindgen_ty_17 = 1;
#[doc = " States for input devices"]
pub type _bindgen_ty_17 = u32;
pub type lv_indev_state_t = u8;
pub type lv_drag_dir_t = u8;
pub type lv_gesture_dir_t = u8;
#[doc = " Data structure passed to an input driver to fill"]
#[repr(C)]
#[derive(Default)]
pub struct lv_indev_data_t {
    #[doc = "< For LV_INDEV_TYPE_POINTER the currently pressed point"]
    pub point: lv_point_t,
    #[doc = "< For LV_INDEV_TYPE_KEYPAD the currently pressed key"]
    pub key: u32,
    #[doc = "< For LV_INDEV_TYPE_BUTTON the currently pressed button"]
    pub btn_id: u32,
    #[doc = "< For LV_INDEV_TYPE_ENCODER number of steps since the previous read"]
    pub enc_diff: i16,
    #[doc = "< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR"]
    pub state: lv_indev_state_t,
}
#[doc = " Initialized by the user and registered by 'lv_indev_add()'"]
#[repr(C)]
pub struct _lv_indev_drv_t {
    pub type_: lv_indev_type_t,
    pub read_cb: ::core::option::Option<
        unsafe extern "C" fn(indev_drv: *mut _lv_indev_drv_t, data: *mut lv_indev_data_t) -> bool,
    >,
    #[doc = " Called when an action happened on the input device."]
    #[doc = " The second parameter is the event from `lv_event_t`"]
    pub feedback_cb:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_indev_drv_t, arg2: u8)>,
    pub user_data: lv_indev_drv_user_data_t,
    pub disp: *mut _disp_t,
    pub read_task: *mut lv_task_t,
    pub drag_limit: u8,
    pub drag_throw: u8,
    pub gesture_min_velocity: u8,
    pub gesture_limit: u8,
    pub long_press_time: u16,
    pub long_press_rep_time: u16,
}
impl Default for _lv_indev_drv_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_indev_drv_t = _lv_indev_drv_t;
#[doc = " Run time data of input devices"]
#[doc = " Internally used by the library, you should not need to touch it."]
#[repr(C)]
pub struct _lv_indev_proc_t {
    #[doc = "< Current state of the input device."]
    pub state: lv_indev_state_t,
    pub types: _lv_indev_proc_t__bindgen_ty_1,
    #[doc = "< Pressed time stamp"]
    pub pr_timestamp: u32,
    #[doc = "< Long press repeat time stamp"]
    pub longpr_rep_timestamp: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
pub struct _lv_indev_proc_t__bindgen_ty_1 {
    pub pointer: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1>,
    pub keypad: __BindgenUnionField<_lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Current point of input device."]
    pub act_point: lv_point_t,
    #[doc = "< Last point of input device."]
    pub last_point: lv_point_t,
    #[doc = "< Difference between `act_point` and `last_point`."]
    pub vect: lv_point_t,
    pub drag_sum: lv_point_t,
    pub drag_throw_vect: lv_point_t,
    pub act_obj: *mut _lv_obj_t,
    pub last_obj: *mut _lv_obj_t,
    pub last_pressed: *mut _lv_obj_t,
    pub gesture_dir: lv_gesture_dir_t,
    pub gesture_sum: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl Default for _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn drag_limit_out(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_limit_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_in_prog(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_in_prog(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gesture_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gesture_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drag_limit_out: u8,
        drag_in_prog: u8,
        drag_dir: lv_drag_dir_t,
        gesture_sent: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drag_limit_out: u8 = unsafe { ::core::mem::transmute(drag_limit_out) };
            drag_limit_out as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag_in_prog: u8 = unsafe { ::core::mem::transmute(drag_in_prog) };
            drag_in_prog as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gesture_sent: u8 = unsafe { ::core::mem::transmute(gesture_sent) };
            gesture_sent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
    pub last_state: lv_indev_state_t,
    pub last_key: u32,
}
impl Default for _lv_indev_proc_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _lv_indev_proc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_indev_proc_t {
    #[inline]
    pub fn long_pr_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_long_pr_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_query(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset_query(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_until_release(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_until_release(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_pr_sent: u8,
        reset_query: u8,
        disabled: u8,
        wait_until_release: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let long_pr_sent: u8 = unsafe { ::core::mem::transmute(long_pr_sent) };
            long_pr_sent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reset_query: u8 = unsafe { ::core::mem::transmute(reset_query) };
            reset_query as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u8 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_until_release: u8 = unsafe { ::core::mem::transmute(wait_until_release) };
            wait_until_release as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_indev_proc_t = _lv_indev_proc_t;
#[repr(C)]
pub struct _lv_group_t {
    _unused: [u8; 0],
}
#[doc = " The main input device descriptor with driver, runtime data ('proc') and some additional"]
#[doc = " information"]
#[repr(C)]
pub struct _lv_indev_t {
    pub driver: lv_indev_drv_t,
    pub proc_: lv_indev_proc_t,
    #[doc = "< Cursor for LV_INPUT_TYPE_POINTER"]
    pub cursor: *mut _lv_obj_t,
    #[doc = "< Keypad destination group"]
    pub group: *mut _lv_group_t,
    #[doc = "< Array points assigned to the button ()screen will be pressed"]
    #[doc = "here by the buttons"]
    pub btn_points: *const lv_point_t,
}
impl Default for _lv_indev_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_indev_t = _lv_indev_t;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize an input device driver with default values."]
    #[doc = " It is used to surly have known values in the fields ant not memory junk."]
    #[doc = " After it you can set the fields."]
    #[doc = " - __`driver`__: pointer to driver variable to initialize"]
    pub fn lv_indev_drv_init(driver: *mut lv_indev_drv_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register an initialized input device driver."]
    #[doc = " - __`driver`__: pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)"]
    #[doc = " Return: pointer to the new input device or NULL on error"]
    pub fn lv_indev_drv_register(driver: *mut lv_indev_drv_t) -> *mut lv_indev_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Update the driver in run time."]
    #[doc = " - __`indev`__: pointer to a input device. (return value of `lv_indev_drv_register`)"]
    #[doc = " - __`new_drv`__: pointer to the new driver"]
    pub fn lv_indev_drv_update(indev: *mut lv_indev_t, new_drv: *mut lv_indev_drv_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the next input device."]
    #[doc = " - __`indev`__: pointer to the current input device. NULL to initialize."]
    #[doc = " Return: the next input devise or NULL if no more. Give the first input device when the parameter"]
    #[doc = " is NULL"]
    pub fn lv_indev_get_next(indev: *mut lv_indev_t) -> *mut lv_indev_t;
}
pub type lv_bidi_dir_t = u8;
pub type lv_design_mode_t = u8;
pub type lv_design_res_t = u8;
#[doc = " The design callback is used to draw the object on the screen."]
#[doc = " It accepts the object, a mask area, and the mode in which to draw the object."]
pub type lv_design_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        clip_area: *const lv_area_t,
        mode: lv_design_mode_t,
    ) -> lv_design_res_t,
>;
pub type lv_event_t = u8;
#[doc = " @brief Event callback."]
#[doc = " Events are used to notify the user of some action being taken on the object."]
#[doc = " For details, see ::lv_event_t."]
pub type lv_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t, event: lv_event_t)>;
pub type lv_signal_t = u8;
pub type lv_signal_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        sign: lv_signal_t,
        param: *mut ::cty::c_void,
    ) -> lv_res_t,
>;
#[repr(C)]
pub struct lv_realign_t {
    pub base: *const _lv_obj_t,
    pub xofs: lv_coord_t,
    pub yofs: lv_coord_t,
    pub align: lv_align_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
impl Default for lv_realign_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_realign_t {
    #[inline]
    pub fn auto_realign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_realign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mid_align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mid_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        auto_realign: u8,
        mid_align: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_realign: u8 = unsafe { ::core::mem::transmute(auto_realign) };
            auto_realign as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mid_align: u8 = unsafe { ::core::mem::transmute(mid_align) };
            mid_align as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_state_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _lv_obj_t {
    #[doc = "< Pointer to the parent object"]
    pub parent: *mut _lv_obj_t,
    #[doc = "< Linked list to store the children objects"]
    pub child_ll: lv_ll_t,
    #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
    pub coords: lv_area_t,
    #[doc = "< Event callback function"]
    pub event_cb: lv_event_cb_t,
    #[doc = "< Object type specific signal function"]
    pub signal_cb: lv_signal_cb_t,
    #[doc = "< Object type specific design function"]
    pub design_cb: lv_design_cb_t,
    #[doc = "< Object type specific extended data"]
    pub ext_attr: *mut ::cty::c_void,
    pub style_list: lv_style_list_t,
    #[doc = "< Extra click padding in horizontal direction"]
    pub ext_click_pad_hor: u8,
    #[doc = "< Extra click padding in vertical direction"]
    pub ext_click_pad_ver: u8,
    #[doc = "< EXTend the size in every direction for drawing."]
    pub ext_draw_pad: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    #[doc = "< Automatically happening actions can be prevented."]
    #[doc = "'OR'ed values from `lv_protect_t`"]
    pub protect: u8,
    pub state: lv_state_t,
    #[doc = "< Information about the last call to ::lv_obj_align."]
    pub realign: lv_realign_t,
    #[doc = "< Custom user data for object."]
    pub user_data: lv_obj_user_data_t,
}
impl Default for _lv_obj_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_obj_t {
    #[inline]
    pub fn click(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_throw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_throw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_top(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parent_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parent_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adv_hittest(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_adv_hittest(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gesture_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gesture_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_focus_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn base_dir(&self) -> lv_bidi_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        click: u8,
        drag: u8,
        drag_throw: u8,
        drag_parent: u8,
        hidden: u8,
        top: u8,
        parent_event: u8,
        adv_hittest: u8,
        gesture_parent: u8,
        focus_parent: u8,
        drag_dir: lv_drag_dir_t,
        base_dir: lv_bidi_dir_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let click: u8 = unsafe { ::core::mem::transmute(click) };
            click as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag: u8 = unsafe { ::core::mem::transmute(drag) };
            drag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_throw: u8 = unsafe { ::core::mem::transmute(drag_throw) };
            drag_throw as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drag_parent: u8 = unsafe { ::core::mem::transmute(drag_parent) };
            drag_parent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hidden: u8 = unsafe { ::core::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let top: u8 = unsafe { ::core::mem::transmute(top) };
            top as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let parent_event: u8 = unsafe { ::core::mem::transmute(parent_event) };
            parent_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let adv_hittest: u8 = unsafe { ::core::mem::transmute(adv_hittest) };
            adv_hittest as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let gesture_parent: u8 = unsafe { ::core::mem::transmute(gesture_parent) };
            gesture_parent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let focus_parent: u8 = unsafe { ::core::mem::transmute(focus_parent) };
            focus_parent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let base_dir: u8 = unsafe { ::core::mem::transmute(base_dir) };
            base_dir as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_obj_t = _lv_obj_t;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the currently processed input device. Can be used in action functions too."]
    #[doc = " Return: pointer to the currently processed input device or NULL if no input device processing"]
    #[doc = " right now"]
    pub fn lv_indev_get_act() -> *mut lv_indev_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the type of an input device"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " Return: the type of the input device from `lv_hal_indev_type_t` (`LV_INDEV_TYPE_...`)"]
    pub fn lv_indev_get_type(indev: *const lv_indev_t) -> lv_indev_type_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset one or all input devices"]
    #[doc = " - __`indev`__: pointer to an input device to reset or NULL to reset all of them"]
    #[doc = " - __`obj`__: pointer to an object which triggers the reset."]
    pub fn lv_indev_reset(indev: *mut lv_indev_t, obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset the long press state of an input device"]
    #[doc = " - __`indev_proc`__: pointer to an input device"]
    pub fn lv_indev_reset_long_press(indev: *mut lv_indev_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable or disable an input devices"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " - __`en`__: true: enable; false: disable"]
    pub fn lv_indev_enable(indev: *mut lv_indev_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON)"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " - __`cur_obj`__: pointer to an object to be used as cursor"]
    pub fn lv_indev_set_cursor(indev: *mut lv_indev_t, cur_obj: *mut lv_obj_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the an array of points for LV_INDEV_TYPE_BUTTON."]
    #[doc = " These points will be assigned to the buttons to press a specific point on the screen"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " - __`group`__: point to a group"]
    pub fn lv_indev_set_button_points(indev: *mut lv_indev_t, points: *const lv_point_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " - __`point`__: pointer to a point to store the result"]
    pub fn lv_indev_get_point(indev: *const lv_indev_t, point: *mut lv_point_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the current gesture direct"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " Return: current gesture direct"]
    pub fn lv_indev_get_gesture_dir(indev: *const lv_indev_t) -> lv_gesture_dir_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD)"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " Return: the last pressed key (0 on error)"]
    pub fn lv_indev_get_key(indev: *const lv_indev_t) -> u32;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check if there is dragging with an input device or not (for LV_INDEV_TYPE_POINTER and"]
    #[doc = " LV_INDEV_TYPE_BUTTON)"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " Return: true: drag is in progress"]
    pub fn lv_indev_is_dragging(indev: *const lv_indev_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the vector of dragging of an input device (for LV_INDEV_TYPE_POINTER and"]
    #[doc = " LV_INDEV_TYPE_BUTTON)"]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " - __`point`__: pointer to a point to store the vector"]
    pub fn lv_indev_get_vect(indev: *const lv_indev_t, point: *mut lv_point_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Manually finish dragging."]
    #[doc = " `LV_SIGNAL_DRAG_END` and `LV_EVENT_DRAG_END` will be sent."]
    #[doc = " - __`indev`__: pointer to an input device"]
    #[doc = " Return: `LV_RES_INV` if the object being dragged was deleted. Else `LV_RES_OK`."]
    pub fn lv_indev_finish_drag(indev: *mut lv_indev_t) -> lv_res_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Do nothing until the next release"]
    #[doc = " - __`indev`__: pointer to an input device"]
    pub fn lv_indev_wait_release(indev: *mut lv_indev_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Gets a pointer to the currently active object in indev proc functions."]
    #[doc = " NULL if no object is currently being handled or if groups aren't used."]
    #[doc = " Return: pointer to currently active object"]
    pub fn lv_indev_get_obj_act() -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Search the most top, clickable object by a point"]
    #[doc = " - __`obj`__: pointer to a start object, typically the screen"]
    #[doc = " - __`point`__: pointer to a point for searching the most top child"]
    #[doc = " Return: pointer to the found object or NULL if there was no suitable object"]
    pub fn lv_indev_search_obj(obj: *mut lv_obj_t, point: *mut lv_point_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get a pointer to the indev read task to"]
    #[doc = " modify its parameters with `lv_task_...` functions."]
    #[doc = " - __`indev`__: pointer to an inout device"]
    #[doc = " Return: pointer to the indev read refresher task. (NULL on error)"]
    pub fn lv_indev_get_read_task(indev: *mut lv_disp_t) -> *mut lv_task_t;
}
