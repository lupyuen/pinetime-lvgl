/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = " Tasks execute this type type of functions."]
pub type lv_task_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
pub const LV_TASK_PRIO_OFF: _bindgen_ty_2 = 0;
pub const LV_TASK_PRIO_LOWEST: _bindgen_ty_2 = 1;
pub const LV_TASK_PRIO_LOW: _bindgen_ty_2 = 2;
pub const LV_TASK_PRIO_MID: _bindgen_ty_2 = 3;
pub const LV_TASK_PRIO_HIGH: _bindgen_ty_2 = 4;
pub const LV_TASK_PRIO_HIGHEST: _bindgen_ty_2 = 5;
pub const _LV_TASK_PRIO_NUM: _bindgen_ty_2 = 6;
#[doc = " Possible priorities for lv_tasks"]
pub type _bindgen_ty_2 = u32;
pub type lv_task_prio_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct _lv_task_t {
    #[doc = "< How often the task should run"]
    pub period: u32,
    #[doc = "< Last time the task ran"]
    pub last_run: u32,
    #[doc = "< Task function"]
    pub task_cb: lv_task_cb_t,
    #[doc = "< Custom user data"]
    pub user_data: *mut ::cty::c_void,
    #[doc = "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
    pub repeat_count: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for _lv_task_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_task_t {
    #[inline]
    pub fn prio(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prio: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let prio: u8 = unsafe { ::core::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_task_t = _lv_task_t;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Call it  periodically to handle lv_tasks."]
    #[doc = " Return: time till it needs to be run next (in ms)"]
    pub fn lv_task_handler() -> u32;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create an \"empty\" task. It needs to initialized with at least"]
    #[doc = " `lv_task_set_cb` and `lv_task_set_period`"]
    #[doc = " Return: pointer to the created task"]
    pub fn lv_task_create_basic() -> *mut lv_task_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create a new lv_task"]
    #[doc = " - __`task_xcb`__: a callback which is the task itself. It will be called periodically."]
    #[doc = "                 (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
    #[doc = "                  the `func_name(object, callback, ...)` convention)"]
    #[doc = " - __`period`__: call period in ms unit"]
    #[doc = " - __`prio`__: priority of the task (LV_TASK_PRIO_OFF means the task is stopped)"]
    #[doc = " - __`user_data`__: custom parameter"]
    #[doc = " Return: pointer to the new task"]
    pub fn lv_task_create(
        task_xcb: lv_task_cb_t,
        period: u32,
        prio: lv_task_prio_t,
        user_data: *mut ::cty::c_void,
    ) -> *mut lv_task_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Delete a lv_task"]
    #[doc = " - __`task`__: pointer to task_cb created by task"]
    pub fn lv_task_del(task: *mut lv_task_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the callback the task (the function to call periodically)"]
    #[doc = " - __`task`__: pointer to a task"]
    #[doc = " - __`task_cb`__: the function to call periodically"]
    pub fn lv_task_set_cb(task: *mut lv_task_t, task_cb: lv_task_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set new priority for a lv_task"]
    #[doc = " - __`task`__: pointer to a lv_task"]
    #[doc = " - __`prio`__: the new priority"]
    pub fn lv_task_set_prio(task: *mut lv_task_t, prio: lv_task_prio_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set new period for a lv_task"]
    #[doc = " - __`task`__: pointer to a lv_task"]
    #[doc = " - __`period`__: the new period"]
    pub fn lv_task_set_period(task: *mut lv_task_t, period: u32);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Make a lv_task ready. It will not wait its period."]
    #[doc = " - __`task`__: pointer to a lv_task."]
    pub fn lv_task_ready(task: *mut lv_task_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the number of times a task will repeat."]
    #[doc = " - __`task`__: pointer to a lv_task."]
    #[doc = " - __`repeat_count`__: -1 : infinity;  0 : stop ;  n>0: residual times"]
    pub fn lv_task_set_repeat_count(task: *mut lv_task_t, repeat_count: i32);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Reset a lv_task."]
    #[doc = " It will be called the previously set period milliseconds later."]
    #[doc = " - __`task`__: pointer to a lv_task."]
    pub fn lv_task_reset(task: *mut lv_task_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable or disable the whole  lv_task handling"]
    #[doc = " - __`en:`__: true: lv_task handling is running, false: lv_task handling is suspended"]
    pub fn lv_task_enable(en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get idle percentage"]
    #[doc = " Return: the lv_task idle in percentage"]
    pub fn lv_task_get_idle() -> u8;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Iterate through the tasks"]
    #[doc = " - __`task`__: NULL to start iteration or the previous return value to get the next task"]
    #[doc = " Return: the next task or NULL if there is no more task"]
    pub fn lv_task_get_next(task: *mut lv_task_t) -> *mut lv_task_t;
}
