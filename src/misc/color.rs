/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const LV_COLOR_DEPTH: u32 = 16;
pub const LV_COLOR_16_SWAP: u32 = 1;
pub const LV_COLOR_SCREEN_TRANSP: u32 = 0;
pub const LV_COLOR_SIZE: u32 = 16;
pub const LV_COLOR_MIX_ROUND_OFS: u32 = 128;
#[doc = "      TYPEDEFS"]
#[repr(C)]
pub struct lv_color1_t {
    pub ch: __BindgenUnionField<lv_color1_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
pub union lv_color1_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    _bindgen_union_align: u8,
}
impl Default for lv_color1_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_color1_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color1_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_color8_t {
    pub ch: __BindgenUnionField<lv_color8_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[repr(C, packed)]
#[derive(Default)]
pub struct lv_color8_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl lv_color8_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color8_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_color16_t {
    pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn green_h(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_h(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green_l(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        green_h: u16,
        red: u16,
        blue: u16,
        green_l: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let green_h: u16 = unsafe { ::core::mem::transmute(green_h) };
            green_h as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let green_l: u16 = unsafe { ::core::mem::transmute(green_l) };
            green_l as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color16_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_color32_t {
    pub ch: __BindgenUnionField<lv_color32_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Default)]
pub struct lv_color32_t__bindgen_ty_1 {
    pub blue: u8,
    pub green: u8,
    pub red: u8,
    pub alpha: u8,
}
impl Default for lv_color32_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_color_int_t = u16;
pub type lv_color_t = lv_color16_t;
#[repr(C)]
#[derive(Default)]
pub struct lv_color_hsv_t {
    pub h: u16,
    pub s: u8,
    pub v: u8,
}
#[doc = "! @cond Doxygen_Suppress"]
pub type lv_opa_t = u8;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " GLOBAL PROTOTYPES"]
    pub fn lv_color_to1(color: lv_color_t) -> u8;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_to8(color: lv_color_t) -> u8;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_to16(color: lv_color_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_to32(color: lv_color_t) -> u32;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Mix two colors with a given ratio."]
    #[doc = " - __`c1`__: the first color to mix (usually the foreground)"]
    #[doc = " - __`c2`__: the second color to mix (usually the background)"]
    #[doc = " - __`mix`__: The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half`c2`"]
    #[doc = " Return: the mixed color"]
    pub fn lv_color_mix(c1: lv_color_t, c2: lv_color_t, mix: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_premult(c: lv_color_t, mix: u8, out: *mut u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Mix two colors with a given ratio. It runs faster then `lv_color_mix` but requires some pre computation."]
    #[doc = " - __`c1`__: The first color. Should be preprocessed with `lv_color_premult(c1)`"]
    #[doc = " - __`c2`__: The second color. As it is no pre computation required on it"]
    #[doc = " - __`mix`__: The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half `c2`."]
    #[doc = "            Should be modified like mix = `255 - mix`"]
    #[doc = " Return: the mixed color"]
    #[doc = " __Note:__ 255 won't give clearly `c1`."]
    pub fn lv_color_mix_premult(premult_c1: *mut u16, c2: lv_color_t, mix: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Mix two colors. Both color can have alpha value. It requires ARGB888 colors."]
    #[doc = " - __`bg_color`__: background color"]
    #[doc = " - __`bg_opa`__: alpha of the background color"]
    #[doc = " - __`fg_color`__: foreground color"]
    #[doc = " - __`fg_opa`__: alpha of the foreground color"]
    #[doc = " - __`res_color`__: the result color"]
    #[doc = " - __`res_opa`__: the result opacity"]
    pub fn lv_color_mix_with_alpha(
        bg_color: lv_color_t,
        bg_opa: lv_opa_t,
        fg_color: lv_color_t,
        fg_opa: lv_opa_t,
        res_color: *mut lv_color_t,
        res_opa: *mut lv_opa_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the brightness of a color"]
    #[doc = " - __`color`__: a color"]
    #[doc = " Return: the brightness [0..255]"]
    pub fn lv_color_brightness(color: lv_color_t) -> u8;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_make(r: u8, g: u8, b: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_hex(c: u32) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_hex3(c: u32) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = "! @cond Doxygen_Suppress"]
    #[doc = "!"]
    pub fn lv_color_fill(buf: *mut lv_color_t, color: lv_color_t, px_num: u32);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = "! @endcond"]
    pub fn lv_color_lighten(c: lv_color_t, lvl: lv_opa_t) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_color_darken(c: lv_color_t, lvl: lv_opa_t) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Convert a HSV color to RGB"]
    #[doc = " - __`h`__: hue [0..359]"]
    #[doc = " - __`s`__: saturation [0..100]"]
    #[doc = " - __`v`__: value [0..100]"]
    #[doc = " Return: the given RGB color in RGB (with LV_COLOR_DEPTH depth)"]
    pub fn lv_color_hsv_to_rgb(h: u16, s: u8, v: u8) -> lv_color_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Convert a 32-bit RGB color to HSV"]
    #[doc = " - __`r8`__: 8-bit red"]
    #[doc = " - __`g8`__: 8-bit green"]
    #[doc = " - __`b8`__: 8-bit blue"]
    #[doc = " Return: the given RGB color in HSV"]
    pub fn lv_color_rgb_to_hsv(r8: u8, g8: u8, b8: u8) -> lv_color_hsv_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Convert a color to HSV"]
    #[doc = " - __`color`__: color"]
    #[doc = " Return: the given color in HSV"]
    pub fn lv_color_to_hsv(color: lv_color_t) -> lv_color_hsv_t;
}
