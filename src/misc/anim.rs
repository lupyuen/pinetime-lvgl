/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LV_ANIM_REPEAT_INFINITE: u32 = 65535;
pub type lv_coord_t = i16;
pub type lv_anim_user_data_t = *mut ::cty::c_void;
pub const LV_ANIM_OFF: _bindgen_ty_2 = 0;
pub const LV_ANIM_ON: _bindgen_ty_2 = 1;
#[doc = " Can be used to indicate if animations are enabled or disabled in a case"]
pub type _bindgen_ty_2 = u32;
pub type lv_anim_enable_t = u8;
#[doc = " Type of the animated value"]
pub type lv_anim_value_t = lv_coord_t;
#[doc = " Get the current value during an animation"]
pub type lv_anim_path_cb_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const _lv_anim_path_t, arg2: *const _lv_anim_t) -> lv_anim_value_t,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_anim_path_t {
    pub cb: lv_anim_path_cb_t,
    pub user_data: *mut ::cty::c_void,
}
impl Default for _lv_anim_path_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_anim_path_t = _lv_anim_path_t;
#[doc = " Generic prototype of \"animator\" functions."]
#[doc = " First parameter is the variable to animate."]
#[doc = " Second parameter is the value to set."]
#[doc = " Compatible with `lv_xxx_set_yyy(obj, value)` functions"]
#[doc = " The `x` in `_xcb_t` means its not a fully generic prototype because"]
#[doc = " it doesn't receive `lv_anim_t *` as its first argument"]
pub type lv_anim_exec_xcb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void, arg2: lv_anim_value_t)>;
#[doc = " Same as `lv_anim_exec_xcb_t` but receives `lv_anim_t *` as the first parameter."]
#[doc = " It's more consistent but less convenient. Might be used by binding generator functions."]
pub type lv_anim_custom_exec_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t, arg2: lv_anim_value_t)>;
#[doc = " Callback to call when the animation is ready"]
pub type lv_anim_ready_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
#[doc = " Callback to call when the animation really stars (considering `delay`)"]
pub type lv_anim_start_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
#[doc = " Describes an animation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_anim_t {
    #[doc = "<Variable to animate"]
    pub var: *mut ::cty::c_void,
    #[doc = "< Function to execute to animate"]
    pub exec_cb: lv_anim_exec_xcb_t,
    #[doc = "< Call it when the animation is starts (considering `delay`)"]
    pub start_cb: lv_anim_start_cb_t,
    #[doc = "< Call it when the animation is ready"]
    pub ready_cb: lv_anim_ready_cb_t,
    #[doc = "< Describe the path (curve) of animations"]
    pub path: lv_anim_path_t,
    #[doc = "< Start value"]
    pub start: i32,
    #[doc = "< Current value"]
    pub current: i32,
    #[doc = "< End value"]
    pub end: i32,
    #[doc = "< Animation time in ms"]
    pub time: i32,
    #[doc = "< Current time in animation. Set to negative to make delay."]
    pub act_time: i32,
    #[doc = "< Wait before play back"]
    pub playback_delay: u32,
    #[doc = "< Duration of playback animation"]
    pub playback_time: u32,
    #[doc = "< Wait before repeat"]
    pub repeat_delay: u32,
    #[doc = "< Repeat count for the animation"]
    pub repeat_cnt: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Custom user data"]
    pub user_data: lv_anim_user_data_t,
    pub time_orig: u32,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for _lv_anim_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_anim_t {
    #[inline]
    pub fn early_apply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_apply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(early_apply: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_apply: u8 = unsafe { ::core::mem::transmute(early_apply) };
            early_apply as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn playback_now(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_playback_now(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_run(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_run(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        playback_now: u8,
        has_run: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let playback_now: u8 = unsafe { ::core::mem::transmute(playback_now) };
            playback_now as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_run: u32 = unsafe { ::core::mem::transmute(has_run) };
            has_run as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_anim_t = _lv_anim_t;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize an animation variable."]
    #[doc = " E.g.:"]
    #[doc = " lv_anim_t a;"]
    #[doc = " lv_anim_init(&a);"]
    #[doc = " lv_anim_set_...(&a);"]
    #[doc = " - __`a`__: pointer to an `lv_anim_t` variable to initialize"]
    pub fn lv_anim_init(a: *mut lv_anim_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a variable to animate"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`var`__: pointer to a variable to animate"]
    pub fn lv_anim_set_var(a: *mut lv_anim_t, var: *mut ::cty::c_void);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a function to animate `var`"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`exec_cb`__: a function to execute during animation"]
    #[doc = "                LittelvGL's built-in functions can be used."]
    #[doc = "                E.g. lv_obj_set_x"]
    pub fn lv_anim_set_exec_cb(a: *mut lv_anim_t, exec_cb: lv_anim_exec_xcb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the duration of an animation"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`duration`__: duration of the animation in milliseconds"]
    pub fn lv_anim_set_time(a: *mut lv_anim_t, duration: u32);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a delay before starting the animation"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`delay`__: delay before the animation in milliseconds"]
    pub fn lv_anim_set_delay(a: *mut lv_anim_t, delay: u32);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the start and end values of an animation"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`start`__: the start value"]
    #[doc = " - __`end`__: the end value"]
    pub fn lv_anim_set_values(a: *mut lv_anim_t, start: lv_anim_value_t, end: lv_anim_value_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Similar to `lv_anim_set_exec_cb` but `lv_anim_custom_exec_cb_t` receives"]
    #[doc = " `lv_anim_t * ` as its first parameter instead of `void *`."]
    #[doc = " This function might be used when LVGL is binded to other languages because"]
    #[doc = " it's more consistent to have `lv_anim_t *` as first parameter."]
    #[doc = " The variable to animate can be stored in the animation's `user_sata`"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`exec_cb`__: a function to execute."]
    pub fn lv_anim_set_custom_exec_cb(a: *mut lv_anim_t, exec_cb: lv_anim_custom_exec_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the path (curve) of the animation."]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`path_cb`__: a function the get the current value of the animation."]
    #[doc = "                The built in functions starts with `lv_anim_path_...`"]
    pub fn lv_anim_set_path(a: *mut lv_anim_t, path: *const lv_anim_path_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a function call when the animation really starts (considering `delay`)"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`start_cb`__: a function call when the animation starts"]
    pub fn lv_anim_set_start_cb(a: *mut lv_anim_t, start_cb: lv_anim_ready_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a function call when the animation is ready"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`ready_cb`__: a function call when the animation is ready"]
    pub fn lv_anim_set_ready_cb(a: *mut lv_anim_t, ready_cb: lv_anim_ready_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Make the animation to play back to when the forward direction is ready"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`time`__: the duration of the playback animation in in milliseconds. 0: disable playback"]
    pub fn lv_anim_set_playback_time(a: *mut lv_anim_t, time: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Make the animation to play back to when the forward direction is ready"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`delay`__: delay in milliseconds before starting the playback animation."]
    pub fn lv_anim_set_playback_delay(a: *mut lv_anim_t, delay: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Make the animation repeat itself."]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`cnt`__: repeat count or `LV_ANIM_REPEAT_INFINITE` for infinite repetition. 0: to disable repetition."]
    pub fn lv_anim_set_repeat_count(a: *mut lv_anim_t, cnt: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a delay before repeating the animation."]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " - __`delay`__: delay in milliseconds before repeating the animation."]
    pub fn lv_anim_set_repeat_delay(a: *mut lv_anim_t, delay: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create an animation"]
    #[doc = " - __`a`__: an initialized 'anim_t' variable. Not required after call."]
    pub fn lv_anim_start(a: *mut lv_anim_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize an animation path"]
    #[doc = " - __`path`__: pointer to path"]
    pub fn lv_anim_path_init(path: *mut lv_anim_path_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a callback for a path"]
    #[doc = " - __`path`__: pointer to an initialized path"]
    #[doc = " - __`cb`__: the callback"]
    pub fn lv_anim_path_set_cb(path: *mut lv_anim_path_t, cb: lv_anim_path_cb_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a user data for a path"]
    #[doc = " - __`path`__: pointer to an initialized path"]
    #[doc = " - __`user_data`__: pointer to the user data"]
    pub fn lv_anim_path_set_user_data(path: *mut lv_anim_path_t, user_data: *mut ::cty::c_void);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get a delay before starting the animation"]
    #[doc = " - __`a`__: pointer to an initialized `lv_anim_t` variable"]
    #[doc = " Return: delay before the animation in milliseconds"]
    pub fn lv_anim_get_delay(a: *mut lv_anim_t) -> i32;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Delete an animation of a variable with a given animator function"]
    #[doc = " - __`var`__: pointer to variable"]
    #[doc = " - __`exec_cb`__: a function pointer which is animating 'var',"]
    #[doc = "           or NULL to ignore it and delete all the animations of 'var"]
    #[doc = " Return: true: at least 1 animation is deleted, false: no animation is deleted"]
    pub fn lv_anim_del(var: *mut ::cty::c_void, exec_cb: lv_anim_exec_xcb_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the animation of a variable and its `exec_cb`."]
    #[doc = " - __`var`__: pointer to variable"]
    #[doc = " - __`exec_cb`__: a function pointer which is animating 'var',"]
    #[doc = "           or NULL to delete all the animations of 'var'"]
    #[doc = " Return: pointer to the animation."]
    pub fn lv_anim_get(var: *mut ::cty::c_void, exec_cb: lv_anim_exec_xcb_t) -> *mut lv_anim_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Delete an animation by getting the animated variable from `a`."]
    #[doc = " Only animations with `exec_cb` will be deleted."]
    #[doc = " This function exists because it's logical that all anim. functions receives an"]
    #[doc = " `lv_anim_t` as their first parameter. It's not practical in C but might make"]
    #[doc = " the API more consequent and makes easier to generate bindings."]
    #[doc = " - __`a`__: pointer to an animation."]
    #[doc = " - __`exec_cb`__: a function pointer which is animating 'var',"]
    #[doc = "           or NULL to ignore it and delete all the animations of 'var"]
    #[doc = " Return: true: at least 1 animation is deleted, false: no animation is deleted"]
    pub fn lv_anim_custom_del(a: *mut lv_anim_t, exec_cb: lv_anim_custom_exec_cb_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the number of currently running animations"]
    #[doc = " Return: the number of running animations"]
    pub fn lv_anim_count_running() -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the time of an animation with a given speed and the start and end values"]
    #[doc = " - __`speed`__: speed of animation in unit/sec"]
    #[doc = " - __`start`__: start value of the animation"]
    #[doc = " - __`end`__: end value of the animation"]
    #[doc = " Return: the required time [ms] for the animation with the given parameters"]
    pub fn lv_anim_speed_to_time(speed: u16, start: lv_anim_value_t, end: lv_anim_value_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Manually refresh the state of the animations."]
    #[doc = " Useful to make the animations running in a blocking process where"]
    #[doc = " `lv_task_handler` can't run for a while."]
    #[doc = " Shouldn't be used directly because it is called in `lv_refr_now()`."]
    pub fn lv_anim_refr_now();
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation applying linear characteristic"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_linear(path: *const lv_anim_path_t, a: *const lv_anim_t)
        -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation slowing down the start phase"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_ease_in(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation slowing down the end phase"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_ease_out(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation applying an \"S\" characteristic (cosine)"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_ease_in_out(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation with overshoot at the end"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_overshoot(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation with 3 bounces"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_bounce(path: *const lv_anim_path_t, a: *const lv_anim_t)
        -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Calculate the current value of an animation applying step characteristic."]
    #[doc = " (Set end value on the end of the animation)"]
    #[doc = " - __`a`__: pointer to an animation"]
    #[doc = " Return: the current value to set"]
    pub fn lv_anim_path_step(path: *const lv_anim_path_t, a: *const lv_anim_t) -> lv_anim_value_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub static lv_anim_path_def: lv_anim_path_t;
}
