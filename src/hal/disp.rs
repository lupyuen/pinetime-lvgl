/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LV_DISP_DEF_REFR_PERIOD: u32 = 30;
pub const LV_DISP_SMALL_LIMIT: u32 = 30;
pub const LV_DISP_MEDIUM_LIMIT: u32 = 50;
pub const LV_DISP_LARGE_LIMIT: u32 = 70;
pub type lv_coord_t = i16;
pub type lv_disp_drv_user_data_t = *mut ::cty::c_void;
#[doc = " Represents an area of the screen."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
#[doc = " Dummy type to make handling easier"]
pub type lv_ll_node_t = u8;
#[doc = " Description of a linked list"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_ll_t {
    pub n_size: u32,
    pub head: *mut lv_ll_node_t,
    pub tail: *mut lv_ll_node_t,
}
impl Default for lv_ll_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Tasks execute this type type of functions."]
pub type lv_task_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_task_t {
    #[doc = "< How often the task should run"]
    pub period: u32,
    #[doc = "< Last time the task ran"]
    pub last_run: u32,
    #[doc = "< Task function"]
    pub task_cb: lv_task_cb_t,
    #[doc = "< Custom user data"]
    pub user_data: *mut ::cty::c_void,
    #[doc = "< 1: Task times;  -1 : infinity;  0 : stop ;  n>0: residual times"]
    pub repeat_count: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for _lv_task_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_task_t {
    #[inline]
    pub fn prio(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prio: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let prio: u8 = unsafe { ::core::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_task_t = _lv_task_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color16_t {
    pub ch: lv_color16_t__bindgen_ty_1,
    pub full: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default, Copy, Clone)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn green_h(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_h(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green_l(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        green_h: u16,
        red: u16,
        blue: u16,
        green_l: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let green_h: u16 = unsafe { ::core::mem::transmute(green_h) };
            green_h as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let green_l: u16 = unsafe { ::core::mem::transmute(green_l) };
            green_l as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color16_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_color_t = lv_color16_t;
#[doc = "! @cond Doxygen_Suppress"]
pub type lv_opa_t = u8;
#[doc = " Structure for holding display buffer information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_disp_buf_t {
    #[doc = "< First display buffer."]
    pub buf1: *mut ::cty::c_void,
    #[doc = "< Second display buffer."]
    pub buf2: *mut ::cty::c_void,
    pub buf_act: *mut ::cty::c_void,
    pub size: u32,
    pub area: lv_area_t,
    pub flushing: ::cty::c_int,
    pub flushing_last: ::cty::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for lv_disp_buf_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_disp_buf_t {
    #[inline]
    pub fn last_area(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_area(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_part(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_part(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        last_area: u32,
        last_part: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_area: u32 = unsafe { ::core::mem::transmute(last_area) };
            last_area as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let last_part: u32 = unsafe { ::core::mem::transmute(last_part) };
            last_part as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Display Driver structure to be registered by HAL"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _disp_drv_t {
    #[doc = "< Horizontal resolution."]
    pub hor_res: lv_coord_t,
    #[doc = "< Vertical resolution."]
    pub ver_res: lv_coord_t,
    #[doc = " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
    #[doc = " LVGL will use this buffer(s) to draw the screens contents"]
    pub buffer: *mut lv_disp_buf_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
    #[doc = " called when finished"]
    pub flush_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            area: *const lv_area_t,
            color_p: *mut lv_color_t,
        ),
    >,
    #[doc = " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
    #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
    pub rounder_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, area: *mut lv_area_t),
    >,
    #[doc = " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
    #[doc = " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
    #[doc = " __Note:__ Much slower then drawing with supported color formats."]
    pub set_px_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            buf: *mut u8,
            buf_w: lv_coord_t,
            x: lv_coord_t,
            y: lv_coord_t,
            color: lv_color_t,
            opa: lv_opa_t,
        ),
    >,
    #[doc = " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
    #[doc = " number of flushed pixels"]
    pub monitor_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, time: u32, px: u32),
    >,
    #[doc = " OPTIONAL: Called periodically while lvgl waits for operation to be completed."]
    #[doc = " For example flushing or GPU"]
    #[doc = " User can execute very simple tasks here or yield the task"]
    pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " OPTIONAL: Called when lvgl needs any CPU cache that affects rendering to be cleaned"]
    pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " OPTIONAL: called to wait while the gpu is working"]
    pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    #[doc = " On CHROMA_KEYED images this color will be transparent."]
    #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
    pub color_chroma_key: lv_color_t,
    #[doc = "< Custom display driver user data"]
    pub user_data: lv_disp_drv_user_data_t,
}
impl Default for _disp_drv_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _disp_drv_t {
    #[inline]
    pub fn antialiasing(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_antialiasing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rotated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_dpi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        antialiasing: u32,
        rotated: u32,
        dpi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialiasing: u32 = unsafe { ::core::mem::transmute(antialiasing) };
            antialiasing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rotated: u32 = unsafe { ::core::mem::transmute(rotated) };
            rotated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let dpi: u32 = unsafe { ::core::mem::transmute(dpi) };
            dpi as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_drv_t = _disp_drv_t;
#[doc = " Display structure."]
#[doc = " __Note:__ `lv_disp_drv_t` should be the first member of the structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _disp_t {
    pub driver: lv_disp_drv_t,
    pub refr_task: *mut lv_task_t,
    #[doc = " Screens of the display"]
    pub scr_ll: lv_ll_t,
    #[doc = "< Currently active screen on this display"]
    pub act_scr: *mut _lv_obj_t,
    #[doc = "< Previous screen. Used during screen animations"]
    pub prev_scr: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_top"]
    pub top_layer: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_sys"]
    pub sys_layer: *mut _lv_obj_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Default display color when screens are transparent"]
    pub bg_color: lv_color_t,
    #[doc = "< An image source to display as wallpaper"]
    pub bg_img: *const ::cty::c_void,
    #[doc = "<Opacity of the background color or wallpaper"]
    pub bg_opa: lv_opa_t,
    #[doc = " Invalidated (marked to redraw) areas"]
    pub inv_areas: [lv_area_t; 32usize],
    pub inv_area_joined: [u8; 32usize],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = "< Last time there was activity on this display"]
    pub last_activity_time: u32,
}
impl Default for _disp_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _disp_t {
    #[inline]
    pub fn del_prev(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_del_prev(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(del_prev: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let del_prev: u8 = unsafe { ::core::mem::transmute(del_prev) };
            del_prev as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inv_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_inv_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inv_p: u32) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let inv_p: u32 = unsafe { ::core::mem::transmute(inv_p) };
            inv_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_t = _disp_t;
pub const lv_disp_size_t_LV_DISP_SIZE_SMALL: lv_disp_size_t = 0;
pub const lv_disp_size_t_LV_DISP_SIZE_MEDIUM: lv_disp_size_t = 1;
pub const lv_disp_size_t_LV_DISP_SIZE_LARGE: lv_disp_size_t = 2;
pub const lv_disp_size_t_LV_DISP_SIZE_EXTRA_LARGE: lv_disp_size_t = 3;
pub type lv_disp_size_t = u32;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a display driver with default values."]
    #[doc = " It is used to have known values in the fields and not junk in memory."]
    #[doc = " After it you can safely set only the fields you need."]
    #[doc = " - __`driver`__: pointer to driver variable to initialize"]
    pub fn lv_disp_drv_init(driver: *mut lv_disp_drv_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a display buffer"]
    #[doc = " - __`disp_buf`__: pointer `lv_disp_buf_t` variable to initialize"]
    #[doc = " - __`buf1`__: A buffer to be used by LVGL to draw the image."]
    #[doc = "             Always has to specified and can't be NULL."]
    #[doc = "             Can be an array allocated by the user. E.g. `static lv_color_t disp_buf1[1024 * 10]`"]
    #[doc = "             Or a memory address e.g. in external SRAM"]
    #[doc = " - __`buf2`__: Optionally specify a second buffer to make image rendering and image flushing"]
    #[doc = "             (sending to the display) parallel."]
    #[doc = "             In the `disp_drv->flush` you should use DMA or similar hardware to send"]
    #[doc = "             the image to the display in the background."]
    #[doc = "             It lets LVGL to render next frame into the other buffer while previous is being"]
    #[doc = " sent. Set to `NULL` if unused."]
    #[doc = " - __`size_in_px_cnt`__: size of the `buf1` and `buf2` in pixel count."]
    pub fn lv_disp_buf_init(
        disp_buf: *mut lv_disp_buf_t,
        buf1: *mut ::cty::c_void,
        buf2: *mut ::cty::c_void,
        size_in_px_cnt: u32,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Register an initialized display driver."]
    #[doc = " Automatically set the first display as active."]
    #[doc = " - __`driver`__: pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)"]
    #[doc = " Return: pointer to the new display or NULL on error"]
    pub fn lv_disp_drv_register(driver: *mut lv_disp_drv_t) -> *mut lv_disp_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Update the driver in run time."]
    #[doc = " - __`disp`__: pointer to a display. (return value of `lv_disp_drv_register`)"]
    #[doc = " - __`new_drv`__: pointer to the new driver"]
    pub fn lv_disp_drv_update(disp: *mut lv_disp_t, new_drv: *mut lv_disp_drv_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove a display"]
    #[doc = " - __`disp`__: pointer to display"]
    pub fn lv_disp_remove(disp: *mut lv_disp_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a default screen. The new screens will be created on it by default."]
    #[doc = " - __`disp`__: pointer to a display"]
    pub fn lv_disp_set_default(disp: *mut lv_disp_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the default display"]
    #[doc = " Return: pointer to the default display"]
    pub fn lv_disp_get_default() -> *mut lv_disp_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the horizontal resolution of a display"]
    #[doc = " - __`disp`__: pointer to a display (NULL to use the default display)"]
    #[doc = " Return: the horizontal resolution of the display"]
    pub fn lv_disp_get_hor_res(disp: *mut lv_disp_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the vertical resolution of a display"]
    #[doc = " - __`disp`__: pointer to a display (NULL to use the default display)"]
    #[doc = " Return: the vertical resolution of the display"]
    pub fn lv_disp_get_ver_res(disp: *mut lv_disp_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get if anti-aliasing is enabled for a display or not"]
    #[doc = " - __`disp`__: pointer to a display (NULL to use the default display)"]
    #[doc = " Return: true: anti-aliasing is enabled; false: disabled"]
    pub fn lv_disp_get_antialiasing(disp: *mut lv_disp_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the DPI of the display"]
    #[doc = " - __`disp`__: pointer to a display (NULL to use the default display)"]
    #[doc = " Return: dpi of the display"]
    pub fn lv_disp_get_dpi(disp: *mut lv_disp_t) -> lv_coord_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the size category of the display based on it's hor. res. and dpi."]
    #[doc = " - __`disp`__: pointer to a display (NULL to use the default display)"]
    #[doc = " Return: LV_DISP_SIZE_SMALL/MEDIUM/LARGE/EXTRA_LARGE"]
    pub fn lv_disp_get_size_category(disp: *mut lv_disp_t) -> lv_disp_size_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Call in the display driver's `flush_cb` function when the flushing is finished"]
    #[doc = " - __`disp_drv`__: pointer to display driver in `flush_cb` where this function is called"]
    pub fn lv_disp_flush_ready(disp_drv: *mut lv_disp_drv_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Tell if it's the last area of the refreshing process."]
    #[doc = " Can be called from `flush_cb` to execute some special display refreshing if needed when all areas area flushed."]
    #[doc = " - __`disp_drv`__: pointer to display driver"]
    #[doc = " Return: true: it's the last area to flush; false: there are other areas too which will be refreshed soon"]
    pub fn lv_disp_flush_is_last(disp_drv: *mut lv_disp_drv_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the next display."]
    #[doc = " - __`disp`__: pointer to the current display. NULL to initialize."]
    #[doc = " Return: the next display or NULL if no more. Give the first display when the parameter is NULL"]
    pub fn lv_disp_get_next(disp: *mut lv_disp_t) -> *mut lv_disp_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the internal buffer of a display"]
    #[doc = " - __`disp`__: pointer to a display"]
    #[doc = " Return: pointer to the internal buffers"]
    pub fn lv_disp_get_buf(disp: *mut lv_disp_t) -> *mut lv_disp_buf_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the number of areas in the buffer"]
    #[doc = " Return: number of invalid areas"]
    pub fn lv_disp_get_inv_buf_size(disp: *mut lv_disp_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)"]
    #[doc = " - __`disp`__: pointer to to display to check"]
    #[doc = " Return: true: double buffered; false: not double buffered"]
    pub fn lv_disp_is_double_buf(disp: *mut lv_disp_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check the driver configuration if it's TRUE double buffered (both `buf1` and `buf2` are set and"]
    #[doc = " `size` is screen sized)"]
    #[doc = " - __`disp`__: pointer to to display to check"]
    #[doc = " Return: true: double buffered; false: not double buffered"]
    pub fn lv_disp_is_true_double_buf(disp: *mut lv_disp_t) -> bool;
}
