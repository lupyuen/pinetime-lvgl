/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const LV_LABEL_DEF_SCROLL_SPEED: u32 = 25;
pub const LV_LABEL_WAIT_CHAR_COUNT: u32 = 3;
pub const LV_LABEL_TEXT_SEL: u32 = 0;
pub const LV_LABEL_LONG_TXT_HINT: u32 = 0;
pub const LV_LABEL_DOT_NUM: u32 = 3;
pub const LV_LABEL_POS_LAST: u32 = 65535;
pub const LV_LABEL_TEXT_SEL_OFF: u32 = 65535;
pub type lv_coord_t = i16;
pub type lv_font_user_data_t = *mut ::cty::c_void;
pub type lv_obj_user_data_t = *mut ::cty::c_void;
#[doc = " Describes the properties of a glyph."]
#[repr(C)]
#[derive(Default)]
pub struct lv_font_glyph_dsc_t {
    #[doc = "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
    pub adv_w: u16,
    #[doc = "< Width of the glyph's bounding box"]
    pub box_w: u8,
    #[doc = "< Height of the glyph's bounding box"]
    pub box_h: u8,
    #[doc = "< x offset of the bounding box"]
    pub ofs_x: i8,
    #[doc = "< y offset of the bounding box"]
    pub ofs_y: i8,
    #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
    pub bpp: u8,
}
#[doc = " Describe the properties of a font"]
#[repr(C)]
pub struct _lv_font_struct {
    #[doc = " Get a glyph's  descriptor from a font"]
    pub get_glyph_dsc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const _lv_font_struct,
            arg2: *mut lv_font_glyph_dsc_t,
            letter: u32,
            letter_next: u32,
        ) -> bool,
    >,
    #[doc = " Get a glyph's bitmap from a font"]
    pub get_glyph_bitmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const _lv_font_struct, arg2: u32) -> *const u8,
    >,
    #[doc = "< The real line height where any text fits"]
    pub line_height: u8,
    #[doc = "< Base line measured from the top of the line_height"]
    pub base_line: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Store implementation specific or run_time data or caching here"]
    pub dsc: *mut ::cty::c_void,
    #[doc = "< Custom user data for font."]
    pub user_data: lv_font_user_data_t,
}
impl Default for _lv_font_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_font_struct {
    #[inline]
    pub fn subpx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_subpx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subpx: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let subpx: u8 = unsafe { ::core::mem::transmute(subpx) };
            subpx as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_font_t = _lv_font_struct;
#[repr(C)]
pub struct lv_color16_t {
    pub ch: __BindgenUnionField<lv_color16_t__bindgen_ty_1>,
    pub full: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn green_h(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_h(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green_l(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        green_h: u16,
        red: u16,
        blue: u16,
        green_l: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let green_h: u16 = unsafe { ::core::mem::transmute(green_h) };
            green_h as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let green_l: u16 = unsafe { ::core::mem::transmute(green_l) };
            green_l as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color16_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_color_t = lv_color16_t;
pub type lv_opa_t = u8;
#[doc = " Represents a point on the screen."]
#[repr(C)]
#[derive(Default)]
pub struct lv_point_t {
    pub x: lv_coord_t,
    pub y: lv_coord_t,
}
#[doc = " Represents an area of the screen."]
#[repr(C)]
#[derive(Default)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
pub type lv_border_part_t = u8;
pub type lv_shadow_type_t = u8;
#[doc = " Object background."]
#[repr(C)]
pub struct lv_style_t__bindgen_ty_1 {
    #[doc = "< Object's main background color."]
    pub main_color: lv_color_t,
    #[doc = "< Second color. If not equal to `main_color` a gradient will be drawn for the background."]
    pub grad_color: lv_color_t,
    #[doc = "< Object's corner radius. You can use #LV_RADIUS_CIRCLE if you want to draw a circle."]
    pub radius: lv_coord_t,
    #[doc = "< Object's opacity (0-255)."]
    pub opa: lv_opa_t,
    pub border: lv_style_t__bindgen_ty_1__bindgen_ty_1,
    pub shadow: lv_style_t__bindgen_ty_1__bindgen_ty_2,
    pub padding: lv_style_t__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
pub struct lv_style_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Border color"]
    pub color: lv_color_t,
    #[doc = "< Border width"]
    pub width: lv_coord_t,
    #[doc = "< Which borders to draw"]
    pub part: lv_border_part_t,
    #[doc = "< Border opacity."]
    pub opa: lv_opa_t,
}
impl Default for lv_style_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_style_t__bindgen_ty_1__bindgen_ty_2 {
    pub color: lv_color_t,
    pub width: lv_coord_t,
    #[doc = "< Which parts of the shadow to draw"]
    pub type_: lv_shadow_type_t,
}
impl Default for lv_style_t__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct lv_style_t__bindgen_ty_1__bindgen_ty_3 {
    pub top: lv_coord_t,
    pub bottom: lv_coord_t,
    pub left: lv_coord_t,
    pub right: lv_coord_t,
    pub inner: lv_coord_t,
}
impl Default for lv_style_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Style for text drawn by this object."]
#[repr(C)]
pub struct lv_style_t__bindgen_ty_2 {
    #[doc = "< Text color"]
    pub color: lv_color_t,
    #[doc = "< Text selection background color."]
    pub sel_color: lv_color_t,
    pub font: *const lv_font_t,
    #[doc = "< Space between letters"]
    pub letter_space: lv_coord_t,
    #[doc = "< Space between lines (vertical)"]
    pub line_space: lv_coord_t,
    #[doc = "< Text opacity"]
    pub opa: lv_opa_t,
}
impl Default for lv_style_t__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_style_t__bindgen_ty_3 {
    #[doc = "< Color to recolor the image with"]
    pub color: lv_color_t,
    #[doc = "< Opacity of recoloring (0 means no recoloring)"]
    pub intense: lv_opa_t,
    #[doc = "< Opacity of whole image"]
    pub opa: lv_opa_t,
}
impl Default for lv_style_t__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct lv_style_t__bindgen_ty_4 {
    pub color: lv_color_t,
    pub width: lv_coord_t,
    pub opa: lv_opa_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl Default for lv_style_t__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_style_t__bindgen_ty_4 {
    #[inline]
    pub fn rounded(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rounded(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rounded: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rounded: u8 = unsafe { ::core::mem::transmute(rounded) };
            rounded as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_res_t = u8;
#[doc = " Dummy type to make handling easier"]
pub type lv_ll_node_t = u8;
#[doc = " Description of a linked list"]
#[repr(C)]
pub struct lv_ll_t {
    pub n_size: u32,
    pub head: *mut lv_ll_node_t,
    pub tail: *mut lv_ll_node_t,
}
impl Default for lv_ll_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_bidi_dir_t = u8;
pub type lv_design_mode_t = u8;
#[doc = " The design callback is used to draw the object on the screen."]
#[doc = " It accepts the object, a mask area, and the mode in which to draw the object."]
pub type lv_design_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        mask_p: *const lv_area_t,
        mode: lv_design_mode_t,
    ) -> bool,
>;
pub type lv_event_t = u8;
#[doc = " @brief Event callback."]
#[doc = " Events are used to notify the user of some action being taken on the object."]
#[doc = " For details, see ::lv_event_t."]
pub type lv_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t, event: lv_event_t)>;
pub type lv_signal_t = u8;
pub type lv_signal_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        sign: lv_signal_t,
        param: *mut ::cty::c_void,
    ) -> lv_res_t,
>;
pub type lv_align_t = u8;
#[repr(C)]
pub struct lv_reailgn_t {
    pub base: *const _lv_obj_t,
    pub xofs: lv_coord_t,
    pub yofs: lv_coord_t,
    pub align: lv_align_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
impl Default for lv_reailgn_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_reailgn_t {
    #[inline]
    pub fn auto_realign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_realign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn origo_align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_origo_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        auto_realign: u8,
        origo_align: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_realign: u8 = unsafe { ::core::mem::transmute(auto_realign) };
            auto_realign as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let origo_align: u8 = unsafe { ::core::mem::transmute(origo_align) };
            origo_align as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_drag_dir_t = u8;
pub type lv_obj_t = _lv_obj_t;
#[doc = "< Expand the object size to the text size"]
pub const LV_LABEL_LONG_EXPAND: _bindgen_ty_22 = 0;
#[doc = "< Keep the object width, break the too long lines and expand the object"]
#[doc = "height"]
pub const LV_LABEL_LONG_BREAK: _bindgen_ty_22 = 1;
#[doc = "< Keep the size and write dots at the end if the text is too long"]
pub const LV_LABEL_LONG_DOT: _bindgen_ty_22 = 2;
#[doc = "< Keep the size and roll the text back and forth"]
pub const LV_LABEL_LONG_SROLL: _bindgen_ty_22 = 3;
#[doc = "< Keep the size and roll the text circularly"]
pub const LV_LABEL_LONG_SROLL_CIRC: _bindgen_ty_22 = 4;
#[doc = "< Keep the size and crop the text out of it"]
pub const LV_LABEL_LONG_CROP: _bindgen_ty_22 = 5;
#[doc = " Long mode behaviors. Used in 'lv_label_ext_t'"]
pub type _bindgen_ty_22 = u8;
pub type lv_label_long_mode_t = u8;
#[doc = "< Align text to left"]
pub const LV_LABEL_ALIGN_LEFT: _bindgen_ty_23 = 0;
#[doc = "< Align text to center"]
pub const LV_LABEL_ALIGN_CENTER: _bindgen_ty_23 = 1;
#[doc = "< Align text to right"]
pub const LV_LABEL_ALIGN_RIGHT: _bindgen_ty_23 = 2;
#[doc = "< Use LEFT or RIGHT depending on the direction of the text (LTR/RTL)"]
pub const LV_LABEL_ALIGN_AUTO: _bindgen_ty_23 = 3;
#[doc = " Label align policy"]
pub type _bindgen_ty_23 = u8;
pub type lv_label_align_t = u8;
#[doc = " Data of label"]
#[repr(C)]
pub struct lv_label_ext_t {
    pub text: *mut ::cty::c_char,
    pub dot: lv_label_ext_t__bindgen_ty_1,
    pub dot_end: u16,
    pub offset: lv_point_t,
    pub anim_speed: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[repr(C)]
pub struct lv_label_ext_t__bindgen_ty_1 {
    pub tmp_ptr: __BindgenUnionField<*mut ::cty::c_char>,
    pub tmp: __BindgenUnionField<[::cty::c_char; 4usize]>,
    pub bindgen_union_field: u64,
}
impl Default for lv_label_ext_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for lv_label_ext_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_label_ext_t {
    #[inline]
    pub fn long_mode(&self) -> lv_label_long_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_long_mode(&mut self, val: lv_label_long_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn static_txt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_static_txt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn recolor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recolor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expand(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_expand(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn body_draw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_body_draw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dot_tmp_alloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dot_tmp_alloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_mode: lv_label_long_mode_t,
        static_txt: u8,
        align: u8,
        recolor: u8,
        expand: u8,
        body_draw: u8,
        dot_tmp_alloc: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let long_mode: u8 = unsafe { ::core::mem::transmute(long_mode) };
            long_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let static_txt: u8 = unsafe { ::core::mem::transmute(static_txt) };
            static_txt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let align: u8 = unsafe { ::core::mem::transmute(align) };
            align as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let recolor: u8 = unsafe { ::core::mem::transmute(recolor) };
            recolor as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let expand: u8 = unsafe { ::core::mem::transmute(expand) };
            expand as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let body_draw: u8 = unsafe { ::core::mem::transmute(body_draw) };
            body_draw as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dot_tmp_alloc: u8 = unsafe { ::core::mem::transmute(dot_tmp_alloc) };
            dot_tmp_alloc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LABEL_STYLE_MAIN: _bindgen_ty_24 = 0;
#[doc = " Label styles"]
pub type _bindgen_ty_24 = u8;
pub type lv_label_style_t = u8;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Create a label objects"]
    #[doc = " - __`par`__: pointer to an object, it will be the parent of the new label"]
    #[doc = " - __`copy`__: pointer to a button object, if not NULL then the new object will be copied from it"]
    #[doc = " Return: pointer to the created button"]
    pub fn lv_label_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a new text for a label. Memory will be allocated to store the text by the label."]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`text`__: '\\0' terminated character string. NULL to refresh with the current text."]
    pub fn lv_label_set_text(label: *mut lv_obj_t, text: *const ::cty::c_char);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a new formatted text for a label. Memory will be allocated to store the text by the label."]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`fmt`__: `printf`-like format"]
    pub fn lv_label_set_text_fmt(label: *mut lv_obj_t, fmt: *const ::cty::c_char, ...);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a new text for a label from a character array. The array don't has to be '\\0' terminated."]
    #[doc = " Memory will be allocated to store the array by the label."]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`array`__: array of characters or NULL to refresh the label"]
    #[doc = " - __`size`__: the size of 'array' in bytes"]
    pub fn lv_label_set_array_text(label: *mut lv_obj_t, array: *const ::cty::c_char, size: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set a static text. It will not be saved by the label so the 'text' variable"]
    #[doc = " has to be 'alive' while the label exist."]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`text`__: pointer to a text. NULL to refresh with the current text."]
    pub fn lv_label_set_static_text(label: *mut lv_obj_t, text: *const ::cty::c_char);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the behavior of the label with longer text then the object size"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`long_mode`__: the new mode from 'lv_label_long_mode' enum."]
    #[doc = "                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this"]
    #[doc = " function"]
    pub fn lv_label_set_long_mode(label: *mut lv_obj_t, long_mode: lv_label_long_mode_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the align of the label (left or center)"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`align`__: 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'"]
    pub fn lv_label_set_align(label: *mut lv_obj_t, align: lv_label_align_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Enable the recoloring by in-line commands"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`en`__: true: enable recoloring, false: disable"]
    pub fn lv_label_set_recolor(label: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the label to draw (or not draw) background specified in its style's body"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`en`__: true: draw body; false: don't draw body"]
    pub fn lv_label_set_body_draw(label: *mut lv_obj_t, en: bool);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the label's animation speed in LV_LABEL_LONG_SROLL/SCROLL_CIRC modes"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`anim_speed`__: speed of animation in px/sec unit"]
    pub fn lv_label_set_anim_speed(label: *mut lv_obj_t, anim_speed: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Set the style of an label"]
    #[doc = " - __`label`__: pointer to an label object"]
    #[doc = " - __`type`__: which style should be get (can be only `LV_LABEL_STYLE_MAIN`)"]
    #[doc = " - __`style`__: pointer to a style"]
    pub fn lv_label_set_style(
        label: *mut lv_obj_t,
        type_: lv_label_style_t,
        style: *const lv_style_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @brief Set the selection start index."]
    #[doc = " - __`label`__: pointer to a label object."]
    #[doc = " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
    pub fn lv_label_set_text_sel_start(label: *mut lv_obj_t, index: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @brief Set the selection end index."]
    #[doc = " - __`label`__: pointer to a label object."]
    #[doc = " - __`index`__: index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
    pub fn lv_label_set_text_sel_end(label: *mut lv_obj_t, index: u16);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the text of a label"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " Return: the text of the label"]
    pub fn lv_label_get_text(label: *const lv_obj_t) -> *mut ::cty::c_char;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the long mode of a label"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " Return: the long mode"]
    pub fn lv_label_get_long_mode(label: *const lv_obj_t) -> lv_label_long_mode_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the align attribute"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " Return: LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER"]
    pub fn lv_label_get_align(label: *const lv_obj_t) -> lv_label_align_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the recoloring attribute"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " Return: true: recoloring is enabled, false: disable"]
    pub fn lv_label_get_recolor(label: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the body draw attribute"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " Return: true: draw body; false: don't draw body"]
    pub fn lv_label_get_body_draw(label: *const lv_obj_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the label's animation speed in LV_LABEL_LONG_ROLL and SCROLL modes"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " Return: speed of animation in px/sec unit"]
    pub fn lv_label_get_anim_speed(label: *const lv_obj_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the relative x and y coordinates of a letter"]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`index`__: index of the letter [0 ... text length]. Expressed in character index, not byte"]
    #[doc = " index (different in UTF-8)"]
    #[doc = " - __`pos`__: store the result here (E.g. index = 0 gives 0;0 coordinates)"]
    pub fn lv_label_get_letter_pos(label: *const lv_obj_t, index: u16, pos: *mut lv_point_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the index of letter on a relative point of a label"]
    #[doc = " - __`label`__: pointer to label object"]
    #[doc = " - __`pos`__: pointer to point with coordinates on a the label"]
    #[doc = " Return: the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)"]
    #[doc = " Expressed in character index and not byte index (different in UTF-8)"]
    pub fn lv_label_get_letter_on(label: *const lv_obj_t, pos: *mut lv_point_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Check if a character is drawn under a point."]
    #[doc = " - __`label`__: Label object"]
    #[doc = " - __`pos`__: Point to check for characte under"]
    #[doc = " Return: whether a character is drawn under the point"]
    pub fn lv_label_is_char_under_pos(label: *const lv_obj_t, pos: *mut lv_point_t) -> bool;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Get the style of an label object"]
    #[doc = " - __`label`__: pointer to an label object"]
    #[doc = " - __`type`__: which style should be get (can be only `LV_LABEL_STYLE_MAIN`)"]
    #[doc = " Return: pointer to the label's style"]
    pub fn lv_label_get_style(label: *const lv_obj_t, type_: lv_label_style_t)
        -> *const lv_style_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @brief Get the selection start index."]
    #[doc = " - __`label`__: pointer to a label object."]
    #[doc = " Return: selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
    pub fn lv_label_get_text_sel_start(label: *const lv_obj_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " @brief Get the selection end index."]
    #[doc = " - __`label`__: pointer to a label object."]
    #[doc = " Return: selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
    pub fn lv_label_get_text_sel_end(label: *const lv_obj_t) -> u16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Insert a text to the label. The label text can not be static."]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
    #[doc = " in UTF-8) 0: before first char. LV_LABEL_POS_LAST: after last char."]
    #[doc = " - __`txt`__: pointer to the text to insert"]
    pub fn lv_label_ins_text(label: *mut lv_obj_t, pos: u32, txt: *const ::cty::c_char);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Delete characters from a label. The label text can not be static."]
    #[doc = " - __`label`__: pointer to a label object"]
    #[doc = " - __`pos`__: character index to insert. Expressed in character index and not byte index (Different"]
    #[doc = " in UTF-8) 0: before first char."]
    #[doc = " - __`cnt`__: number of characters to cut"]
    pub fn lv_label_cut_text(label: *mut lv_obj_t, pos: u32, cnt: u32);
}
