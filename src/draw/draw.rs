/* automatically generated by rust-bindgen */

use
super::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LV_DRAW_LABEL_NO_TXT_SEL: u32 = 65535;
pub type lv_coord_t = i16;
pub type lv_font_user_data_t = *mut ::cty::c_void;
#[doc = " Represents a point on the screen."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_point_t {
    pub x: lv_coord_t,
    pub y: lv_coord_t,
}
#[doc = " Represents an area of the screen."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
pub type lv_align_t = u8;
#[doc = " Describes the properties of a glyph."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_font_glyph_dsc_t {
    #[doc = "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
    pub adv_w: u16,
    #[doc = "< Width of the glyph's bounding box"]
    pub box_w: u16,
    #[doc = "< Height of the glyph's bounding box"]
    pub box_h: u16,
    #[doc = "< x offset of the bounding box"]
    pub ofs_x: i16,
    #[doc = "< y offset of the bounding box"]
    pub ofs_y: i16,
    #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
    pub bpp: u8,
}
#[doc = " Describe the properties of a font"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_font_struct {
    #[doc = " Get a glyph's  descriptor from a font"]
    pub get_glyph_dsc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const _lv_font_struct,
            arg2: *mut lv_font_glyph_dsc_t,
            letter: u32,
            letter_next: u32,
        ) -> bool,
    >,
    #[doc = " Get a glyph's bitmap from a font"]
    pub get_glyph_bitmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const _lv_font_struct, arg2: u32) -> *const u8,
    >,
    #[doc = "< The real line height where any text fits"]
    pub line_height: lv_coord_t,
    #[doc = "< Base line measured from the top of the line_height"]
    pub base_line: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Distance between the top of the underline and base line (< 0 means below the base line)"]
    pub underline_position: i8,
    #[doc = "< Thickness of the underline"]
    pub underline_thickness: i8,
    #[doc = "< Store implementation specific or run_time data or caching here"]
    pub dsc: *mut ::cty::c_void,
    #[doc = "< Custom user data for font."]
    pub user_data: lv_font_user_data_t,
}
impl Default for _lv_font_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl _lv_font_struct {
    #[inline]
    pub fn subpx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_subpx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subpx: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let subpx: u8 = unsafe { ::core::mem::transmute(subpx) };
            subpx as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_font_t = _lv_font_struct;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_sqrt_res_t {
    pub i: u16,
    pub f: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color16_t {
    pub ch: lv_color16_t__bindgen_ty_1,
    pub full: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default, Copy, Clone)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn green_h(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_h(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green_l(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_green_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        green_h: u16,
        red: u16,
        blue: u16,
        green_l: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let green_h: u16 = unsafe { ::core::mem::transmute(green_h) };
            green_h as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let green_l: u16 = unsafe { ::core::mem::transmute(green_l) };
            green_l as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for lv_color16_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_color_t = lv_color16_t;
#[doc = "! @cond Doxygen_Suppress"]
pub type lv_opa_t = u8;
pub const LV_DRAW_MASK_RES_TRANSP: _bindgen_ty_7 = 0;
pub const LV_DRAW_MASK_RES_FULL_COVER: _bindgen_ty_7 = 1;
pub const LV_DRAW_MASK_RES_CHANGED: _bindgen_ty_7 = 2;
pub const LV_DRAW_MASK_RES_UNKNOWN: _bindgen_ty_7 = 3;
#[doc = "      TYPEDEFS"]
pub type _bindgen_ty_7 = u32;
pub type lv_draw_mask_res_t = u8;
pub const LV_DRAW_MASK_TYPE_LINE: _bindgen_ty_8 = 0;
pub const LV_DRAW_MASK_TYPE_ANGLE: _bindgen_ty_8 = 1;
pub const LV_DRAW_MASK_TYPE_RADIUS: _bindgen_ty_8 = 2;
pub const LV_DRAW_MASK_TYPE_FADE: _bindgen_ty_8 = 3;
pub const LV_DRAW_MASK_TYPE_MAP: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = u32;
pub type lv_draw_mask_type_t = u8;
pub const LV_DRAW_MASK_LINE_SIDE_LEFT: _bindgen_ty_9 = 0;
pub const LV_DRAW_MASK_LINE_SIDE_RIGHT: _bindgen_ty_9 = 1;
pub const LV_DRAW_MASK_LINE_SIDE_TOP: _bindgen_ty_9 = 2;
pub const LV_DRAW_MASK_LINE_SIDE_BOTTOM: _bindgen_ty_9 = 3;
pub type _bindgen_ty_9 = u32;
#[doc = " A common callback type for every mask type."]
#[doc = " Used internally by the library."]
pub type lv_draw_mask_xcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        mask_buf: *mut lv_opa_t,
        abs_x: lv_coord_t,
        abs_y: lv_coord_t,
        len: lv_coord_t,
        p: *mut ::cty::c_void,
    ) -> lv_draw_mask_res_t,
>;
pub type lv_draw_mask_line_side_t = u8;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_common_dsc_t {
    pub cb: lv_draw_mask_xcb_t,
    pub type_: lv_draw_mask_type_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_line_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_line_param_t__bindgen_ty_1,
    pub origo: lv_point_t,
    pub xy_steep: i32,
    pub yx_steep: i32,
    pub steep: i32,
    pub spx: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_line_param_t__bindgen_ty_1 {
    pub p1: lv_point_t,
    pub p2: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_draw_mask_line_param_t__bindgen_ty_1 {
    #[inline]
    pub fn side(&self) -> lv_draw_mask_line_side_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_side(&mut self, val: lv_draw_mask_line_side_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        side: lv_draw_mask_line_side_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let side: u8 = unsafe { ::core::mem::transmute(side) };
            side as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_draw_mask_line_param_t {
    #[inline]
    pub fn flat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(flat: u8, inv: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flat: u8 = unsafe { ::core::mem::transmute(flat) };
            flat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inv: u8 = unsafe { ::core::mem::transmute(inv) };
            inv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_angle_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_angle_param_t__bindgen_ty_1,
    pub start_line: lv_draw_mask_line_param_t,
    pub end_line: lv_draw_mask_line_param_t,
    pub delta_deg: u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_angle_param_t__bindgen_ty_1 {
    pub vertex_p: lv_point_t,
    pub start_angle: lv_coord_t,
    pub end_angle: lv_coord_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_radius_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_radius_param_t__bindgen_ty_1,
    pub y_prev: i32,
    pub y_prev_x: lv_sqrt_res_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_radius_param_t__bindgen_ty_1 {
    pub rect: lv_area_t,
    pub radius: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_draw_mask_radius_param_t__bindgen_ty_1 {
    #[inline]
    pub fn outer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_outer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(outer: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outer: u8 = unsafe { ::core::mem::transmute(outer) };
            outer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_fade_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_fade_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_mask_fade_param_t__bindgen_ty_1 {
    pub coords: lv_area_t,
    pub y_top: lv_coord_t,
    pub y_bottom: lv_coord_t,
    pub opa_top: lv_opa_t,
    pub opa_bottom: lv_opa_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_draw_mask_map_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: _lv_draw_mask_map_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_draw_mask_map_param_t__bindgen_ty_1 {
    pub coords: lv_area_t,
    pub map: *const lv_opa_t,
}
impl Default for _lv_draw_mask_map_param_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _lv_draw_mask_map_param_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type lv_draw_mask_map_param_t = _lv_draw_mask_map_param_t;
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Add a draw mask. Everything drawn after it (until removing the mask) will be affected by the mask."]
    #[doc = " - __`param`__: an initialized mask parameter. Only the pointer is saved."]
    #[doc = " - __`custom_id`__: a custom pointer to identify the mask. Used in `lv_draw_mask_remove_custom`."]
    #[doc = " Return: the an integer, the ID of the mask. Can be used in `lv_draw_mask_remove_id`."]
    pub fn lv_draw_mask_add(param: *mut ::cty::c_void, custom_id: *mut ::cty::c_void) -> i16;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Apply the added buffers on a line. Used internally by the library's drawing routines."]
    #[doc = " - __`mask_buf`__: store the result mask here. Has to be `len` byte long. Should be initialized with `0xFF`."]
    #[doc = " - __`abs_x`__: absolute X coordinate where the line to calculate start"]
    #[doc = " - __`abs_y`__: absolute Y coordinate where the line to calculate start"]
    #[doc = " - __`len`__: length of the line to calculate (in pixel count)"]
    #[doc = " Return: One of these values:"]
    #[doc = " - `LV_DRAW_MASK_RES_FULL_TRANSP`: the whole line is transparent. `mask_buf` is not set to zero"]
    #[doc = " - `LV_DRAW_MASK_RES_FULL_COVER`: the whole line is fully visible. `mask_buf` is unchanged"]
    #[doc = " - `LV_DRAW_MASK_RES_CHANGED`: `mask_buf` has changed, it shows the desired opacity of each pixel in the given line"]
    pub fn lv_draw_mask_apply(
        mask_buf: *mut lv_opa_t,
        abs_x: lv_coord_t,
        abs_y: lv_coord_t,
        len: lv_coord_t,
    ) -> lv_draw_mask_res_t;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove a mask with a given ID"]
    #[doc = " - __`id`__: the ID of the mask.  Returned by `lv_draw_mask_add`"]
    #[doc = " Return: the parameter of the removed mask."]
    #[doc = " If more masks have `custom_id` ID then the last mask's parameter will be returned"]
    pub fn lv_draw_mask_remove_id(id: i16) -> *mut ::cty::c_void;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Remove all mask with a given custom ID"]
    #[doc = " - __`custom_id`__: a pointer used in `lv_draw_mask_add`"]
    #[doc = " Return: return the parameter of the removed mask."]
    #[doc = " If more masks have `custom_id` ID then the last mask's parameter will be returned"]
    pub fn lv_draw_mask_remove_custom(custom_id: *mut ::cty::c_void) -> *mut ::cty::c_void;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Count the currently added masks"]
    #[doc = " Return: number of active masks"]
    pub fn lv_draw_mask_get_cnt() -> u8;
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = "Initialize a line mask from two points."]
    #[doc = " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
    #[doc = " - __`p1x`__: X coordinate of the first point of the line"]
    #[doc = " - __`p1y`__: Y coordinate of the first point of the line"]
    #[doc = " - __`p2x`__: X coordinate of the second point of the line"]
    #[doc = " - __`p2y`__: y coordinate of the second point of the line"]
    #[doc = " - __`side`__: and element of `lv_draw_mask_line_side_t` to describe which side to keep."]
    #[doc = " With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept"]
    #[doc = " With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept"]
    pub fn lv_draw_mask_line_points_init(
        param: *mut lv_draw_mask_line_param_t,
        p1x: lv_coord_t,
        p1y: lv_coord_t,
        p2x: lv_coord_t,
        p2y: lv_coord_t,
        side: lv_draw_mask_line_side_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = "Initialize a line mask from a point and an angle."]
    #[doc = " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
    #[doc = " - __`px`__: X coordinate of a point of the line"]
    #[doc = " - __`py`__: X coordinate of a point of the line"]
    #[doc = " - __`angle`__: right 0 deg, bottom: 90"]
    #[doc = " - __`side`__: and element of `lv_draw_mask_line_side_t` to describe which side to keep."]
    #[doc = " With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept"]
    #[doc = " With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept"]
    pub fn lv_draw_mask_line_angle_init(
        param: *mut lv_draw_mask_line_param_t,
        p1x: lv_coord_t,
        py: lv_coord_t,
        angle: i16,
        side: lv_draw_mask_line_side_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize an angle mask."]
    #[doc = " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
    #[doc = " - __`vertex_x`__: X coordinate of the angle vertex (absolute coordinates)"]
    #[doc = " - __`vertex_y`__: Y coordinate of the angle vertex (absolute coordinates)"]
    #[doc = " - __`start_angle`__: start angle in degrees. 0 deg on the right, 90 deg, on the bottom"]
    #[doc = " - __`end_angle`__: end angle"]
    pub fn lv_draw_mask_angle_init(
        param: *mut lv_draw_mask_angle_param_t,
        vertex_x: lv_coord_t,
        vertex_y: lv_coord_t,
        start_angle: lv_coord_t,
        end_angle: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a fade mask."]
    #[doc = " - __`param`__: param pointer to a `lv_draw_mask_param_t` to initialize"]
    #[doc = " - __`rect`__: coordinates of the rectangle to affect (absolute coordinates)"]
    #[doc = " - __`radius`__: radius of the rectangle"]
    #[doc = " - __`inv:`__: true: keep the pixels inside the rectangle; keep the pixels outside of the rectangle"]
    pub fn lv_draw_mask_radius_init(
        param: *mut lv_draw_mask_radius_param_t,
        rect: *const lv_area_t,
        radius: lv_coord_t,
        inv: bool,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a fade mask."]
    #[doc = " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
    #[doc = " - __`coords`__: coordinates of the area to affect (absolute coordinates)"]
    #[doc = " - __`opa_top`__: opacity on the top"]
    #[doc = " - __`y_top`__: at which coordinate start to change to opacity to `opa_bottom`"]
    #[doc = " - __`opa_bottom`__: opacity at the bottom"]
    #[doc = " - __`y_bottom`__: at which coordinate reach `opa_bottom`."]
    pub fn lv_draw_mask_fade_init(
        param: *mut lv_draw_mask_fade_param_t,
        coords: *const lv_area_t,
        opa_top: lv_opa_t,
        y_top: lv_coord_t,
        opa_bottom: lv_opa_t,
        y_bottom: lv_coord_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Initialize a map mask."]
    #[doc = " - __`param`__: pointer to a `lv_draw_mask_param_t` to initialize"]
    #[doc = " - __`coords`__: coordinates of the map (absolute coordinates)"]
    #[doc = " - __`map`__: array of bytes with the mask values"]
    pub fn lv_draw_mask_map_init(
        param: *mut lv_draw_mask_map_param_t,
        coords: *const lv_area_t,
        map: *const lv_opa_t,
    );
}
pub type lv_blend_mode_t = u8;
pub type lv_grad_dir_t = u8;
pub type lv_text_decor_t = u8;
pub type lv_style_int_t = i16;
pub type lv_txt_flag_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_rect_dsc_t {
    pub radius: lv_style_int_t,
    pub bg_color: lv_color_t,
    pub bg_grad_color: lv_color_t,
    pub bg_grad_dir: lv_grad_dir_t,
    pub bg_main_color_stop: lv_style_int_t,
    pub bg_grad_color_stop: lv_style_int_t,
    pub bg_opa: lv_opa_t,
    pub bg_blend_mode: lv_blend_mode_t,
    pub border_color: lv_color_t,
    pub border_width: lv_style_int_t,
    pub border_side: lv_style_int_t,
    pub border_opa: lv_opa_t,
    pub border_blend_mode: lv_blend_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub outline_color: lv_color_t,
    pub outline_width: lv_style_int_t,
    pub outline_pad: lv_style_int_t,
    pub outline_opa: lv_opa_t,
    pub outline_blend_mode: lv_blend_mode_t,
    pub shadow_color: lv_color_t,
    pub shadow_width: lv_style_int_t,
    pub shadow_ofs_x: lv_style_int_t,
    pub shadow_ofs_y: lv_style_int_t,
    pub shadow_spread: lv_style_int_t,
    pub shadow_opa: lv_opa_t,
    pub shadow_blend_mode: lv_blend_mode_t,
    pub pattern_image: *const ::cty::c_void,
    pub pattern_font: *const lv_font_t,
    pub pattern_recolor: lv_color_t,
    pub pattern_opa: lv_opa_t,
    pub pattern_recolor_opa: lv_opa_t,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub pattern_blend_mode: lv_blend_mode_t,
    pub value_str: *const ::cty::c_char,
    pub value_font: *const lv_font_t,
    pub value_opa: lv_opa_t,
    pub value_color: lv_color_t,
    pub value_ofs_x: lv_style_int_t,
    pub value_ofs_y: lv_style_int_t,
    pub value_letter_space: lv_style_int_t,
    pub value_line_space: lv_style_int_t,
    pub value_align: lv_align_t,
    pub value_blend_mode: lv_blend_mode_t,
}
impl Default for lv_draw_rect_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_draw_rect_dsc_t {
    #[inline]
    pub fn border_post(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_border_post(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(border_post: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let border_post: u8 = unsafe { ::core::mem::transmute(border_post) };
            border_post as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pattern_repeat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pattern_repeat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(pattern_repeat: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pattern_repeat: u8 = unsafe { ::core::mem::transmute(pattern_repeat) };
            pattern_repeat as u64
        });
        __bindgen_bitfield_unit
    }
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " GLOBAL PROTOTYPES"]
    pub fn lv_draw_rect_dsc_init(dsc: *mut lv_draw_rect_dsc_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Draw a rectangle"]
    #[doc = " - __`coords`__: the coordinates of the rectangle"]
    #[doc = " - __`mask`__: the rectangle will be drawn only in this mask"]
    #[doc = " - __`dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
    pub fn lv_draw_rect(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        dsc: *const lv_draw_rect_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Draw a pixel"]
    #[doc = " - __`point`__: the coordinates of the point to draw"]
    #[doc = " - __`mask`__: the pixel will be drawn only in this mask"]
    #[doc = " - __`style`__: pointer to a style"]
    pub fn lv_draw_px(
        point: *const lv_point_t,
        clip_area: *const lv_area_t,
        style: *const lv_style_t,
    );
}
pub type lv_bidi_dir_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_label_dsc_t {
    pub color: lv_color_t,
    pub sel_color: lv_color_t,
    pub font: *const lv_font_t,
    pub opa: lv_opa_t,
    pub line_space: lv_style_int_t,
    pub letter_space: lv_style_int_t,
    pub sel_start: u32,
    pub sel_end: u32,
    pub ofs_x: lv_coord_t,
    pub ofs_y: lv_coord_t,
    pub bidi_dir: lv_bidi_dir_t,
    pub flag: lv_txt_flag_t,
    pub decor: lv_text_decor_t,
    pub blend_mode: lv_blend_mode_t,
}
impl Default for lv_draw_label_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Store some info to speed up drawing of very large texts"]
#[doc = " It takes a lot of time to get the first visible character because"]
#[doc = " all the previous characters needs to be checked to calculate the positions."]
#[doc = " This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line."]
#[doc = " Therefore the calculations can start from here."]
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lv_draw_label_hint_t {
    #[doc = " Index of the line at `y` coordinate"]
    pub line_start: i32,
    #[doc = " Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates"]
    pub y: i32,
    #[doc = " The 'y1' coordinate of the label when the hint was saved."]
    #[doc = " Used to invalidate the hint if the label has moved too much."]
    pub coord_y: i32,
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = "! @cond Doxygen_Suppress"]
    pub fn lv_draw_label_dsc_init(dsc: *mut lv_draw_label_dsc_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Write a text"]
    #[doc = " - __`coords`__: coordinates of the label"]
    #[doc = " - __`mask`__: the label will be drawn only in this area"]
    #[doc = " - __`dsc`__: pointer to draw descriptor"]
    #[doc = " - __`txt`__: `\\0` terminated text to write"]
    #[doc = " - __`hint`__: pointer to a `lv_draw_label_hint_t` variable."]
    #[doc = " It is managed by the drawer to speed up the drawing of very long texts (thousands of lines)."]
    pub fn lv_draw_label(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        dsc: *const lv_draw_label_dsc_t,
        txt: *const ::cty::c_char,
        hint: *mut lv_draw_label_hint_t,
    );
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_img_dsc_t {
    pub opa: lv_opa_t,
    pub angle: u16,
    pub pivot: lv_point_t,
    pub zoom: u16,
    pub recolor_opa: lv_opa_t,
    pub recolor: lv_color_t,
    pub blend_mode: lv_blend_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl Default for lv_draw_img_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_draw_img_dsc_t {
    #[inline]
    pub fn antialias(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antialias(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(antialias: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialias: u8 = unsafe { ::core::mem::transmute(antialias) };
            antialias as u64
        });
        __bindgen_bitfield_unit
    }
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " GLOBAL PROTOTYPES"]
    pub fn lv_draw_img_dsc_init(dsc: *mut lv_draw_img_dsc_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Draw an image"]
    #[doc = " - __`coords`__: the coordinates of the image"]
    #[doc = " - __`mask`__: the image will be drawn only in this area"]
    #[doc = " - __`src`__: pointer to a lv_color_t array which contains the pixels of the image"]
    #[doc = " - __`dsc`__: pointer to an initialized `lv_draw_img_dsc_t` variable"]
    pub fn lv_draw_img(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        src: *const ::cty::c_void,
        dsc: *const lv_draw_img_dsc_t,
    );
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_line_dsc_t {
    pub color: lv_color_t,
    pub width: lv_style_int_t,
    pub dash_width: lv_style_int_t,
    pub dash_gap: lv_style_int_t,
    pub opa: lv_opa_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl Default for lv_draw_line_dsc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl lv_draw_line_dsc_t {
    #[inline]
    pub fn blend_mode(&self) -> lv_blend_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blend_mode(&mut self, val: lv_blend_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn round_start(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_round_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn round_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_round_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn raw_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_raw_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        blend_mode: lv_blend_mode_t,
        round_start: u8,
        round_end: u8,
        raw_end: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blend_mode: u8 = unsafe { ::core::mem::transmute(blend_mode) };
            blend_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let round_start: u8 = unsafe { ::core::mem::transmute(round_start) };
            round_start as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let round_end: u8 = unsafe { ::core::mem::transmute(round_end) };
            round_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let raw_end: u8 = unsafe { ::core::mem::transmute(raw_end) };
            raw_end as u64
        });
        __bindgen_bitfield_unit
    }
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = "! @cond Doxygen_Suppress"]
    #[doc = "**"]
    #[doc = "* Draw a line"]
    #[doc = "* - __`point1`__: first point of the line"]
    #[doc = "* - __`point2`__: second point of the line"]
    #[doc = "* - __`clip`__: the line will be drawn only in this area"]
    #[doc = "* - __`dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
    #[doc = "*/"]
    pub fn lv_draw_line(
        point1: *const lv_point_t,
        point2: *const lv_point_t,
        clip: *const lv_area_t,
        dsc: *const lv_draw_line_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    pub fn lv_draw_line_dsc_init(dsc: *mut lv_draw_line_dsc_t);
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Draw a triangle"]
    #[doc = " - __`points`__: pointer to an array with 3 points"]
    #[doc = " - __`clip_area`__: the triangle will be drawn only in this area"]
    #[doc = " - __`draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
    pub fn lv_draw_triangle(
        points: *const lv_point_t,
        clip: *const lv_area_t,
        draw_dsc: *const lv_draw_rect_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Draw a polygon. Only convex polygons are supported."]
    #[doc = " - __`points`__: an array of points"]
    #[doc = " - __`point_cnt`__: number of points"]
    #[doc = " - __`clip_area`__: polygon will be drawn only in this area"]
    #[doc = " - __`draw_dsc`__: pointer to an initialized `lv_draw_rect_dsc_t` variable"]
    pub fn lv_draw_polygon(
        points: *const lv_point_t,
        point_cnt: u16,
        mask: *const lv_area_t,
        draw_dsc: *const lv_draw_rect_dsc_t,
    );
}
#[lvgl_macros::safe_wrap(attr)] extern "C" {
    #[doc = " Draw an arc. (Can draw pie too with great thickness.)"]
    #[doc = " - __`center_x`__: the x coordinate of the center of the arc"]
    #[doc = " - __`center_y`__: the y coordinate of the center of the arc"]
    #[doc = " - __`radius`__: the radius of the arc"]
    #[doc = " - __`mask`__: the arc will be drawn only in this mask"]
    #[doc = " - __`start_angle`__: the start angle of the arc (0 deg on the bottom, 90 deg on the right)"]
    #[doc = " - __`end_angle`__: the end angle of the arc"]
    #[doc = " - __`clip_area`__: the arc will be drawn only in this area"]
    #[doc = " - __`dsc`__: pointer to an initialized `lv_draw_line_dsc_t` variable"]
    pub fn lv_draw_arc(
        center_x: lv_coord_t,
        center_y: lv_coord_t,
        radius: u16,
        start_angle: u16,
        end_angle: u16,
        clip_area: *const lv_area_t,
        dsc: *const lv_draw_line_dsc_t,
    );
}
